#if( ! @defined( fileclass_hhf ))
?fileclass_hhf := true;

#includeOnce( "fileio.hhf" )
#includeOnce( "_hla.hhf" )

/****************************************************/
/*                                                  */
/* 	The FILE class:                                 */
/*                                                  */
/****************************************************/



#if( !@defined( _deprecate_old_file_types_ ))

	const
		file		:text := "file_t";			// "file" is deprecated.
		virtualFile	:text := "virtualFile_t";	// "virtualFile" is deprecated.
		
#endif	

type
	virtualFile_t: 
		class

			var
				fileHandle:dword;


			proc
			
				create:
					procedure;
					@global:_hla._ext( "VFILECLASS_CREATE" );

				handle:
					method {@returns( "eax" )}; 
					@global:_hla._ext( "VFILECLASS_HANDLE" );

				open:
					method
					( 
						FileName	:string; 
						Access		:@global:fileio.accessMode 
					);
					@global:_hla._ext( "VFILECLASS_OPEN" );

				openNew:
					method( FileName: string );
					@global:_hla._ext( "VFILECLASS_OPENNEW" );
					
				write:
					method( var buffer:var; count:dword );
					@global:_hla._ext( "VFILECLASS_WRITE" );
					
				read:
					method( var buffer:var; count:dword );
					@global:_hla._ext( "VFILECLASS_READ" );
				
				close:
					method;
					@global:_hla._ext( "VFILECLASS_CLOSE" );
					
				eof:
					method {@returns( "al" )}; 
					@global:_hla._ext( "VFILECLASS_EOF" ); 


				readLn:
					method;
					@global:_hla._ext( "VFILECLASS_READLN" );
					
				eoln:
					method {@returns( "al" )}; 
					@global:_hla._ext( "VFILECLASS_EOLN" );

				getc:
					method {@returns( "al" )}; 
					@global:_hla._ext( "VFILECLASS_GETC" );
					
				gets:
					method( s:string );
					@global:_hla._ext( "VFILECLASS_GETS" );
					
				a_gets:
					method {@returns( "eax" )};
					@global:_hla._ext( "VFILECLASS_A_GETS" );

				geti8:
					method {@returns( "al" )}; 
					@global:_hla._ext( "VFILECLASS_GETI8" );
					
				geti16:
					method {@returns( "ax" )}; 
					@global:_hla._ext( "VFILECLASS_GETI16" );
					
				geti32:
					method {@returns( "eax" )}; 
					@global:_hla._ext( "VFILECLASS_GETI32" );
					
				geti64:
					method{@returns( "edx:eax" )}; 
					@global:_hla._ext( "VFILECLASS_GETI64" );

				geti128:
					method( var l:lword );
					@global:_hla._ext( "VFILECLASS_GETI128" );

				getu8:
					method {@returns( "al" )}; 
					@global:_hla._ext( "VFILECLASS_GETU8" );
					
				getu16:
					method {@returns( "ax" )}; 
					@global:_hla._ext( "VFILECLASS_GETU16" );
					
				getu32:
					method {@returns( "eax" )}; 
					@global:_hla._ext( "VFILECLASS_GETU32" );
					
				getu64:
					method{@returns( "edx:eax" )}; 
					@global:_hla._ext( "VFILECLASS_GETU64" );

				getu128:
					method( var l:lword );
					@global:_hla._ext( "VFILECLASS_GETU128" );

				geth8:
					method {@returns( "al" )}; 
					@global:_hla._ext( "VFILECLASS_GETH8" );
					
				geth16:
					method {@returns( "ax" )}; 
					@global:_hla._ext( "VFILECLASS_GETH16" );
					
				geth32:
					method {@returns( "eax" )}; 
					@global:_hla._ext( "VFILECLASS_GETH32" );
					
				geth64:
					method{@returns( "edx:eax" )}; 
					@global:_hla._ext( "VFILECLASS_GETH64" );
					
				geth128:
					method( var l:lword );
					@global:_hla._ext( "VFILECLASS_GETH128" );

				getf:
					method {@returns( "st0" )}; 
					@global:_hla._ext( "VFILECLASS_GETF" );



				putbool:
					method( b:boolean );
					@global:_hla._ext( "VFILECLASS_PUTBOOL" );
					
				putcset:
					method( cs:cset   );
					@global:_hla._ext( "VFILECLASS_PUTCSET" );

				putc:
					method( c:char    );
					@global:_hla._ext( "VFILECLASS_PUTC" );
					
				putcSize:
					method( c:char; width:int32; fill:char );
					@global:_hla._ext( "VFILECLASS_PUTCSIZE" );

				newln:
					method;
					@global:_hla._ext( "VFILECLASS_NEWLN" );

				puts:
					method( s:string  );
					@global:_hla._ext( "VFILECLASS_PUTS" );
					
				putsSize:
					method
					( 
						s:string; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTSSIZE" );

				putb:
					method( h:byte    );
					@global:_hla._ext( "VFILECLASS_PUTB" );
					
				putw:
					method( w:word 	  );
					@global:_hla._ext( "VFILECLASS_PUTW" );
					
				putd:
					method( dw:dword );
					@global:_hla._ext( "VFILECLASS_PUTD" );
					
				putq:
					method( qw:qword );
					@global:_hla._ext( "VFILECLASS_PUTQ" );
					
				puttb:
					method( tb:tbyte );
					@global:_hla._ext( "VFILECLASS_PUTTB" );
					
				putl:
					method( l:lword );
					@global:_hla._ext( "VFILECLASS_PUTL" );


				putbin8:
					method( h:byte    );
					@global:_hla._ext( "VFILECLASS_PUTBIN8" );
					

				puth8:
					method( h:byte    );
					@global:_hla._ext( "VFILECLASS_PUTH8" );
					
				puth16:
					method( w:word 	  );
					@global:_hla._ext( "VFILECLASS_PUTH16" );
					
				puth32:
					method( dw:dword );
					@global:_hla._ext( "VFILECLASS_PUTH32" );
					
				puth64:
					method( qw:qword );
					@global:_hla._ext( "VFILECLASS_PUTH64" );
					
				puth80:
					method( tb:tbyte );
					@global:_hla._ext( "VFILECLASS_PUTH80" );
					
				puth128:
					method( l:lword );
					@global:_hla._ext( "VFILECLASS_PUTH128" );

				puti8:
					method ( b:byte  );
					@global:_hla._ext( "VFILECLASS_PUTI8" );
					
				puti16:
					method( w:word  );
					@global:_hla._ext( "VFILECLASS_PUTI16" );
					
				puti32:
					method( d:dword );
					@global:_hla._ext( "VFILECLASS_PUTI32" );
			
				puti64:
					method( q:qword );
					@global:_hla._ext( "VFILECLASS_PUTI64" );
					
				puti128:
					method( l:lword );
					@global:_hla._ext( "VFILECLASS_PUTI128" );
					

				puth8Size:
					method
					( 
						b:byte; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTH8SIZE" );

				puth16Size:
					method
					( 
						w:word; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTH16SIZE" );

				puth32Size:
					method
					( 
						d:dword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTH32SIZE" );
				
				puth64Size:
					method
					( 
						q:qword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTH64SIZE" );

				puth80Size:
					method
					( 
						tb:tbyte; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTH80SIZE" );

				puth128Size:
					method
					( 
						l:lword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTH128SIZE" );


				puti8Size:
					method 
					( 
						b:byte;  
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTI8SIZE" );

				puti16Size:
					method
					( 
						w:word;  
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTI16SIZE" );

				puti32Size:
					method
					( 
						d:dword; 
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTI32SIZE" );

				puti64Size:
					method
					( 
						q:qword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTI64SIZE" );

				puti128Size:
					method
					( 
						l:lword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTI128SIZE" );

				putu8:
					method ( b:byte  );
					@global:_hla._ext( "VFILECLASS_PUTU8" );
					
				putu16:
					method( w:word  );
					@global:_hla._ext( "VFILECLASS_PUTU16" );
					
				putu32:
					method( d:dword );
					@global:_hla._ext( "VFILECLASS_PUTU32" );
					
				putu64:
					method( q:qword );
					@global:_hla._ext( "VFILECLASS_PUTU64" );
					
				putu128:
					method( l:lword );
					@global:_hla._ext( "VFILECLASS_PUTU128" );

				putu8Size:
					method 
					( 
						b:byte;  
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTU8SIZE" );

				putu16Size:
					method
					( 
						w:word;  
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTU16SIZE" );

				putu32Size:
					method
					( 
						d:dword; 
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTU32SIZE" );

				putu64Size:
					method
					( 
						q:qword; 
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTU64SIZE" );

				putu128Size:
					method
					( 
						l:lword; 
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTU128SIZE" );


				putr32:
					method
					( 
						r:real32; 
						width:uns32; 
						decpts:uns32;
						fill	:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTR32" );

				putr64:
					method
					( 
						r:real64; 
						width:uns32; 
						decpts:uns32;
						fill	:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTR64" );

				putr80:
					method
					( 
						r		:real80; 
						width	:uns32; 
						decpts	:uns32;
						fill	:char 
					);
					@global:_hla._ext( "VFILECLASS_PUTR80" );



				pute32:
					method
					( 
						r:real32; 
						width:uns32 
					);
					@global:_hla._ext( "VFILECLASS_PUTE32" );

				pute64:
					method
					( 
						r:real64; 
						width:uns32 
					);
					@global:_hla._ext( "VFILECLASS_PUTE64" );

				pute80:
					method
					( 
						r:real80; 
						width:uns32 
					);
					@global:_hla._ext( "VFILECLASS_PUTE80" );



				sPutPad:
					method( fill:char; size:uns32 );
					@global:_hla._ext( "VFILECLASS_SPUTPAD" );


			// _put_ is used by the put macro to emit the correct
			// call depending upon the presence of width and decpts
			// parameters in addition to the value to output.

			#macro _put_( _obj_, _routine_, _typename_ );
						_invoke_, _func_, _parms_, _realsize_, _typ_;

				?_func_:string := @string:_routine_;
				?_parms_:string := "";
				?_typ_:string := @string:_typename_;

				// Real values allow two size parameters 
				// (width & decpts).

				#if( @substr( _typ_, 0, 4 ) = "real" )

					#if( _width_ <> "-1" )

						?_realsize_:string := @substr( _typ_, 4, 2 );

						// If decpts is <> -1, print in dec notation,
						// else print in sci notation.

						#if( _decpts_ <> "-1" )

							?_parms_:string := 
								"," + _width_ + "," + _decpts_ + ", ' '";
							
						#else
						 
							?_func_:string := "pute" + _realsize_;
							?_parms_:string := "," + _width_;

						#endif

					#else

						// If the user did not specify a format size,
						// then use the puteXX routines with default
						// sizes of: real32=15, real64=22, real80=28.

						?_func_:string := "pute" + _realsize_;
						#if( _realsize_ = "32" )

							?_parms_:string := ",15";

						#elseif( _realsize_ = "64" )

							?_parms_:string := ",22";

						#else

							?_parms_:string := ",28";

						#endif

					#endif

				#else //It's not a real type.

					#if( _decpts_ <> "-1" )

						#error
						( 
							"Fractional width specification "
							"is not supported here" 
						)

					#elseif( _width_ <> "-1" )

						// Width specifications are only supported for
						// certain types.  Check for that here.

						#if
						(
								_typ_ <> "uns8"
							&	_typ_ <> "uns16"
							&	_typ_ <> "uns32"
							&	_typ_ <> "int8"
							&	_typ_ <> "int16"
							&	_typ_ <> "int32"
							&	_typ_ <> "char"
							&	_typ_ <> "string"
							&	_typ_ <> "byte"
							&	_typ_ <> "word"
							&	_typ_ <> "dword"
							&	_typ_ <> "qword"
						)

							#error
							( 
								"Type " + 
								_typ_ + 
								" does not support width format "
								"option" 
							)

						#else

							?_func_:string := _func_ + "Size";
							?_parms_:string := "," + _width_ + ", ' '";

						#endif

					#endif

				#endif
							
				#if(
						@isconst( @text( _arg_ ))
					&	_typ_ = "string"
					&	_arg_ = "#13 #10"
				)

					_obj_.newln();

				#elseif( @isconst( @text( _arg_ )))

					?_invoke_:text := @string( _obj_ ) + "." +_func_;
					_invoke_( @text( _arg_ ) @text( _parms_ ));

				#else

					?_invoke_:text := @string( _obj_ ) + "." + _func_;
					_invoke_
					( 
						(type _typename_ @text( _arg_ )) @text( _parms_ )
					);

				#endif

			#endmacro



			#macro put( _parms_[] ): 
				_curparm_, _pType_, _arg_, _width_, _decpts_, 
				_fVar_, _parmArray_, _id_, _fieldCnt_;

				// Preserved ESI and EDI across all the
				// calls in this macro.

				push( esi );
				push( edi );

				?_fVar_:text := @LastObject;

				?_curparm_:uns32 := 0;
				#while( _curparm_ < @elements( _parms_ ))

					// The following stmt frees up any storage
					// currently in use by parmArray.

					?_parmArray_:uns32 := 0;

					// Get the current parameter into parmArray.

					?_parmArray_ :=	@tokenize
									(
										_parms_[ _curparm_ ],
										0,
										{':'},
										{
											'"',
											'''',
											'[',
											']',
											'(',
											');,
											'{',
											'}'
										}
									);

					?_arg_ := @trim( _parmArray_[ 0 ], 0 );
					#if( char( _arg_ ) in stdio._idchars_ )

						?_id_ := stdio._GetID_( _arg_ );
						#if
						(
								@class( _id_ ) = hla.cConstant
							|	@class( _id_ ) = hla.cValue
						)

							?_id_ := _arg_;

						#endif

					#else

						?_id_ := _arg_;

					#endif

					?_fieldCnt_ := @elements( _parmArray_ );
					#if( _fieldCnt_ > 1 )

						?_width_ := @trim( _parmArray_[ 1 ], 0 );

					#else

						?_width_ := "-1";

					#endif
					#if( _fieldCnt_ > 2 )

						?_decpts_ := @trim( _parmArray_[ 2 ], 0 );

					#else

						?_decpts_ := "-1";

					#endif
					#if( _fieldCnt_ > 3 )

						#error
						(
							"<<" + _parms_[ _curparm_ ] + ">>" +
							" has too many width fields"
						)

					#endif
					
					?_pType_ := @pType(  @text( _id_ ));
					#if( _pType_ = hla.ptArray )

						?_pType_ := 
							@pType( @text( @typename( @text( _id_))));

					#endif

					#if( _pType_ = hla.ptBoolean )
					 
						file._put_( _fVar_, putbool, boolean )

					#elseif( _pType_ = hla.ptUns8 )
					 
						file._put_( _fVar_, putu8, uns8 )

					#elseif( _pType_ = hla.ptUns16 ) 
					
						file._put_( _fVar_, putu16, uns16 )

					#elseif( _pType_ = hla.ptUns32 ) 
					
						file._put_( _fVar_, putu32, uns32 )

					#elseif( _pType_ = hla.ptByte ) 
					
						file._put_( _fVar_, putb, byte )

					#elseif( _pType_ = hla.ptWord ) 
					
						file._put_( _fVar_, putw, word )

					#elseif( _pType_ = hla.ptDWord ) 
					
						file._put_( _fVar_, putd, dword )

					#elseif( _pType_ = hla.ptInt8 ) 
					
						file._put_( _fVar_, puti8, int8 )

					#elseif( _pType_ = hla.ptInt16 ) 
					
						file._put_( _fVar_, puti16, int16 )

					#elseif( _pType_ = hla.ptInt32 ) 
					
						file._put_( _fVar_, puti32, int32 )

					#elseif( _pType_ = hla.ptChar ) 
					
						file._put_( _fVar_, putc, char )

					#elseif( _pType_ = hla.ptCset ) 
					
						file._put_( _fVar_, putcset, cset )

					#elseif( _pType_ = hla.ptReal32 ) 
					
						file._put_( _fVar_, putr32, real32 )

					#elseif( _pType_ = hla.ptReal64 ) 
					
						file._put_( _fVar_, putr64, real64 )

					#elseif( _pType_ = hla.ptReal80 ) 
					
						file._put_( _fVar_, putr80, real80 )

					#elseif( _pType_ = hla.ptString )

						file._put_( _fVar_, puts, string )


					#elseif( @isclass( @text( _parms_[ _curparm_ ] )))

						#if
						( 
							@defined
							( 
								@text
								(
									 _parms_[ _curparm_ ] + 
									".toString" 
								)
							)
						)

							push( eax );
							push( esi );
							push( edi );
							@text
							( 
								_parms_[ _curparm_ ] + 
								".toString()"
							);
							_fVar_.puts( eax );
							strfree( eax );
							pop( edi );
							pop( esi );
							pop( eax );

						#else

							#error
							(
								"file.put: Class does not provide a "
								"toString or:
				method procedure"
							);

						#endif

					#else

						#error
						( 
							"file.put: Unknown data type (" +
							_parms_[ _curparm_ ] +
							":" +
							@typename( @text( _parms_[_curparm_] )) +
							")"
						);

					#endif
					?_curparm_ := _curparm_ + 1;

				#endwhile

				pop( edi );
				pop( esi );

			#endmacro



			#macro get( _parms_[] ): 
				_curparm_, _pType_, _arg_, _id_, _fVar_;

				?_curparm_:uns32 := 0;
				?_fVar_:text := @LastObject;
				
				// Save important registers that the "GET" macro uses.

				push( eax );
				push( esi );
				push( edi );

				// The following loop repeats once for each GET parameter
				// we process.

				#while( _curparm_ < @elements( _parms_ ))

					// If this parameter begins with an identifier,
					// there are some problems to deal with.
					// The symbol table functions (e.g., @ptype) don't
					// allow address expression components after the
					// symbol name.  Named constants, however, do allow
					// such entities.  The following code determines
					// (1) is this a symbol?  (2) if it is a symbol, is
					// it a constant?
					//
					//	For non-constant symbols, we need to strip any
					// trailing non-symbol characters from the string
					// (e.g., "[0]" ).

					?_arg_ := @trim( _parms_[ _curparm_ ], 0 );
					#if( char( _arg_ ) in stdio._idchars_ )

						// If this parameter begins with an id character,
						// then strip away any non-ID symbols from the
						// end of the string.  Then determine if we've
						// got a constant or some other class (e.g.,
						// variable or procedure).  If not a constant,
						// keep only the name.  If a constant, we need
						// to keep all trailing characters as well.

						?_id_ := stdio._GetID_( _arg_ );
						#if
						( 
								@class( _id_ ) = hla.cConstant 
							|	@class( _id_ ) = hla.cValue 
						)

							?_id_ := _arg_;

						#endif

					#else

						// If it's not an ID, we need to keep everything.

						?_id_ := _arg_;

					#endif



					// Determine the type of this parameter so we can
					// call the appropriate routine to input it.

					?_pType_ := @pType( @text( _id_ ));
					#if( _pType_ = hla.ptArray )

						?_pType_ := 
							@pType( @text( @typename( @text( _id_ ))));

					#endif

					// Based on the type, call the appropriate library
					// routine to print this value.

					#if( _pType_ = hla.ptBoolean )

						#error( "Boolean input is not supported" );

					#elseif( _pType_ = hla.ptUns8 ) 
						
						_fVar_.getu8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = hla.ptUns16 ) 
						
						_fVar_.getu16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptUns32 ) 
						
						_fVar_.getu32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptByte ) 
						
						_fVar_.geth8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = hla.ptWord ) 
						
						_fVar_.geth16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptDWord ) 
						
						_fVar_.geth32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptInt8 ) 
						
						_fVar_.geti8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = hla.ptInt16 ) 
						
						_fVar_.geti16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptInt32 ) 
						
						_fVar_.geti32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptChar ) 
						
						_fVar_.getc();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = hla.ptCset ) 

						#error( "Cset input is not supported" );

					#elseif
					( 
							_pType_ = hla.ptReal32 
						|	_pType_ = hla.ptReal64 
						|	_pType_ = hla.ptReal80 
					) 
						
						_fVar_.getf();
						fstp( @text( _arg_ ));

					#elseif( _pType_ = hla.ptString ) 

						_fVar_.gets( @text( _arg_ ));

					#else

						#error
						( 
							"stdin.get: Unknown data type (" +
							_parms_[ _curparm_ ] +
							":" +
							@typename( @text( _id_ )) +
							")"
						);

					#endif
					?_curparm_ := _curparm_ + 1;

				#endwhile

				// Restore the registers pushed earlier for this 
				// call to the GET macro.

				pop( edi );
				pop( esi );
				pop( eax );

			#endmacro



		endclass;







	file_t: 
		class

			var
				fileHandle:dword;
				
			proc

				create:
					procedure;
					@global:_hla._ext( "FILECLASS_CREATE" );

				handle:
					procedure { @returns( "eax" ) }; 
					@global:_hla._ext( "FILECLASS_HANDLE" );

				open:
					procedure
					( 
						FileName	:string; 
						Access		:@global:fileio.accessMode 
					);
					@global:_hla._ext( "FILECLASS_OPEN" );

				openNew:
					procedure( FileName: string );
					@global:_hla._ext( "FILECLASS_OPENNEW" );
					
				write:
					procedure( var buffer:var; count:dword );
					@global:_hla._ext( "FILECLASS_WRITE" );
					
				read:
					procedure( var buffer:var; count:dword );
					@global:_hla._ext( "FILECLASS_READ" );
				
				close:
					procedure;
					@global:_hla._ext( "FILECLASS_CLOSE" );
					
				eof:
					procedure { @returns( "al") }; 
					@global:_hla._ext( "FILECLASS_EOF" ); 


				readLn:
					procedure;
					@global:_hla._ext( "FILECLASS_READLN" );
					
				eoln:
					procedure { @returns( "al") }; 
					@global:_hla._ext( "FILECLASS_EOLN" );

				getc:
					procedure { @returns( "al") }; 
					@global:_hla._ext( "FILECLASS_GETC" );
					
				gets:
					procedure( s:string );
					@global:_hla._ext( "FILECLASS_GETS" );
					
				a_gets:
					procedure { @returns( "eax" ) };
					@global:_hla._ext( "FILECLASS_A_GETS" );

				geti8:
					procedure { @returns( "al") }; 
					@global:_hla._ext( "FILECLASS_GETI8" );
					
				geti16:
					procedure { @returns( "ax") }; 
					@global:_hla._ext( "FILECLASS_GETI16" );
					
				geti32:
					procedure { @returns( "eax" ) }; 
					@global:_hla._ext( "FILECLASS_GETI32" );
					
				geti64:
					procedure { @returns( "edx:eax") }; 
					@global:_hla._ext( "FILECLASS_GETI64" );

				geti128:
					procedure( var l:lword );
					@global:_hla._ext( "FILECLASS_GETI128" );

				getu8:
					procedure { @returns( "al") }; 
					@global:_hla._ext( "FILECLASS_GETU8" );
					
				getu16:
					procedure { @returns( "ax") }; 
					@global:_hla._ext( "FILECLASS_GETU16" );
					
				getu32:
					procedure { @returns( "eax" ) }; 
					@global:_hla._ext( "FILECLASS_GETU32" );
					
				getu64:
					procedure { @returns( "edx:eax") }; 
					@global:_hla._ext( "FILECLASS_GETU64" );

				getu128:
					procedure( var l:lword );
					@global:_hla._ext( "FILECLASS_GETU128" );

				geth8:
					procedure { @returns( "al") }; 
					@global:_hla._ext( "FILECLASS_GETH8" );
					
				geth16:
					procedure { @returns( "ax") }; 
					@global:_hla._ext( "FILECLASS_GETH16" );
					
				geth32:
					procedure { @returns( "eax" ) }; 
					@global:_hla._ext( "FILECLASS_GETH32" );
					
				geth64:
					procedure { @returns( "edx:eax") }; 
					@global:_hla._ext( "FILECLASS_GETH64" );
					
				geth128:
					procedure( var l:lword );
					@global:_hla._ext( "FILECLASS_GETH128" );

				getf:
					procedure {@returns( "st0" )}; 
					@global:_hla._ext( "FILECLASS_GETF" );



				putbool:
					procedure( b:boolean );
					@global:_hla._ext( "FILECLASS_PUTBOOL" );
					
				putcset:
					procedure( cs:cset   );
					@global:_hla._ext( "FILECLASS_PUTCSET" );

				putc:
					procedure( c:char    );
					@global:_hla._ext( "FILECLASS_PUTC" );
					
				putcSize:
					procedure( c:char; width:int32; fill:char );
					@global:_hla._ext( "FILECLASS_PUTCSIZE" );

				newln:
					procedure;
					@global:_hla._ext( "FILECLASS_NEWLN" );

				puts:
					procedure( s:string  );
					@global:_hla._ext( "FILECLASS_PUTS" );
					
				putsSize:
					procedure
					( 
						s:string; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTSSIZE" );

				putb:
					procedure( h:byte    );
					@global:_hla._ext( "FILECLASS_PUTB" );
					
				putw:
					procedure( w:word 	  );
					@global:_hla._ext( "FILECLASS_PUTW" );
					
				putd:
					procedure( dw:dword );
					@global:_hla._ext( "FILECLASS_PUTD" );
					
				putq:
					procedure( qw:qword );
					@global:_hla._ext( "FILECLASS_PUTQ" );
					
				puttb:
					procedure( tb:tbyte );
					@global:_hla._ext( "FILECLASS_PUTTB" );
					
				putl:
					procedure( l:lword );
					@global:_hla._ext( "FILECLASS_PUTL" );


				putbin8:
					procedure( h:byte    );
					@global:_hla._ext( "FILECLASS_PUTBIN8" );
					

				puth8:
					procedure( h:byte    );
					@global:_hla._ext( "FILECLASS_PUTH8" );
					
				puth16:
					procedure( w:word 	  );
					@global:_hla._ext( "FILECLASS_PUTH16" );
					
				puth32:
					procedure( dw:dword );
					@global:_hla._ext( "FILECLASS_PUTH32" );
					
				puth64:
					procedure( qw:qword );
					@global:_hla._ext( "FILECLASS_PUTH64" );
					
				puth80:
					procedure( tb:tbyte );
					@global:_hla._ext( "FILECLASS_PUTH80" );
					
				puth128:
					procedure( l:lword );
					@global:_hla._ext( "FILECLASS_PUTH128" );

				puti8:
					procedure ( b:byte  );
					@global:_hla._ext( "FILECLASS_PUTI8" );
					
				puti16:
					procedure( w:word  );
					@global:_hla._ext( "FILECLASS_PUTI16" );
					
				puti32:
					procedure( d:dword );
					@global:_hla._ext( "FILECLASS_PUTI32" );
			
				puti64:
					procedure( q:qword );
					@global:_hla._ext( "FILECLASS_PUTI64" );
					
				puti128:
					procedure( l:lword );
					@global:_hla._ext( "FILECLASS_PUTI128" );
					

				puth8Size:
					procedure
					( 
						b:byte; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTH8SIZE" );

				puth16Size:
					procedure
					( 
						w:word; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTH16SIZE" );

				puth32Size:
					procedure
					( 
						d:dword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTH32SIZE" );
				
				puth64Size:
					procedure
					( 
						q:qword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTH64SIZE" );

				puth80Size:
					procedure
					( 
						tb:tbyte; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTH80SIZE" );

				puth128Size:
					procedure
					( 
						l:lword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTH128SIZE" );


				puti8Size:
					procedure 
					( 
						b:byte;  
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTI8SIZE" );

				puti16Size:
					procedure
					( 
						w:word;  
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTI16SIZE" );

				puti32Size:
					procedure
					( 
						d:dword; 
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTI32SIZE" );

				puti64Size:
					procedure
					( 
						q:qword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTI64SIZE" );

				puti128Size:
					procedure
					( 
						l:lword; 
						width:int32; 
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTI128SIZE" );

				putu8:
					procedure ( b:byte  );
					@global:_hla._ext( "FILECLASS_PUTU8" );
					
				putu16:
					procedure( w:word  );
					@global:_hla._ext( "FILECLASS_PUTU16" );
					
				putu32:
					procedure( d:dword );
					@global:_hla._ext( "FILECLASS_PUTU32" );
					
				putu64:
					procedure( q:qword );
					@global:_hla._ext( "FILECLASS_PUTU64" );
					
				putu128:
					procedure( l:lword );
					@global:_hla._ext( "FILECLASS_PUTU128" );

				putu8Size:
					procedure 
					( 
						b:byte;  
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTU8SIZE" );

				putu16Size:
					procedure
					( 
						w:word;  
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTU16SIZE" );

				putu32Size:
					procedure
					( 
						d:dword; 
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTU32SIZE" );

				putu64Size:
					procedure
					( 
						q:qword; 
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTU64SIZE" );

				putu128Size:
					procedure
					( 
						l:lword; 
						width:int32;	
						fill:char 
					);
					@global:_hla._ext( "FILECLASS_PUTU128SIZE" );


				putr32:
					procedure
					( 
						r:real32; 
						width:uns32; 
						decpts:uns32;
						fill	:char 
					);
					@global:_hla._ext( "FILECLASS_PUTR32" );

				putr64:
					procedure
					( 
						r:real64; 
						width:uns32; 
						decpts:uns32;
						fill	:char 
					);
					@global:_hla._ext( "FILECLASS_PUTR64" );

				putr80:
					procedure
					( 
						r		:real80; 
						width	:uns32; 
						decpts	:uns32;
						fill	:char 
					);
					@global:_hla._ext( "FILECLASS_PUTR80" );



				pute32:
					procedure
					( 
						r:real32; 
						width:uns32 
					);
					@global:_hla._ext( "FILECLASS_PUTE32" );

				pute64:
					procedure
					( 
						r:real64; 
						width:uns32 
					);
					@global:_hla._ext( "FILECLASS_PUTE64" );

				pute80:
					procedure
					( 
						r:real80; 
						width:uns32 
					);
					@global:_hla._ext( "FILECLASS_PUTE80" );




			// _put_ is used by the put macro to emit the correct
			// call depending upon the presence of width and decpts
			// parameters in addition to the value to output.

			#macro _put_( _obj_, _routine_, _typename_ ):
						_invoke_, _func_, _parms_, _realsize_, _typ_;

				?_func_:string := @string:_routine_;
				?_parms_:string := "";
				?_typ_:string := @string:_typename_;

				// Real values allow two size parameters 
				// (width & decpts).

				#if( @substr( _typ_, 0, 4 ) = "real" )

					#if( _width_ <> "-1" )

						?_realsize_:string := @substr( _typ_, 4, 2 );

						// If decpts is <> -1, print in dec notation,
						// else print in sci notation.

						#if( _decpts_ <> "-1" )

							?_parms_:string := 
								"," + _width_ + "," + _decpts_ + ", ' '";
							
						#else
						 
							?_func_:string := "pute" + _realsize_;
							?_parms_:string := "," + _width_;

						#endif

					#else

						// If the user did not specify a format size,
						// then use the puteXX routines with default
						// sizes of: real32=15, real64=22, real80=28.

						?_func_:string := "pute" + _realsize_;
						#if( _realsize_ = "32" )

							?_parms_:string := ",15";

						#elseif( _realsize_ = "64" )

							?_parms_:string := ",22";

						#else

							?_parms_:string := ",28";

						#endif

					#endif

				#else //It's not a real type.

					#if( _decpts_ <> "-1" )

						#error
						( 
							"Fractional width specification "
							"is not supported here" 
						)

					#elseif( _width_ <> "-1" )

						// Width specifications are only supported for
						// certain types.  Check for that here.

						#if
						(
								_typ_ <> "uns8"
							&	_typ_ <> "uns16"
							&	_typ_ <> "uns32"
							&	_typ_ <> "int8"
							&	_typ_ <> "int16"
							&	_typ_ <> "int32"
							&	_typ_ <> "char"
							&	_typ_ <> "string"
							&	_typ_ <> "byte"
							&	_typ_ <> "word"
							&	_typ_ <> "dword"
							&	_typ_ <> "qword"
						)

							#error
							( 
								"Type " + 
								_typ_ + 
								" does not support width format "
								"option" 
							)

						#else

							?_func_:string := _func_ + "Size";
							?_parms_:string := "," + _width_ + ", ' '";

						#endif

					#endif

				#endif
							
				#if(
						@isconst( @text( _arg_ ))
					&	_typ_ = "string"
					&	_arg_ = "#13 #10"
				)

					_obj_.newln();

				#elseif( @isconst( @text( _arg_ )))

					?_invoke_:text := @string( _obj_ ) + "." +_func_;
					_invoke_( @text( _arg_ ) @text( _parms_ ));

				#else

					?_invoke_:text := @string( _obj_ ) + "." + _func_;
					_invoke_
					( 
						(type _typename_ @text( _arg_ )) @text( _parms_ )
					);

				#endif

			#endmacro



			#macro put( _parms_[] ): 
				_curparm_, _pType_, _arg_, _width_, _decpts_, 
				_fVar_, _parmArray_, _id_, _fieldCnt_;

				// Preserved ESI and EDI across all the
				// calls in this macro.

				push( esi );
				push( edi );

				?_fVar_:text := @LastObject;

				?_curparm_:uns32 := 0;
				#while( _curparm_ < @elements( _parms_ ))

					// The following stmt frees up any storage
					// currently in use by parmArray.

					?_parmArray_:uns32 := 0;

					// Get the current parameter into parmArray.

					?_parmArray_ :=	@tokenize
									(
										_parms_[ _curparm_ ],
										0,
										{':'},
										{
											'"',
											'''',
											'[',
											']',
											'(',
											')',
											'{',
											'}'
										}
									);

					?_arg_ := @trim( _parmArray_[ 0 ], 0 );
					#if( char( _arg_ ) in stdio._idchars_ )

						?_id_ := stdio._GetID_( _arg_ );
						#if
						(
								@class( _id_ ) = hla.cConstant
							|	@class( _id_ ) = hla.cValue
						)

							?_id_ := _arg_;

						#endif

					#else

						?_id_ := _arg_;

					#endif

					?_fieldCnt_ := @elements( _parmArray_ );
					#if( _fieldCnt_ > 1 )

						?_width_ := @trim( _parmArray_[ 1 ], 0 );

					#else

						?_width_ := "-1";

					#endif
					#if( _fieldCnt_ > 2 )

						?_decpts_ := @trim( _parmArray_[ 2 ], 0 );

					#else

						?_decpts_ := "-1";

					#endif
					#if( _fieldCnt_ > 3 )

						#error
						(
							"<<" + _parms_[ _curparm_ ] + ">>" +
							" has too many width fields"
						)

					#endif
					
					?_pType_ := @pType(  @text( _id_ ));
					#if( _pType_ = hla.ptArray )

						?_pType_ := 
							@pType( @text( @typename( @text( _id_))));

					#endif

					#if( _pType_ = hla.ptBoolean )
					 
						file._put_( _fVar_, putbool, boolean )

					#elseif( _pType_ = hla.ptUns8 )
					 
						file._put_( _fVar_, putu8, uns8 )

					#elseif( _pType_ = hla.ptUns16 ) 
					
						file._put_( _fVar_, putu16, uns16 )

					#elseif( _pType_ = hla.ptUns32 ) 
					
						file._put_( _fVar_, putu32, uns32 )

					#elseif( _pType_ = hla.ptByte ) 
					
						file._put_( _fVar_, putb, byte )

					#elseif( _pType_ = hla.ptWord ) 
					
						file._put_( _fVar_, putw, word )

					#elseif( _pType_ = hla.ptDWord ) 
					
						file._put_( _fVar_, putd, dword )

					#elseif( _pType_ = hla.ptInt8 ) 
					
						file._put_( _fVar_, puti8, int8 )

					#elseif( _pType_ = hla.ptInt16 ) 
					
						file._put_( _fVar_, puti16, int16 )

					#elseif( _pType_ = hla.ptInt32 ) 
					
						file._put_( _fVar_, puti32, int32 )

					#elseif( _pType_ = hla.ptChar ) 
					
						file._put_( _fVar_, putc, char )

					#elseif( _pType_ = hla.ptCset ) 
					
						file._put_( _fVar_, putcset, cset )

					#elseif( _pType_ = hla.ptReal32 ) 
					
						file._put_( _fVar_, putr32, real32 )

					#elseif( _pType_ = hla.ptReal64 ) 
					
						file._put_( _fVar_, putr64, real64 )

					#elseif( _pType_ = hla.ptReal80 ) 
					
						file._put_( _fVar_, putr80, real80 )

					#elseif( _pType_ = hla.ptString )

						file._put_( _fVar_, puts, string )


					#elseif( @isclass( @text( _parms_[ _curparm_ ] )))

						#if
						( 
							@defined
							( 
								@text
								(
									 _parms_[ _curparm_ ] + 
									".toString" 
								)
							)
						)

							push( eax );
							push( esi );
							push( edi );
							@text
							( 
								_parms_[ _curparm_ ] + 
								".toString()"
							);
							_fVar_.puts( eax );
							strfree( eax );
							pop( edi );
							pop( esi );
							pop( eax );

						#else

							#error
							(
								"file.put: Class does not provide a "
								"toString or:
				procedure procedure"
							);

						#endif

					#else

						#error
						( 
							"file.put: Unknown data type (" +
							_parms_[ _curparm_ ] +
							":" +
							@typename( @text( _parms_[_curparm_] )) +
							")"
						);

					#endif
					?_curparm_ := _curparm_ + 1;

				#endwhile

				pop( edi );
				pop( esi );

			#endmacro



			#macro get( _parms_[] ): 
				_curparm_, _pType_, _arg_, _id_, _fVar_;

				?_curparm_:uns32 := 0;
				?_fVar_:text := @LastObject;
				
				// Save important registers that the "GET" macro uses.

				push( eax );
				push( esi );
				push( edi );

				// The following loop repeats once for each GET parameter
				// we process.

				#while( _curparm_ < @elements( _parms_ ))

					// If this parameter begins with an identifier,
					// there are some problems to deal with.
					// The symbol table functions (e.g., @ptype) don't
					// allow address expression components after the
					// symbol name.  Named constants, however, do allow
					// such entities.  The following code determines
					// (1) is this a symbol?  (2) if it is a symbol, is
					// it a constant?
					//
					//	For non-constant symbols, we need to strip any
					// trailing non-symbol characters from the string
					// (e.g., "[0]" ).

					?_arg_ := @trim( _parms_[ _curparm_ ], 0 );
					#if( char( _arg_ ) in stdio._idchars_ )

						// If this parameter begins with an id character,
						// then strip away any non-ID symbols from the
						// end of the string.  Then determine if we've
						// got a constant or some other class (e.g.,
						// variable or procedure).  If not a constant,
						// keep only the name.  If a constant, we need
						// to keep all trailing characters as well.

						?_id_ := stdio._GetID_( _arg_ );
						#if
						( 
								@class( _id_ ) = hla.cConstant 
							|	@class( _id_ ) = hla.cValue 
						)

							?_id_ := _arg_;

						#endif

					#else

						// If it's not an ID, we need to keep everything.

						?_id_ := _arg_;

					#endif



					// Determine the type of this parameter so we can
					// call the appropriate routine to input it.

					?_pType_ := @pType( @text( _id_ ));
					#if( _pType_ = hla.ptArray )

						?_pType_ := 
							@pType( @text( @typename( @text( _id_ ))));

					#endif

					// Based on the type, call the appropriate library
					// routine to print this value.

					#if( _pType_ = hla.ptBoolean )

						#error( "Boolean input is not supported" );

					#elseif( _pType_ = hla.ptUns8 ) 
						
						_fVar_.getu8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = hla.ptUns16 ) 
						
						_fVar_.getu16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptUns32 ) 
						
						_fVar_.getu32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptByte ) 
						
						_fVar_.geth8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = hla.ptWord ) 
						
						_fVar_.geth16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptDWord ) 
						
						_fVar_.geth32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptInt8 ) 
						
						_fVar_.geti8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = hla.ptInt16 ) 
						
						_fVar_.geti16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptInt32 ) 
						
						_fVar_.geti32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = hla.ptChar ) 
						
						_fVar_.getc();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = hla.ptCset ) 

						#error( "Cset input is not supported" );

					#elseif
					( 
							_pType_ = hla.ptReal32 
						|	_pType_ = hla.ptReal64 
						|	_pType_ = hla.ptReal80 
					) 
						
						_fVar_.getf();
						fstp( @text( _arg_ ));

					#elseif( _pType_ = hla.ptString ) 

						_fVar_.gets( @text( _arg_ ));

					#else

						#error
						( 
							"stdin.get: Unknown data type (" +
							_parms_[ _curparm_ ] +
							":" +
							@typename( @text( _id_ )) +
							")"
						);

					#endif
					?_curparm_ := _curparm_ + 1;

				#endwhile

				// Restore the registers pushed earlier for this 
				// call to the GET macro.

				pop( edi );
				pop( esi );
				pop( eax );

			#endmacro



		endclass;




	

#endif