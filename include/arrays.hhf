
#if( ! @defined( arrays_hhf ))
?arrays_hhf := true;

#includeOnce( "hla.hhf" )
#includeOnce( "excepts.hhf" )




namespace array; @fast;

val
	boundsChk:boolean := @global:true;


/*************************************************************************/

	// Macro that returns true if its parameter is a
	// dynamic array variable.

	#macro isItDynamic( _SuspectName_ );

		(

				(	  
						@class( _SuspectName_ ) = hla.cVar
					|	@class( _SuspectName_ ) = hla.cStatic
					|	@class( _SuspectName_ ) = hla.cParm
				)
			&	@defined( _SuspectName_.elementType )
			&	@defined( _SuspectName_.dataPtr )
			&	@defined( _SuspectName_.dopeVector )
		)
	#endmacro


	// Macro that returns true if its parameter is a variable

	#macro isItVar( _PossibleVarName_ );
		(
				@class( _PossibleVarName_ ) = hla.cVar
			|	@class( _PossibleVarName_ ) = hla.cStatic
			|	@class( _PossibleVarName_ ) = hla.cParm
		)
	#endmacro

	


/*************************************************************************/


	// Dynamic array declaration
	//
	//	e.g.,
	//
	//	static
	//
	//		aDynArray: dArray( int32, 3 );

					   
	#macro dArray( _theType_, _NumDimensions_ );

		#if( !@IsConst( _NumDimensions_ )) 

			#error( "Number of dimensions must be a constant" )

		#endif
		#if( @class( _theType_ ) <> hla.cType )

			#error( "First parameter must be a data type" )

			// Provide a fake type for the data declaration:

			uns32 

		#else

			record

				dataPtr:		dword;
				dopeVector:		uns32[ _NumDimensions_ ];

				// elementType is only used to determine
				// the size of an element in daAlloc.

				elementType:	_theType_;

			endrecord

		#endif

	#endmacro




/*************************************************************************/
//
// The following iterators return each element of the array passed as
// a parameter.

	proc

		__returnEachArrayElement1:
			iterator( var theArray:byte; Elements:uns32 );
			@global:_hla._ext( "array_ReturnEachArrayElement1" );

		__returnEachArrayElement2:
			iterator( var theArray:word; Elements:uns32 );
			@global:_hla._ext( "array_ReturnEachArrayElement2" );

		__returnEachArrayElement4:
			iterator( var theArray:dword; Elements:uns32 );
			@global:_hla._ext( "array_ReturnEachArrayElement4" );

		__returnEachArrayElement8:
			iterator ( var theArray:qword; Elements:uns32 );
			@global:_hla._ext( "array_ReturnEachArrayElement8" );

		__returnEachArrayElement16:
			iterator 
			( 
				var theArray	:lword; 
					Elements	:uns32 
			);
			@global:_hla._ext( "array_ReturnEachArrayElement16" );

		__returnEachArrayElementR32:
			iterator 
			( 
				var theArray:real32; 
					Elements:uns32 
			);
			@global:_hla._ext( "array_ReturnEachArrayElementR32" );

		__returnEachArrayElementR64:
			iterator 
			( 
				var theArray:real64; 
					Elements:uns32 
			);	
			@global:_hla._ext( "array_ReturnEachArrayElementR64" );

		__returnEachArrayElementR80:
			iterator 
			( 
				var theArray:real80; 
					Elements:uns32 
			);	
			@global:_hla._ext( "array_ReturnEachArrayElementR80" );



	// Here is the macro that provides procedure overloading for
	// each of the above procedures:

	#macro element( _theArray_ ):_dimIndex_;

		#if( array.isItDynamic( _theArray_ ))

			#if( @Size( _theArray_.elementType ) = 1 )

				array.__returnEachArrayElement1
				( 
					#{ push( _theArray_.dataPtr ); }#,
					#{
						push( eax );
						push( eax );
						mov( _theArray_.dopeVector[0], eax );

						?_dimIndex_ := 1;
						#while
						( 
							_dimIndex_ < @Elements( _theArray_.dopeVector )
						)

							intmul
							( 
								_theArray_.dopeVector[ _dimIndex_ * 4], 
								eax 
							);
							?_dimIndex_ := _dimIndex_ + 1;

						#endwhile
						mov( eax, [esp+4] );
						pop( eax );
					}#
				)

			#elseif( @Size( _theArray_.elementType ) = 2 )

				array.__returnEachArrayElement2
				( 
					#{ push( _theArray_.dataPtr ); }#,
					#{
						push( eax );
						push( eax );
						mov( _theArray_.dopeVector[0], eax );

						?_dimIndex_ := 1;
						#while
						( 
							_dimIndex_ < @Elements( _theArray_.dopeVector )
						)

							intmul
							( 
								_theArray_.dopeVector[ _dimIndex_ * 4], 
								eax 
							);
							?_dimIndex_ := _dimIndex_ + 1;

						#endwhile
						mov( eax, [esp+4] );
						pop( eax );
					}#
				)


			#elseif( @TypeName( _theArray_.elementType ) = "real32" )
			

				array.__returnEachArrayElementR32
				( 
					#{ push( _theArray_.dataPtr ); }#,
					#{
						push( eax );
						push( eax );
						mov( _theArray_.dopeVector[0], eax );

						?_dimIndex_ := 1;
						#while
						( 
							_dimIndex_ < @Elements( _theArray_.dopeVector )
						)

							intmul
							( 
								_theArray_.dopeVector[ _dimIndex_ * 4], 
								eax 
							);
							?_dimIndex_ := _dimIndex_ + 1;

						#endwhile
						mov( eax, [esp+4] );
						pop( eax );
					}#
				)

			#elseif( @Size( _theArray_.elementType ) = 4 )

				array.__returnEachArrayElement4
				( 
					#{ push( _theArray_.dataPtr ); }#,
					#{
						push( eax );
						push( eax );
						mov( _theArray_.dopeVector[0], eax );

						?_dimIndex_ := 1;
						#while
						( 
							_dimIndex_ < @Elements( _theArray_.dopeVector )
						)

							intmul
							( 
								_theArray_.dopeVector[ _dimIndex_ * 4], 
								eax 
							);
							?_dimIndex_ := _dimIndex_ + 1;

						#endwhile
						mov( eax, [esp+4] );
						pop( eax );
					}#
				)



			#elseif( @TypeName( _theArray_.elementType ) = "real64" )

				array.__returnEachArrayElementR64
				( 
					#{ push( _theArray_.dataPtr ); }#,
					#{
						push( eax );
						push( eax );
						mov( _theArray_.dopeVector[0], eax );

						?_dimIndex_ := 1;
						#while
						( 
							_dimIndex_ < @Elements( _theArray_.dopeVector )
						)

							intmul
							( 
								_theArray_.dopeVector[ _dimIndex_ * 4], 
								eax 
							);
							?_dimIndex_ := _dimIndex_ + 1;

						#endwhile
						mov( eax, [esp+4] );
						pop( eax );
					}#
				)

			#elseif( @Size( _theArray_.elementType ) = 8 )

				array.__returnEachArrayElement8
				( 
					#{ push( _theArray_.dataPtr ); }#,
					#{
						push( eax );
						push( eax );
						mov( _theArray_.dopeVector[0], eax );

						?_dimIndex_ := 1;
						#while
						( 
							_dimIndex_ < @Elements( _theArray_.dopeVector )
						)

							intmul
							( 
								_theArray_.dopeVector[ _dimIndex_ * 4], 
								eax 
							);
							?_dimIndex_ := _dimIndex_ + 1;

						#endwhile
						mov( eax, [esp+4] );
						pop( eax );
					}#
				)



			#elseif( @TypeName( _theArray_.elementType ) = "real80" )

				array.__returnEachArrayElementR80
				( 
					#{ push( _theArray_.dataPtr ); }#,
					#{
						push( eax );
						push( eax );
						mov( _theArray_.dopeVector[0], eax );

						?_dimIndex_ := 1;
						#while
						( 
							_dimIndex_ < @Elements( _theArray_.dopeVector )
						)

							intmul
							( 
								_theArray_.dopeVector[ _dimIndex_ * 4], 
								eax 
							);
							?_dimIndex_ := _dimIndex_ + 1;

						#endwhile
						mov( eax, [esp+4] );
						pop( eax );
					}#
				)

			#elseif( @Size( _theArray_.elementType ) = 16 )

				array.__returnEachArrayElement16
				( 
					#{ push( _theArray_.dataPtr ); }#,
					#{
						push( eax );
						push( eax );
						mov( _theArray_.dopeVector[0], eax );

						?_dimIndex_ := 1;
						#while
						( 
							_dimIndex_ < @Elements( _theArray_.dopeVector )
						)

							intmul
							( 
								_theArray_.dopeVector[ _dimIndex_ * 4], 
								eax 
							);
							?_dimIndex_ := _dimIndex_ + 1;

						#endwhile
						mov( eax, [esp+4] );
						pop( eax );
					}#
				)



			#else

				yyerror( "array.elements does not support this type" );

			#endif


		#else // It's a static array.

			#if( @ElementSize( _theArray_ ) = 1 )

				array.__returnEachArrayElement1
				( 
					_theArray_, 
					@Elements( _theArray_ )
				)

			#elseif( @ElementSize( _theArray_ ) = 2 )

				array.__returnEachArrayElement2
				( 
					_theArray_, 
					@Elements( _theArray_ )
				)


			#elseif( @TypeName( _theArray_ ) = "real32" )
			

				array.__returnEachArrayElementR32
				( 
					_theArray_, 
					@Elements( _theArray_ )
				)

			#elseif( @ElementSize( _theArray_ ) = 4 )

				array.__returnEachArrayElement4
				( 
					_theArray_, 
					@Elements( _theArray_ )
				)


			#elseif( @TypeName( _theArray_ ) = "real64" )
			

				array.__returnEachArrayElementR64
				( 
					_theArray_, 
					@Elements( _theArray_ )
				)

			#elseif( @ElementSize( _theArray_ ) = 8 )

				array.__returnEachArrayElement8
				( 
					_theArray_, 
					@Elements( _theArray_ )
				)



			#elseif( @TypeName( _theArray_ ) = "real80" )
			

				array.__returnEachArrayElementR80
				( 
					_theArray_, 
					@Elements( _theArray_ )
				)

			#elseif( @ElementSize( _theArray_ ) = 16 )

				array.__returnEachArrayElement16
				( 
					_theArray_, 
					@Elements( _theArray_ )
				)



			#else

				yyerror( "array.elements does not support this type" );

			#endif

		#endif

	#endmacro





/*************************************************************************/




	
	// daAlloc-
	//
	//	Allocates storage for a dynamic array at run-time given
	//	a list of array bounds.
	//
	//	syntax:
	//
	//		daAlloc( daArrayName, <<list of dimension bounds>> );
	//
	//	Notes:
	//
	//	daArrayName must have been declared using "dArray" type.
	//	
	//	The number of comma separated dimension bounds must
	//	match the number of dimensions specified in the dArray
	//	declaration.
	//
	//	Example:
	//
	//		daAlloc( MyDA, 3, i, j );
	//
	//	This example assumes the variable declaration: MyDA:dArray( uns32, 3 );
	//	The "i" and "j" IDs in this example can be run-time variables.


	#macro daAlloc( _theDA_, _dimensions_[] ):
			_i_, 
			_valid_, 
			_size_, 
			_curDim_, 
			_hadVar_;

		#if( !array.isItDynamic( _theDA_ ))

			#error( "Expected a dynamic array variable" )

		#elseif( @elements( _dimensions_ ) = 0 )
		
			#error( "Must specify at least one dimension" )
			
		#elseif( @elements( _dimensions_ ) <> @elements( _theDA_.dopeVector ))

			#error
			( 
				"Number of actual dimension bounds does not " nl
				"match number of declared dimensions" 
				" (actual = " + 
				string( @elements( _dimensions_ )) +
				" declared = " + 
				string( @elements( _theDA_.dopeVector )) + 
				")"
			)

		#else
		
			push( eax );
			?_i_ := 0;
			?_valid_ := true;
			?_hadVar_ := false;
			?_size_ := 1;
			#while( _i_ < @elements( _dimensions_ ))
			
				?_curDim_:text := _dimensions_[_i_];
				#if( @IsConst( _curDim_ ) )

					?_valid_ := _valid_	& hla.isNumber( _curDim_ );

				#elseif( array.isItVar( _curDim_ ))

					?_valid_ := _valid_	& hla.isNumber( _curDim_ );

				#else

					?_valid_ := false;

				#endif

				#if( _valid_ )

					#if( @IsConst( _curDim_ ) )

						?_size_ := _size_ * _curDim_;
						mov( _curDim_, _theDA_.dopeVector[ _i_*4 ] );


					#else

						push( edx );
						#if( !_hadVar_ )

							mov( _curDim_, eax );

						#else

							intmul( _curDim_, eax );

						#endif
						#if
						( 
								@size( _curDim_ ) = 1 
							|	@size( _curDim_ ) = 2 
						)

							movzx( _curDim_, edx );

						#elseif( @size( _curDim_ ) = 4 )

							mov( _curDim_, edx );

						#else

							#error( "Dimension object must be an integer" );

						#endif
						mov( edx, _theDA_.dopeVector[ _i_*4 ]);
						?_hadVar_ := true;
						pop( edx );


					#endif

				#endif
				?_i_ := _i_ + 1;
				?@tostring:_curDim_ := 0;	// Deallocate string.

			#endwhile
			#if( _valid_ )

				#if( _size_ != 1 )

					#if( _hadVar_ )

						intmul( _size_, eax );

					#else

						mov( _size_, eax );

					#endif

				#endif
				#if( @size( _theDA_.elementType ) = 1 )

					// do nothing

				#elseif( @size( _theDA_.elementType ) = 2 )

					shl( 1, eax );

				#elseif( @size( _theDA_.elementType ) = 4 )

					shl( 2, eax );

				#elseif( @size( _theDA_.elementType ) = 8 )

					shl( 3, eax );

				#elseif( @size( _theDA_.elementType ) = 16 )

					shl( 4, eax );

				#else

					intmul( @size( _theDA_.elementType ), eax );

				#endif

				malloc( eax );
				mov( eax, _theDA_.dataPtr );

			#else

				#error( "Invalid dynamic array dimension list" );

			#endif
			pop( eax );

		#endif

	#endmacro



/*************************************************************************/



	// daFree:
	//
	//	Frees a dynamic array allocated via daAlloc.

	#macro daFree( _theDA_ );

		#if( !array.isItDynamic( _theDA_ ))

			#error( "Expected a dynamic array variable" )

		#else

			if( _theDA_.dataPtr != 0 ) then

				free( _theDA_.dataPtr );
				mov( 0, _theDA_.dataPtr );

			else

				raise( ex.AttemptToDerefNULL );

			endif;

		#endif

	#endmacro


		



/*************************************************************************/



	// Index:	Compute the row-major index into an array
	//		 	given a list of indexes.
	//
	//			Handles both normal arrays and dynamically
	//			declared arrays.

	#macro index( _register_, _arrayVar_, _indicies_[] ):
			_numDims_,
			_i_,
			_elementSize_,
			_tempid_,
			_pType_;

		#if( !@IsReg32( _register_ ))

			#error( "index: First parameter must be a 32-bit register" );

		#elseif( array.isItDynamic( _arrayVar_ ))


			// We've probably got a dynamic array at this point.
			// (there is the slight chance the user declared a
			// record containing these fields, but this is highly
			// unlikely.


			#if
			( 
					@elements( _arrayVar_.dopeVector ) 
				<>	@elements( _indicies_ )
			)

				#error
				( 
					@tostring:_arrayVar_ + 
					" has " + 
					string( _numDims_ ) +
					" dimensions, you provided " +
					string( @elements( _indicies_ )) +
					" dimensions"
				);

			#else

				?_i_ := 1;
				mov( @text( _indicies_[0] ), _register_ );
				#if( array.boundsChk )

					if( _register_ < @dim( _arrayVar_ )[0] ) then

						raise( ex.ArrayBounds );

					endif;

				#endif


				#while( _i_ < @elements( _arrayVar_.dopeVector ))

					intmul( _arrayVar_.dopeVector[ _i_*4 ], _register_ );
					add( @text( _indicies_[_i_] ), _register_ );

					#if( array.boundsChk )

						#if( @isConst( @text( _indicies_[_i_] ) ))

							#if
							( 
								@text( _indicies_[_i_] ) < 
									@dim(_arrayVar_)[_i_]
							)

								#error( "Constant array index out of bounds" )
								#print( "index = ", @text( _indicies_[_i_] ))
								#print( "bound = ", @dim(_arrayVar_)[_i_] )

							#endif
							
						#else

							if
							( 
								@text( _indicies_[_i_] ) < @dim(_arrayVar_)[_i_]
							) then

								raise( ex.ArrayBounds );

							endif;

						#endif

					#endif
					?_i_:=_i_+1;

				#endwhile
				?_elementSize_ := 
					@Size( @text( @TypeName( _arrayVar_.elementType )));

				#if( _elementSize_ = 1 )

					// Do nothing

				#elseif( _elementSize_ = 2 )

					shl( 1, _register_ );

				#elseif( _elementSize_ = 4 )

					shl( 2, _register_ );

				#elseif( _elementSize_ = 8 )

					shl( 3, _register_ );

				#elseif( _elementSize_ = 16 )

					shl( 4, _register_ );

				#else
				
					intmul( _elementSize_, _register_ );

				#endif
				add( _arrayVar_.dataPtr, _register_ );


			#endif

		#else

			// Assume we've got a standard array.

			?_numDims_:uns32 := @arity( _arrayVar_ );
			#if( _numDims_ <> @elements( _indicies_ ))

				#error
				( 
					@tostring:_arrayVar_ + 
					" has " + 
					string( _numDims_ ) +
					" dimensions, you provided " +
					string( @elements( _indicies_ )) +
					" dimensions"
				);

			#else

				?_i_ := 1;
				mov( @text( _indicies_[0] ), _register_ );
				#if( array.boundsChk )

					if( _register_ >= @dim(_arrayVar_)[0] ) then

						raise( ex.ArrayBounds );

					endif;

				#endif

				#while( _i_ < @arity( _arrayVar_ ))

					#if( array.boundsChk )

						if( @text( _indicies_[_i_] ) >= @dim(_arrayVar_)[_i_] )
						then

							raise( ex.ArrayBounds );

						endif;

					#endif
					intmul( @dim(_arrayVar_)[_i_], _register_ );
					add( @text( _indicies_[_i_] ), _register_ );
					?_i_:=_i_+1;

				#endwhile

				// Locate the base type of this array.

				?_tempid_ := @basetype( _arrayVar_ );

				?_elementSize_ := @Size( @text( _tempid_ ));
				#if( _elementSize_ = 1 )

					lea( _register_, _arrayVar_[ _register_ ] );

				#elseif( _elementSize_ = 2 )

					lea( _register_, _arrayVar_[ _register_*2 ] );

				#elseif( _elementSize_ = 4 )

					lea( _register_, _arrayVar_[ _register_*4 ] );

				#elseif( _elementSize_ = 8 )

					lea( _register_, _arrayVar_[ _register_*8 ] );

				#elseif( _elementSize_ = 16 )

					shl( 4, _register_ );
					lea( _register_, _arrayVar_[ _register_ ] );

				#else
				
					intmul( _elementSize_, _register_ );
					lea( _register_, _arrayVar_[ _register_ ] );

				#endif

			#endif

		#endif
				
	#endmacro



/*************************************************************************/


	// Utility macros used by some of the following routines:


	#macro _getArity_( _GAarrayVar_ );

		#if( array.isItDynamic( _GAarrayVar_ ))

			// Okay, it's a dynamic array.
			// The arity is equal to the number of dopeVector elements.

			@elements( _GAarrayVar_.dopeVector )

		#else

			// It's not a dynamic array, just return the arity value.

			@arity( _GAarrayVar_ )

		#endif

	#endmacro


	// _copyArray_
	//
	//	This macro is used by _cpy_ to emit the correct MOVS instruction.

	#macro _copyArray_( _elementSize_ );

		#if( _elementSize_ = 16 )

			shl( 2, ecx );
			rep.movsd();

		#elseif( _elementSize_ = 8 )

			shl( 1, ecx );
			rep.movsd();

		#elseif( _elementSize_ = 4 )

			rep.movsd();

		#elseif( _elementSize_ = 2 )

			shr( 1, ecx );	// Compute # of dwords.
			pushfd();
			rep.movsd();
			popfd();
			if( @c )

				movsw();

			endif;

		#elseif( _elementSize_ = 1 )

			rep.movsb();

		#else

			#if( (_elementSize_ & %11) = 0 )

				intmul( _elementSize_ div 4, ecx );
				rep.movsd();

			#elseif( (_elementSize_ & %1) = 0 )

				intmul( _elementSize_ shr 1, ecx );
				rep.movsw();

			#else

				intmul( _elementSize_, ecx );
				rep.movsb();

			#endif


		#endif

	#endmacro


		


	// cpy-
	//
	//	This copies the data in one array to another:

	#macro cpy( _src_, _dest_ ):
		_aritySrc_,
		_arityDest_,
		_cpyIndex_,
		_cpyElements_,
		_srcType_,
		_destType_;



		#if( @defined( _src_.elementType ))

			?_srcType_ := @type( _src_.elementType );

		#else

			?_srcType_ := @type( _src_ );

		#endif
		#if( @defined( _dest_.elementType ))

			?_destType_ := @type( _dest_.elementType );

		#else

			?_destType_ := @type( _dest_ );

		#endif
		?_aritySrc_ := array._getArity_( @text( @string:_src_) );
		?_arityDest_ := array._getArity_( @text( @string:_dest_) );



		#if( _aritySrc_ <> _arityDest_ )

			#error( "The shape and sizes of the two arrays must be the same" );

		#elseif( _srcType_ <> _destType_ )

			#error( "The base types of the two arrays must be the same" );

		#else

			// Verify that the two arrays have the same dimensions:

			#if( array.isItDynamic( _src_ ) & array.isItDynamic( _dest_ ) )

				// Both arrays are dynamic, compare their
				// bounds at run-time.
				
				push( ecx );
				push( esi );
				push( edi );
				
				?_cpyIndex_ := 0;
				mov( 1, ecx );
				if
				(#{
				
					#while( _cpyIndex_ < _aritySrc_ )
					
						mov( _src_.dopeVector[ _cpyIndex_*4 ], edi );
						intmul( edi, ecx );
						cmp( edi, _dest_.dopeVector[ _cpyIndex_*4 ] );
						#if( _cpyIndex_ != _aritySrc_ - 1 )

							jne true;

						#else

							je false;

						#endif
						?_cpyIndex_ := _cpyIndex_ + 1;

					#endwhile
					
				}#) then

					raise( ex.ArrayShapeViolation );

				endif;


				// Emit an appropriate memory move instruction:

				cld();
				mov( _src_.dataPtr, esi );
				mov( _dest_.dataPtr, edi );
				array._copyArray_( @size( _src_.elementType ) )

				pop( edi );
				pop( esi );
				pop( ecx );
				
			#elseif
			( 
					array.isItDynamic( _src_ ) 
				&	!array.isItDynamic( _dest_ )
			)

				// The src array is a dynamic array, the
				// dest array is a static array.  Compare
				// their bounds at run-time

				push( ecx );
				push( esi );
				push( edi );
				
				?_cpyIndex_ := 0;
				?_cpyElements_ := 1;
				if
				(#{
				
					#while( _cpyIndex_ < _aritySrc_ )
					
						?_cpyElements_ := 
							_cpyElements_ * @dim( _dest_ )[ _cpyIndex_ ];

						cmp
						( 
							_src_.dopeVector[ _cpyIndex_*4 ], 
							@dim( _dest_ )[ _cpyIndex_ ] 
						);
						#if( _cpyIndex_ != _aritySrc_ - 1 )

							jne true;

						#else

							je false;

						#endif
						?_cpyIndex_ := _cpyIndex_ + 1;

					#endwhile
				}#) then

					raise( ex.ArrayShapeViolation );

				endif;


				// Emit an appropriate memory move instruction:

				cld();
				mov( _src_.dataPtr, esi );
				lea( edi, _dest_ );
				mov( _cpyElements_, ecx );
				array._copyArray_( @size( _src_.elementType ) )



				pop( edi );
				pop( esi );
				pop( ecx );
				


			#elseif
			( 
					!array.isItDynamic( _src_ ) 
				&	array.isItDynamic( _dest_ )
			)

			 	// The src array is a static array, the
				// dest array is a dynamic array.  Compare
				// their bounds at run-time.

				push( ecx );
				push( esi );
				push( edi );
				
				?_cpyIndex_ := 0;
				?_cpyElements_ := 1;
				if
				(#{
				
					#while( _cpyIndex_ < _aritySrc_ )
					
						?_cpyElements_ := 
							_cpyElements_ * @dim( _src_ )[ _cpyIndex_ ];

						cmp
						( 
							_dest_.dopeVector[ _cpyIndex_*4 ], 
							@dim( _src_ )[ _cpyIndex_ ] 
						);
						#if( _cpyIndex_ != _aritySrc_ - 1 )

							jne true;

						#else

							je false;

						#endif
						?_cpyIndex_ := _cpyIndex_ + 1;

					#endwhile
				}# )then

					raise( ex.ArrayShapeViolation );

				endif;


				// Emit an appropriate memory move instruction:

				cld();
				mov( _dest_.dataPtr, edi );
				lea( esi, _src_ );
				mov( _cpyElements_, ecx );
				array._copyArray_( @size( _dest_.elementType ) )



				pop( edi );
				pop( esi );
				pop( ecx );


			#else

				// Both arrays are static arrays.  Compare
				// their bounds at compile-time.

				push( ecx );
				push( esi );
				push( edi );
				
				?_cpyIndex_ := 0;
				?_cpyElements_ := 1;
				#while( _cpyIndex_ < _aritySrc_ )
				
					?_cpyElements_ := 
						_cpyElements_ * @dim( _src_ )[ _cpyIndex_ ];

					#if
					( 
							@dim( _src_ )[_cpyIndex_] 
						<>  @dim( _dest_ )[_cpyIndex_]
					)

						#error( "Array shapes must be the same" )

					#endif

					?_cpyIndex_ := _cpyIndex_ + 1;

				#endwhile


				// Emit an appropriate memory move instruction:

				cld();
				lea( edi, _dest_ );
				lea( esi, _src_ );
				mov( _cpyElements_, ecx );
				array._copyArray_( @size( @text( @typename( _src_ ))) )

				pop( edi );
				pop( esi );
				pop( ecx );

			#endif


		#endif
		
	#endmacro






/*************************************************************************/


	// reduce-
	//
	//	This macro does a row reduction.  That is, it eliminates
	//	one dimension of the array using a user-defined sequence
	//	of instructions.
	//
	//	Syntax:
	//
	//		array.reduce( srcArray, destArray )
	//
	//				<<instrs to perform before reduction>>
	//			
	//			array.beforeRow
	//
	//				<<instrs to execute before each row is reduced>>
	//
	//			array.reduction
	//
	//				<<instrs to perform on each element of the
	//					row being reduce.  Note: ESI contains the
	//					index into the source array, EAX & EDX are (the
	//					only registers) free for use.>>
	//
	//			array.afterRow
	//
	//				<<instrs to execute after the row is reduced.
	//					Note: EDI contains an index into the
	//					destination array.  EAX & EDX are (the only
	//					registers) free for use.>>
	//
	//		array.endreduce;


	#macro reduce
	( 
		_theSrc_, 
		_theDest_ 
	):
			_dimIndex_,
			_dimSrc_,
			_dimDest_,
			_arityDest_,
			_aritySrc_,
			_goodShape_,
			_DidBeforeRow_,
			_DidReduce_,
			_DidAfterRow_,
			_ElementSize_,
			_DestElementSize_,
			_NumIterations_,
			_BadArity_,
			_GoodArity_;

		?_DidBeforeRow_ := false;
		?_DidAfterRow_ := false;
		?_DidReduce_ := false;

		#if( array.isItDynamic( _theSrc_ ))

			?_aritySrc_ := @elements( _theSrc_.dopeVector );
			?_ElementSize_ := 	@size
								( 
									@text( @typename( _theSrc_.elementType ))
								);

		#else

			?_aritySrc_ := @arity( _theSrc_ );
			?_ElementSize_ := @size( _theSrc_ ) div @elements( _theSrc_ );

		#endif

		#if( array.isItDynamic( _theDest_ ))

			?_arityDest_ := @elements( _theDest_.dopeVector );
			?_DestElementSize_ := 	
				@size
				( 
					@text( @typename( _theDest_.elementType ))
				);

		#else

			?_arityDest_ := @arity( _theDest_ );
			?_DestElementSize_ := 
				@size( _theDest_ ) div @elements( _theDest_ );

		#endif



		push( ecx );
		push( esi );
		push( edi );

		#if( _ElementSize_ <> _DestElementSize_ )

			#error( "Array elements must be the same size" )
			?_goodShape_ := false;

		#elseif( _aritySrc_ <> _arityDest_ + 1 )

			#error
			(
				"Destination array must have one "
				"fewer dimensions than the source array" 
			)
			?_goodShape_ := false;


		#else

			// Verify the shapes of the two arrays.
			// The dest must have one less dimension than the
			// source (that was checked above) and except for
			// the dimension in src specified by _theDim_, each
			// src dimension must match the corresponding
			// dest dimension.
			//
			// Note: If either, or both, of the arrays are dynamic,
			// the check must be done at run-time.  If both arrays
			// are static, then the check can be done at compile time.

			#if
			( 
					!array.isItDynamic( _theSrc_ ) 
				&	!array.isItDynamic( _theDest_ )
			)

				// Both arrays are static, do the check at compile-time.

				?_dimSrc_ := @dim( _theSrc_ );
				?_dimDest_ := @dim( _theDest_ );
				?_dimIndex_ := 0;
				?_NumIterations_ := 1;
				?_goodShape_ := true;
				#while( _dimIndex_ < _arityDest_ )

					#if( _dimSrc_[ _dimIndex_ ] <> _dimDest_[ _dimIndex_ ] )

						#error( "reduce: illegal destination shape" )
						?_goodShape_ := false;

					#endif
					?_NumIterations_ := 
						_NumIterations_ * _dimSrc_[ _dimIndex_ ];

					?_dimIndex_ := _dimIndex_ + 1;

				#endwhile

			#elseif
			(
					array.isItDynamic( _theSrc_ ) 
				&	!array.isItDynamic( _theDest_ )
			)

				// The source array is dynamic, must check the
				// dimensions at run-time.

				?_dimDest_ := @dim( _theDest_ );
				?_goodShape_ := true;
				?_NumIterations_ := 1;
				?_dimIndex_ := 0;
				#if( _arityDest_ <> 0 )

					#while( _dimIndex_ < _arityDest_ - 1 )

						cmp
						( 
							_theSrc_.dopeVector[ _dimIndex_*4 ], 
							_dimDest_[ _dimIndex_ ] 
						);
						jne _BadArity_;

						?_NumIterations_ := 
							_NumIterations_ * _dimDest_[ _dimIndex_ ];

						?_dimIndex_ := _dimIndex_ + 1;

					#endwhile
					cmp
					(
						_theSrc_.dopeVector[ (_arityDest_ - 1)*4 ],
						_dimDest_[ _arityDest_ - 1 ]
					);
					je _GoodArity_;
					_BadArity_:
						raise( ex.ArrayShapeViolation );
					_GoodArity_:
					?_NumIterations_ := 
						_NumIterations_ * _dimDest_[ _arityDest_ - 1 ];


				#endif

			#elseif
			(
					!array.isItDynamic( _theSrc_ ) 
				&	array.isItDynamic( _theDest_ )
			)

				// The destination array is dynamic, must check the
				// dimensions at run-time.


				?_dimSrc_ := @dim( _theSrc_ );
				?_goodShape_ := true;
				?_NumIterations_ := 1;
				?_dimIndex_ := 0;
				#if( _aritySrc_ - 1 <> 0 )

					#while( _dimIndex_ < _aritySrc_ - 2 )

						cmp
						( 
							_theDest_.dopeVector[ _dimIndex_*4 ], 
							_dimSrc_[ _dimIndex_ ] 
						);
						jne _BadArity_;
						?_dimIndex_ := _dimIndex_ + 1;
						?_NumIterations_ := 
							_NumIterations_ * _dimSrc_[ _dimIndex_ ];

					#endwhile
					cmp
					(
						_theDest_.dopeVector[ (_aritySrc_ - 2)*4 ],
						_dimSrc_[ _aritySrc_ - 2 ]
					);
					je _GoodArity_;
					_BadArity_:
						raise( ex.ArrayShapeViolation );
					_GoodArity_:
					?_NumIterations_ := 
						_NumIterations_ * _dimSrc_[ _aritySrc_ - 2 ];

				#else

					#error( "Source array must have at least one dimension" )
					?_goodShape_ := false;

				#endif

			#else

				// Both arrays are dynamic, so we must check the
				// dimensions at run-time.

				push( eax );
				mov( 1, eax );
				mov( @elements( _theDest_.dopeVector ), ecx );
				while( ecx > 0 ) do

					mov( _theSrc_.dopeVector[ ecx*4-4 ], esi );
					cmp( esi, _theDest_.dopeVector[ ecx*4-4 ] );
					je _GoodArity_;

						raise( ex.ArrayShapeViolation );

					_GoodArity_:
					intmul( esi, eax );
					dec( ecx );

				endwhile;
				?_goodShape_ := true;
				intmul( _ElementSize_, eax );
				xchg( eax, [esp] );

			#endif

		#endif

	#keyword beforeRow;


		#if( _goodShape_ & !_DidBeforeRow_ )

			#if
			( 
					!array.isItDynamic( _theSrc_ ) 
				|	!array.isItDynamic( _theDest_ )
			)

				// Construct the for loop that will generate
				// the reduction.  Note that at least one
				// of the arrays is a static array, so we
				// can use the _NumIterations_ constant.

				xor( esi, esi );
				for
				( 
					xor( edi, edi );
					edi < _NumIterations_ * _ElementSize_;
					add( _ElementSize_, edi) 
				) do

			#else

				// As above, but both arrays are dynamic.
				// The number of loop iterations can be
				// found on the top of the stack.

				xor( esi, esi );
				for
				( 
					xor( edi, edi );
					edi < [esp];
					add( _ElementSize_, edi) 
				) do

			#endif

		#endif
		?_DidBeforeRow_ := true;

	#keyword reduction:_srcDims_;

		#if( !_DidBeforeRow_ )

			#error
			( 
				"'beforeRow' section must precede the 'reduction' section" 
			)
			?_DidEachRow_ := true; // So we don't get two messages.

		#endif

		#if( _goodShape_ & !_DidReduce_ )

			// Emit the for loop that indexes through the
			// array elements we are reducing:

			#if( !array.isItDynamic( _theSrc_ ))

				?_srcDims_ := @dim( _theSrc_ );
				for
				(
					xor( ecx, ecx );
					ecx < _srcDims_[ @elements( _srcDims_ ) - 1 ];
					inc( ecx )
				) do

			#else

				push
				( 
					_theSrc_.dopeVector
					[ 
						( @elements( _theSrc_.dopeVector ) - 1 ) * 4
					] 
				);
				for
				(
					xor( ecx, ecx );
					ecx < [esp];
					inc( ecx )
				) do

			#endif

			
		#endif
		?_DidReduce_ := true;

	

	#keyword afterRow;

		#if( !_DidBeforeRow_ )

			#error( "Missing 'beforeRow' and 'reduction' sections" )
			?_DidBeforeRow_ := true;

		#elseif( !_DidReduce_ )

			#error( "Missing 'reduction' section" )
			?_DidReduce_ := true;

		#else

			// Bump up the index into the array by the size of
			// a single array element:

			add( _ElementSize_, esi );

			// Endfor that matches the innermost loop:
			
			endfor;

			// If the source array is a dynamic array, remove
			// the ending loop index from the stack:

			#if( array.isItDynamic( _theSrc_ ))

				add( 4, esp );

			#endif


		#endif
		?_DidAfterRow_ := true;


	#terminator endreduce;

		#if( _goodShape_ )

			#if( !_DidBeforeRow_ )

				#error
				( 
					"Missing 'beforeRow', 'reduction', "
					"and 'afterRow' sections" 
				)

			#elseif( !_DidReduce_ )

				#error( "Missing 'reduction' and 'afterRow' sections" )

			#elseif( !_DidAfterRow_ )

				#error( "Missing 'afterRow' section" )

			#else

				// Emit the endfor for the enclosing loop.

				endfor;

				// If both arrays were dynamic, we need to remove
				// the ending loop index from the stack:

				#if
				(
						array.isItDynamic( _theSrc_ )
					&	array.isItDynamic( _theDest_ )
				)

					add( 4, esp );

				#endif

			#endif

		#endif

		pop( edi );
		pop( esi );
		pop( ecx );

	#endmacro

/*************************************************************************/


	#macro mulbyConst( src1, dest );

		#if( src1 = 1 )

			mov( src2, dest );

		#elseif( src1 = 2 )

			shl( 1, dest );

		#elseif( src1 = 4 )

			shl( 2, dest );

		#elseif( src1 = 8 )

			shl( 3, dest );

		#elseif( src1 = 16 )

			shl( 4, dest );

		#else

			intmul( src1, dest );

		#endif

	#endmacro





	#macro transpose( _srcArray_, _destArray_, _xposDim_[] ):
		_xpos_,
		_offset_,
		_srcd_,
		_dstd_,
		_dSize_,
		_sSize_;

		// See if the third parameter is present.
		// If so, verify that it is an integer constant
		// falling in the range 0..arity( _srcArray_ ) - 1

		#if( @Elements( _xposDim_ ) = 0 )

			// If third parameter is not present, default the
			// transpose dimension to one.

			?_xpos_ := 1;

		#elseif( @Elements( _xposDim_ ) = 1 )

			// If we've got a third parameter, verify that
			// it is a constant.

			#if( !@IsConst( @text( _xposDim_[0] )))

				#error
				(
					"array.transpose:" nl
					"Expected a constant for the transpose dimension"
				);

			#else

				// If the third parameter is a constant, verify that
				// it is a numeric constant.

				?_xpos_ := @text( _xposDim_[0] );
				#if( !hla.isNumber( _xpos_ ))

					#error
					(
						"array.transpose:" nl
						"Transpose dimension parameter must be an integer"
					)
					?_xpos_ := 1;

				#endif

			#endif

		#else

			#error
			(
				"array.transpose:" nl
				"Too many parameters"
			);
			?_xpos_ := 1;

		#endif

		// It is illegal to transpose dimension zero since that's
		// the other dimension we're working with.  Also, negative
		// dimensions don't make sense, so check that here as well.

		#if( _xpos_ <= 0 )

			#error
			(
				"array.transpose:" nl
				"Transpose dimension must be one or greater"
			);
			?_xpos_ := 1;

		#endif






		// Handle the case where both arrays are dynamic:


		#if
		( 
				array.isItDynamic( _srcArray_ ) 
			&	array.isItDynamic( _destArray_ )
		)


			// Check the element sizes statically to ensure
			// they are reasonable and are the same size.

			?_sSize_ := @Size( _srcArray_.elementType );
			?_dSize_ := @Size( _destArray_.elementType );

			#if
			(
					_sSize_ <> 1
				&	_sSize_ <> 2
				&	_sSize_ <> 4
				&	_sSize_ <> 8
				&	_sSize_ <> _dSize_
			)

				#error
				(
					"array.transpose: " nl
					"Can only handle arrays with 1, 2, 4, or 8 byte elements"
				);



			#else

				// We must check for proper array shapes at run-time
				// since we don't know the dest array dimensions
				// until then.

				push( eax );
				if
				(#{
					?_i_ := 1;
					#while( _i_ < @Elements( _srcArray_.dopeVector ))

						#if( _i_ <> _xpos_ )

							mov( _srcArray_.dopeVector[_i_*4], eax );
							cmp
							(
								eax,
								_destArray_.dopeVector[_i_*4]
							);
							jne true;

						#endif
						?_i_ := _i_ + 1;

					#endwhile
					
					mov( _srcArray_.dopeVector[0], eax ); 
					cmp( eax, _destArray_.dopeVector[0] );
					jne true;
					mov( _srcArray_.dopeVector[_xpos_*4], eax );
					cmp( eax, _destArray_.dopeVector[_xpos_*4] );
					je false;

				}#) then
					raise( ex.ArrayShapeViolation );

				endif;

				


				// Optimize the most common case (transposing
				// a two-dim array or the last two dimensions
				// of an array).

				#if( _xpos_ = 1 )

					push( ebx );
					push( ecx );
					push( edx );
					push( esi );
					push( edi );

					// Note: assume that the src and dest array
					// sizes are the same.
					//
					// Begin by computing the size of the
					// matrix composed of the lower two dimensions.
					// The loop below uses this value.

					mov( _srcArray_.dopeVector[0], ecx );
					intmul( _srcArray_.dopeVector[4], ecx );
					#if( _sSize_ = 2 )

						shl( 1, ecx );

					#elseif( _sSize_ = 4 )

						shl( 2, ecx );

					#elseif( _sSize_ = 8 )

						shl( 3, ecx );

					#endif
					push( ecx );	// Save matrix size at [esp+4].

					// Compute the size of the entire matrix and
					// the compute the address of the last element
					// of the source array so we can use this as
					// a loop termination value.

					?_i_ := 2;
					#while( _i_ < @Elements( _srcArray_.dopeVector ) )

						intmul( _srcArray_.dopeVector[_i_*4], ecx );
						?_i_ := _i_ + 1;

					#endwhile

					mov( _srcArray_.dataPtr, ebx );
					add( ebx, ecx );
					push( ecx );	// Save ptr to last src element at [esp].

					// Compute the starting address of the first element
					// of the destination array, noting that will will
					// adjust the block size on the first iteration of
					// the loop, below.

					mov( _destArray_.dataPtr, ecx );
					sub( [esp+4], ecx );

					while( ebx < [esp] ) do

						add( [esp+4], ecx );
						for
						( 
							mov(0, esi ); 
							esi < _srcArray_.dopeVector[0]; 
							inc( esi )
						) do

							for
							( 
								mov( 0, edi ); 
								edi < _srcArray_.dopeVector[4]; 
								inc( edi )
							) do

								#if( _sSize_ = 1 )

									mov( edi, edx );
									intmul( _destArray_.dopeVector[0], edx );
									add( esi, edx );
									mov( [ebx], al );
									mov( al, [ecx+edx] );
									inc( ebx );

								#elseif( _sSize_ = 2 )

									mov( edi, edx );
									intmul( _destArray_.dopeVector[0], edx );
									add( esi, edx );
									mov( [ebx], ax );
									mov( ax, [ecx+edx*2] );
									add( 2, ebx );

								#elseif( _sSize_ = 4 )

									mov( edi, edx );
									intmul( _destArray_.dopeVector[0], edx );
									add( esi, edx );
									mov( [ebx], eax );
									mov( eax, [ecx+edx*4] );
									add( 4, ebx );

								#else

									mov( edi, edx );
									intmul( _destArray_.dopeVector[0], edx );
									add( esi, edx );
									mov( [ebx], eax );
									mov( eax, [ecx+edx*8] );
									mov( [ebx+4], eax );
									mov( eax, [ecx+edx*8+4] );
									add( 8, ebx );

								#endif

							endfor;

						endfor;

					endwhile;
					add( 8, esp );
					pop( edi );
					pop( esi );
					pop( edx );
					pop( ecx );
					pop( ebx );
					pop( eax );



				
				// Okay, handle the case where we are not transposing
				// the last two dimensions of the array.  This one is
				// ugly and less efficient (hence the special case
				// above).

				#else


					push( ebx );
					push( esi );
					push( edi );


					// Make room for a set of loop control variables
					// on the stack:

					sub( @arity( _srcArray_ ) * 4, esp );

					// Initialize array base pointers.

					mov( _destArray_.dataPtr, ebx );
					mov( _srcArray_.dataPtr, esi );

					// Emit the for loops that will do the
					// transposition.


					?_i_ := @Elements( _srcArray_.dopeVector );

					#while( _i_ > 0 )

						?_offset_ := ( _i_ - 1 ) * 4;
						mov(0, (type dword [esp+_offset_]));
						while({

							mov( (type dword [esp+_offset_]), eax );
							cmp( eax, _srcArray_.dopeVector[ _i_*4 - 4 ] );
							jae false;
						}) do
						?_i_ := _i_ - 1;

					#endwhile

					// Compute index into the destination array.
					// Note: to properly transpose, we need to
					// swap the zero index with the _xpos_ index.
					//
					// Begin by checking to see if the highest dimension
					// is _xpos_.  If so, use loop counter zero as the
					// index value.  If not, use loop counter n (n=arity-1)
					// as the index value.

					?_i_ := @Elements( _destArray_.dopeVector ) - 1;
					#if( _i_ = _xpos_ )

						mov( (type dword [esp] ), edi );
	
					#else

						mov
						( 
							(type dword [esp + _i_*4] ), 
							edi
						);

					#endif

					// Okay, for all dimensions except _xpos_ and zero,
					// compute the row-major offset into the array.
					// Swap indicies zero and _xpos_.  Note that _xpos_
					// may have been handled above.

					?_i_ := _i_ - 1;
					#while( _i_ > 0 )

						intmul( _destArray_.dopeVector[_i_*4], edi );
						#if( _i_ = _xpos_ )

							add( [esp], edi );

						#else

							add( [esp+_i_*4], edi );

						#endif
						?_i_ := _i_ - 1;

					#endwhile
					intmul( _destArray_.dopeVector[_xpos_*4], edi );
					add( [esp + _xpos_*4], edi );

					// Okay, EDI is the index into the destination array.
					// ESI contains the pointer at the current source
					// element.  Copy the data from the source array to
					// the destination array.

					#if( _sSize_ = 1 )

						mov( [esi], al );
						mov( al, [ebx+edi] );
						inc( esi );


					#elseif( _sSize_ = 2 )

						mov( [esi], ax );
						mov( ax, [ebx+edi*2] );
						add( 2, esi );


					#elseif( _sSize_ = 4 )

						mov( [esi], eax );
						mov( eax, [ebx+edi*4] );
						add( 4, esi );

					#else

						mov( [esi], eax );
						mov( [esi+4], edx );
						mov( eax, [ebx+edi*8] );
						mov( edx, [ebx+edi*8+4] );
						add( 8, esi );

					#endif

					?_i_ := 0;
					#while( _i_ < @Elements( _destArray_.dopeVector ))

							inc( (type dword [esp + _i_ * 4 ]));

						endwhile;
						?_i_ := _i_ + 1;

					#endwhile

					// Remove loop control variables from the stack.
					
					add( @Elements( _srcArray_.dopeVector ) * 4, esp );

					// Remove registers from the stack:

					pop( edi );
					pop( esi );
					pop( ebx );
					pop( eax );

				#endif

				

			#endif

		

		
		
		
		
		
		
		












		// Handle the case where the source array is static
		// and the destination array is dynamic.

		#elseif
		( 
				!array.isItDynamic( _srcArray_ ) 
			&	array.isItDynamic( _destArray_ )
		)





			?_srcd_ := @dim( _srcArray_ );
			?_sSize_ := @ElementSize( _srcArray_ );
			?_dSize_ := @Size( _destArray_.elementType );

			#if
			(
					_sSize_ <> 1
				&	_sSize_ <> 2
				&	_sSize_ <> 4
				&	_sSize_ <> 8
				&	_sSize_ <> _dSize_
			)

				#error
				(
					"array.transpose: " nl
					"Can only handle arrays with 1, 2, 4, or 8 byte elements"
				);

			#elseif
			( 
					@elements( _destArray_.dopeVector ) <= _xpos_
					 
				|	@arity( _srcArray_ ) <= _xpos_

				|	@elements( _destArray_.dopeVector ) <> 
											@arity( _srcArray_ ) 
			)

				#error
				(
					"array.transpose:" nl
					"Arrays must have at least "
					+ string( _xpos_ ) + " dimensions" nl
					"and they must have the same number of dimensions"
				);



			#else

				// We must check for proper array shapes at run-time
				// since we don't know the dest array dimensions
				// until then.

				if
				(#{
					?_i_ := 1;
					#while( _i_ < @arity( _srcArray_ ))

						#if( _i_ <> _xpos_ )

							cmp
							(
								_destArray_.dopeVector[ _i_ * 4 ],
								_srcd_[_i_]
							);
							jne true;

						#endif
						?_i_ := _i_ + 1;

					#endwhile
					 
					cmp
					(
						_destArray_.dopeVector[0], _srcd_[_xpos_]
					);
					jne true;
					cmp
					(
						_destArray_.dopeVector[_xpos_*4], _srcd_[0]
					);
					je false;

				}#) then

					raise( ex.ArrayShapeViolation );

				endif;

				


				// Optimize the most common case (transposing
				// a two-dim array or the last two dimensions
				// of an array).

				#if( _xpos_ = 1 )

					push( eax );
					push( ebx );
					push( ecx );
					push( edx );
					push( esi );
					push( edi );

					// Note: assume that the src and dest array
					// sizes are the same:

					lea( ebx, _srcArray_ );

					lea( ecx, [ebx + @size( _srcArray_ )] );
					push( ecx );

					mov( _destArray_.dataPtr, ecx );
					sub( _srcd_[0] * _srcd_[1] * _sSize_, ecx );

					while( ebx < [esp] ) do

						add( _srcd_[0] * _srcd_[1] * _sSize_, ecx );
						for( mov(0, esi ); esi < _srcd_[0]; inc( esi )) do

							for
							( 
								mov( 0, edi ); 
								edi < _srcd_[_xpos_]; 
								inc( edi )
							) do

								#if( _sSize_ = 1 )

									intmul( _srcd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], al );
									mov( al, [ecx+edx] );
									inc( ebx );

								#elseif( _sSize_ = 2 )

									intmul( _srcd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], ax );
									mov( ax, [ecx+edx*2] );
									add( 2, ebx );

								#elseif( _sSize_ = 4 )

									intmul( _srcd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], eax );
									mov( eax, [ecx+edx*4] );
									add( 4, ebx );

								#else

									intmul( _srcd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], eax );
									mov( eax, [ecx+edx*8] );
									mov( [ebx+4], eax );
									mov( eax, [ecx+edx*8+4] );
									add( 8, ebx );

								#endif

							endfor;

						endfor;

					endwhile;
					add( 4, esp );
					pop( edi );
					pop( esi );
					pop( edx );
					pop( ecx );
					pop( ebx );
					pop( eax );



				
				// Okay, handle the case where we are not transposing
				// the last two dimensions of the array.  This one is
				// ugly and less efficient (hence the special case
				// above).

				#else


					push( eax );
					push( ebx );
					push( esi );
					push( edi );


					// Make room for a set of loop control variables
					// on the stack:

					sub( @arity( _srcArray_ ) * 4, esp );

					// Initialize array base pointers.

					mov( _destArray_.dataPtr, ebx );
					lea( esi, _srcArray_ );

					// Emit the for loops that will do the
					// transposition.

					?_i_ := @arity( _srcArray_ );
					#while( _i_ > 0 )

						?_offset_ := ( _i_ - 1 ) * 4;
						for
						( 
							mov(0, (type dword [esp+_offset_]));
							(type dword [esp+_offset_]) < _srcd_[_i_ - 1];
							inc( (type dword [esp+_offset_]))
						) do
						?_i_ := _i_ - 1;

					#endwhile

					// Compute index into the source array.
					// Note: to properly transpose, we need to
					// swap the zero index with the _xpos_ index.
					//
					// Begin by checking to see if the highest dimension
					// is _xpos_.  If so, use loop counter zero as the
					// index value.  If not, use loop counter n (n=arity-1)
					// as the index value.

					?_i_ := @arity( _srcArray_ ) - 1;
					#if( _i_ = _xpos_ )

						mov( (type dword [esp] ), edi );
	
					#else

						mov
						( 
							(type dword [esp + _i_*4] ), 
							edi
						);

					#endif

					// Okay, for all dimensions except _xpos_ and zero,
					// compute the row-major offset into the array.
					// Swap indicies zero and _xpos_.  Note that _xpos_
					// may have been handled above.

					?_i_ := _i_ - 1;
					#while( _i_ > 0 )

						array.mulbyConst
						( 
							@dim( _srcArray_ )[_i_], 
							edi 
						);
						#if( _i_ = _xpos_ )

							add( [esp], edi );

						#else

							add( [esp+_i_*4], edi );

						#endif
						?_i_ := _i_ - 1;

					#endwhile
					array.mulbyConst( _srcd_[_xpos_], edi );
					add( [esp + _xpos_*4], edi );

					// Okay, EDI is the index into the destination array.
					// ESI contains the pointer at the current source
					// element.  Copy the data from the source array to
					// the destination array.

					#if( _sSize_ = 1 )

						mov( [esi], al );
						mov( al, [ebx+edi] );
						inc( esi );


					#elseif( _sSize_ = 2 )

						mov( [esi], ax );
						mov( ax, [ebx+edi*2] );
						add( 2, esi );


					#elseif( _sSize_ = 4 )

						mov( [esi], eax );
						mov( eax, [ebx+edi*4] );
						add( 4, esi );

					#else

						mov( [esi], eax );
						mov( [esi+4], edx );
						mov( eax, [ebx+edi*8] );
						mov( edx, [ebx+edi*8+4] );
						add( 8, esi );

					#endif
					?_i_ := 0;
					#while( _i_ < @arity( _srcArray_ ))

						endfor;
						?_i_ := _i_ + 1;

					#endwhile

					// Remove loop control variables from the stack.
					
					add( @arity( _srcArray_ ) * 4, esp );

					// Remove registers from the stack:

					pop( edi );
					pop( esi );
					pop( ebx );
					pop( eax );

				#endif

				

			#endif

		

		
		
		
		
		
		
		





		// Handle the case where the source array is dynamic and
		// the destination array is static.

		#elseif
		( 
				array.isItDynamic( _srcArray_ ) 
			&	!array.isItDynamic( _destArray_ )
		)



			?_dstd_ := @dim( _destArray_ );
			?_dSize_ := @ElementSize( _destArray_ );
			?_sSize_ := @Size( _srcArray_.elementType );

			#if
			(
					_sSize_ <> 1
				&	_sSize_ <> 2
				&	_sSize_ <> 4
				&	_sSize_ <> 8
				&	_sSize_ <> _dSize_
			)

				#error
				(
					"array.transpose: " nl
					"Can only handle arrays with 1, 2, 4, or 8 byte elements"
				);

			#elseif
			( 
					@elements( _srcArray_.dopeVector ) <= _xpos_
					 
				|	@arity( _destArray_ ) <= _xpos_

				|	@elements( _srcArray_.dopeVector ) <> 
											@arity( _destArray_ ) 
			)

				#error
				(
					"array.transpose:" nl
					"Arrays must have at least "
					+ string( _xpos_ ) + " dimensions" nl
					"and they must have the same number of dimensions"
				);



			#else

				// We must check for proper array shapes at run-time
				// since we don't know the source array dimensions
				// until then.

				if
				(#{
					?_i_ := 1;
					#while( _i_ < @arity( _destArray_ ))

						#if( _i_ <> _xpos_ )

							cmp
							(
								_srcArray_.dopeVector[ _i_ * 4 ],
								_dstd_[_i_]
							);
							jne true;

						#endif
						?_i_ := _i_ + 1;

					#endwhile
					 
					cmp
					(
						_srcArray_.dopeVector[0], _dstd_[_xpos_]
					);
					jne true;
					cmp
					(
						_srcArray_.dopeVector[_xpos_*4], _dstd_[0]
					);
					je false;

				}#) then

					raise( ex.ArrayShapeViolation );

				endif;

				


				// Optimize the most common case (transposing
				// a two-dim array or the last two dimensions
				// of an array).

				#if( _xpos_ = 1 )

					push( eax );
					push( ebx );
					push( ecx );
					push( edx );
					push( esi );
					push( edi );

					// Note: assume that the src and dest array
					// sizes are the same:

					mov( _srcArray_.dataPtr, ebx );
					lea( ecx, [ebx + @size( _destArray_ )] );
					push( ecx );
					lea( ecx, _destArray_ );
					sub( _dstd_[0] * _dstd_[1] * _dSize_, ecx );
					while( ebx < [esp] ) do

						add( _dstd_[0] * _dstd_[1] * _dSize_, ecx );
						for( mov(0, esi ); esi < _dstd_[0]; inc( esi )) do

							for
							( 
								mov( 0, edi ); 
								edi < _dstd_[_xpos_]; 
								inc( edi )
							) do

								#if( _dSize_ = 1 )

									intmul( _dstd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], al );
									mov( al, [ecx+edx] );
									inc( ebx );

								#elseif( _dSize_ = 2 )

									intmul( _dstd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], ax );
									mov( ax, [ecx+edx*2] );
									add( 2, ebx );

								#elseif( _dSize_ = 4 )

									intmul( _dstd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], eax );
									mov( eax, [ecx+edx*4] );
									add( 4, ebx );

								#else

									intmul( _dstd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], eax );
									mov( eax, [ecx+edx*8] );
									mov( [ebx+4], eax );
									mov( eax, [ecx+edx*8+4] );
									add( 8, ebx );

								#endif

							endfor;

						endfor;

					endwhile;
					add( 4, esp );
					pop( edi );
					pop( esi );
					pop( edx );
					pop( ecx );
					pop( ebx );
					pop( eax );



				
				// Okay, handle the case where we are not transposing
				// the last two dimensions of the array.  This one is
				// ugly and less efficient (hence the special case
				// above).

				#else


					push( eax );
					push( ebx );
					push( esi );
					push( edi );


					// Make room for a set of loop control variables
					// on the stack:

					sub( @arity( _destArray_ ) * 4, esp );

					// Initialize array base pointers.

					mov( _srcArray_.dataPtr, esi );
					lea( ebx, _destArray_ );

					// Emit the for loops that will do the
					// transposition.

					?_i_ := @arity( _destArray_ );
					#while( _i_ > 0 )

						?_offset_ := ( _i_ - 1 ) * 4;
						for
						( 
							mov(0, (type dword [esp+_offset_]));
							(type dword [esp+_offset_]) < _dstd_[_i_ - 1];
							inc( (type dword [esp+_offset_]))
						) do
						?_i_ := _i_ - 1;

					#endwhile

					// Compute index into the destination array.
					// Note: to properly transpose, we need to
					// swap the zero index with the _xpos_ index.
					//
					// Begin by checking to see if the highest dimension
					// is _xpos_.  If so, use loop counter zero as the
					// index value.  If not, use loop counter n (n=arity-1)
					// as the index value.

					?_i_ := @arity( _destArray_ ) - 1;
					#if( _i_ = _xpos_ )

						mov( (type dword [esp] ), edi );
	
					#else

						mov
						( 
							(type dword [esp + _i_*4] ), 
							edi
						);

					#endif

					// Okay, for all dimensions except _xpos_ and zero,
					// compute the row-major offset into the array.
					// Swap indicies zero and _xpos_.  Note that _xpos_
					// may have been handled above.

					?_i_ := _i_ - 1;
					#while( _i_ > 0 )

						array.mulbyConst
						( 
							@dim( _destArray_ )[_i_], 
							edi 
						);
						#if( _i_ = _xpos_ )

							add( [esp], edi );

						#else

							add( [esp+_i_*4], edi );

						#endif
						?_i_ := _i_ - 1;

					#endwhile
					array.mulbyConst( _dstd_[_xpos_], edi );
					add( [esp + _xpos_*4], edi );

					// Okay, EDI is the index into the destination array.
					// ESI contains the pointer at the current source
					// element.  Copy the data from the source array to
					// the destination array.

					#if( _dSize_ = 1 )

						mov( [esi], al );
						mov( al, [ebx+edi] );
						inc( esi );


					#elseif( _dSize_ = 2 )

						mov( [esi], ax );
						mov( ax, [ebx+edi*2] );
						add( 2, esi );


					#elseif( _dSize_ = 4 )

						mov( [esi], eax );
						mov( eax, [ebx+edi*4] );
						add( 4, esi );

					#else

						mov( [esi], eax );
						mov( [esi+4], edx );
						mov( eax, [ebx+edi*8] );
						mov( edx, [ebx+edi*8+4] );
						add( 8, esi );

					#endif
					?_i_ := 0;
					#while( _i_ < @arity( _destArray_ ))

						endfor;
						?_i_ := _i_ + 1;

					#endwhile

					// Remove loop control variables from the stack.
					
					add( @arity( _destArray_ ) * 4, esp );

					// Remove registers from the stack:

					pop( edi );
					pop( esi );
					pop( ebx );
					pop( eax );

				#endif

				

			#endif

		

		
		
		
		
		
		
		
		#else // Both arrays must be static.


			?_srcd_ := @dim( _srcArray_ );
			?_dstd_ := @dim( _destArray_ );
			?_sSize_ := @ElementSize( _srcArray_ );
			?_dSize_ := @ElementSize( _destArray_ );
			#if
			(
					_sSize_ <> 1
				&	_sSize_ <> 2
				&	_sSize_ <> 4
				&	_sSize_ <> 8
				&	_sSize_ <> _dSize_
			)

				#error
				(
					"array.transpose: " nl
					"Can only handle arrays with 1, 2, 4, or 8 byte elements"
				);

			#elseif
			( 
					@arity( _srcArray_ ) <= _xpos_ 
				|	@arity( _destArray_ ) <= _xpos_
				|	@arity( _srcArray_ ) <> @arity( _destArray_ ) 
			)

				#error
				(
					"array.transpose:" nl
					"Arrays must have at least "
					+ string( _xpos_ ) + " dimensions" nl
					"and they must have the same number of dimensions"
				);



			#else

				// Verify that the shapes of the arrays are reasonable.

				#if
				( 
						_srcd_[0] <> _dstd_[_xpos_]
					|	_srcd_[_xpos_] <> _dstd_[0]
				)

					#error
					(
						"array.transpose:" nl
						"Array shapes are incorrect"
					);

				#else

					?_i_ := 1;
					#while( _i_ < @arity( _destArray_ ))

						#if( _i_ <> _xpos_ )

							#if( _srcd_[_i_] <> _dstd_[_i_] )

								#error
								(
									"array.transpose:" nl
									"Array shapes are incompatible"
								)
							#endif

						#endif
						?_i_ := _i_ + 1;

					#endwhile

				#endif


				// Optimize the most common case (transposing
				// a two-dim array or the last two dimensions
				// of an array).

				#if( _xpos_ = 1 )

					push( eax );
					push( ebx );
					push( ecx );
					push( edx );
					push( esi );
					push( edi );

					lea( ebx, _srcArray_ );
					lea( ecx, [ebx + @size( _srcArray_ )] );
					push( ecx );
					lea( ecx, _destArray_ );
					sub( _dstd_[0] * _dstd_[1] * _dSize_, ecx );
					while( ebx < [esp] ) do

						add( _dstd_[0] * _dstd_[1] * _dSize_, ecx );
						for( mov(0, esi ); esi < _dstd_[0]; inc( esi )) do

							for
							(
								mov( 0, edi ); 
								edi < _dstd_[_xpos_]; 
								inc( edi )
							) do

								#if( _sSize_ = 1 )

									intmul( _dstd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], al );
									mov( al, [ecx+edx] );
									inc( ebx );

								#elseif( _sSize_ = 2 )

									intmul( _dstd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], ax );
									mov( ax, [ecx+edx*2] );
									add( 2, ebx );

								#elseif( _sSize_ = 4 )

									intmul( _dstd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], eax );
									mov( eax, [ecx+edx*4] );
									add( 4, ebx );

								#elseif( _sSize) = 8 )

									intmul( _dstd_[0], edi, edx );
									add( esi, edx );
									mov( [ebx], eax );
									mov( eax, [ecx+edx*8] );
									mov( [ebx+4], eax );
									mov( eax, [ecx+edx*8+4] );
									add( 8, ebx );

								#endif

							endfor;

						endfor;

					endwhile;
					add( 4, esp );
					pop( edi );
					pop( esi );
					pop( edx );
					pop( ecx );
					pop( ebx );
					pop( eax );



				
				// Okay, handle the case where we are not transposing
				// the last two dimensions of the array.  This one is
				// ugly and less efficient (hence the special case
				// above).

				#else

					// Make room for a set of loop control variables
					// on the stack:

					push( eax );
					push( ebx );
					push( esi );
					push( edi );

					lea( esi, _srcArray_ );
					lea( ebx, _destArray_ );
					sub( @arity( _destArray_ ) * 4, esp );
					?_i_ := @arity( _destArray_ );
					#while( _i_ > 0 )

						?_offset_ := ( _i_ - 1 ) * 4;
						for
						( 
							mov(0, (type dword [esp+_offset_]));
							(type dword [esp+_offset_]) < _dstd_[_i_ - 1];
							inc( (type dword [esp+_offset_]))
						) do
						?_i_ := _i_ - 1;

					#endwhile

					// Compute index into the destination array.
					// Note: to properly transpose, we need to
					// swap the zero index with the _xpos_ index.
					//
					// Begin by checking to see if the highest dimension
					// is _xpos_.  If so, use loop counter zero as the
					// index value.  If not, use loop counter n (n=arity-1)
					// as the index value.

					?_i_ := @arity( _destArray_ ) - 1;
					#if( _i_ = _xpos_ )

						mov( (type dword [esp] ), edi );
	
					#else

						mov
						( 
							(type dword [esp + _i_*4] ), 
							edi
						);

					#endif

					// Okay, for all dimensions except _xpos_ and zero,
					// compute the row-major offset into the array.
					// Swap indicies zero and _xpos_.  Note that _xpos_
					// may have been handled above.

					?_i_ := _i_ - 1;
					#while( _i_ > 0 )

						array.mulbyConst
						( 
							_dstd_[_i_], 
							edi 
						);
						#if( _i_ = _xpos_ )

							add( [esp], edi );

						#else

							add( [esp+_i_*4], edi );

						#endif
						?_i_ := _i_ - 1;

					#endwhile
					array.mulbyConst( _dstd_[_xpos_], edi );
					add( [esp + _xpos_*4], edi );

					// Okay, EDI is the index into the destination array.
					// ESI contains the pointer at the current source
					// element.  Copy the data from the source array to
					// the destination array.

					#if( _dSize_ = 1 )

						mov( [esi], al );
						mov( al, [ebx+edi] );
						inc( esi );


					#elseif( _dSize_ = 2 )

						mov( [esi], ax );
						mov( ax, [ebx+edi*2] );
						add( 2, esi );


					#elseif( _dSize_ = 4 )

						mov( [esi], eax );
						mov( eax, [ebx+edi*4] );
						add( 4, esi );

					#else

						mov( [esi], eax );
						mov( [esi+4], edx );
						mov( eax, [ebx+edi*8] );
						mov( edx, [ebx+edi*8+4] );
						add( 8, esi );

					#endif
					?_i_ := 0;
					#while( _i_ < @arity( _destArray_ ))

						endfor;
						?_i_ := _i_ + 1;

					#endwhile

					// Remove loop control variables from the stack.
					
					add( @arity( _destArray_ ) * 4, esp );

					// Remove registers from the stack:

					pop( edi );
					pop( esi );
					pop( ebx );
					pop( eax );

				#endif

				

			#endif

		#endif

	#endmacro

/*************************************************************************/
//
//	print( array, minwidth, decpts )

	#macro print( _arrayToPrint_, _fmt_[] ):
		_dims_,
		_Arity_,
		_fmtOptions_,
		_elementTypeName_;

		#if( @elements( _fmt_ ) = 0 )

			?_fmtOptions_:text := "";

		#elseif( @elements( _fmt_ ) = 1 )

			?_fmtOptions_:text := ":" + _fmt_[0];

		#elseif( @elements( _fmt_ ) = 2 )

			?_fmtOptions_:text := ":" + _fmt_[0] + ":" + _fmt_[1];

		#else

			#error( "array.print: too many parameters" );
			?_fmtOptions_:text := "";

		#endif

		push( eax );
		push( edx );
		push( esi );
		push( edi );
		#if( !array.isItDynamic( _arrayToPrint_ ))

			?_dims_ := @dim( _arrayToPrint_ );
			?_Arity_ := @arity( _arrayToPrint_ );

			xor( esi, esi );
			mov( 1, edi );
			while( edi <= @elements( _arrayToPrint_ ) ) do

				stdout.put( _arrayToPrint_[ esi ] _fmtOptions_ );
				#if( _Arity_ > 1 )
				
					mov( edi, eax );
					cdq();
					div( _dims_[ 0 ], edx:eax );
					if( !edx ) then

						stdout.newln();

						#if( _Arity_ > 2 )

							mov( edi, eax );
							cdq();
							div( _dims_[0] * _dims_[1], edx:eax );
							if( !edx ) then

								stdout.newln();

							endif;

						#endif

					else

						stdout.put( ", " );

					endif;

				#endif
				add( @ElementSize( _arrayToPrint_ ), esi );
				inc( edi );

			endwhile;

		#else

			?_Arity_ := 1;
			push( ecx );
			push( ebx );
			mov( _arrayToPrint_.dopeVector[0], ecx );
			mov( _arrayToPrint_.dataPtr, esi );
			#while( _Arity_ < @elements( _arrayToPrint_.dopeVector ) )

				intmul( _arrayToPrint_.dopeVector[ _Arity_*4 ], ecx );
				?_Arity_ := _Arity_ + 1;

			#endwhile

			mov( _arrayToPrint_.dataPtr, esi );
			mov( 1, edi );
			while( edi <= ecx ) do

				?_elementTypeName_:text := @typename( _arrayToPrint_.elementType );
				stdout.put
				( 
					(type  _elementTypeName_ [ esi ]) 
					_fmtOptions_ 
				);
				#if( @elements( _arrayToPrint_.dopeVector ) > 1 )
				
					mov( edi, eax );
					cdq();
					div
					( 
						(type uns32 _arrayToPrint_.dopeVector[0]), 
						edx:eax 
					);
					if( !edx ) then

						stdout.newln();

						#if( _Arity_ > 2 )

							mov( _arrayToPrint_.dopeVector[ 0 ], ebx );
							intmul(	_arrayToPrint_.dopeVector[ 4 ], ebx );
							mov( edi, eax );
							cdq();
							div( ebx, edx:eax );
							if( !edx ) then

								stdout.newln();

							endif;

						#endif

					else

						stdout.put( ", " );

					endif;

				#endif
				add( @Size( _arrayToPrint_.elementType ), esi );
				inc( edi );

			endwhile;
			pop( ebx );
			pop( ecx );
				
		#endif
		pop( edi );
		pop( esi );
		pop( edx );
		pop( eax );

		// Deallocate compile-time storage for _dims_

		?_dims_ := 0;

	#endmacro



/*************************************************************************/
//
// lookupTable-
//
// Generate a lookup table (only in the read-only data section)
//
// Usage:
//
//  someID: 
//		array.lookupTable
//		( 
//			elementType,
//			defaultCaseLabel, 
//			tableValue:indexList, 
//			tableValue:indexList, 
//			... 
//		);
//
// For each value in the indexList list of values, this macro inserts
// the "tableValue" into the array at each specified index, e.g.,
//
//    luTable : 
//        array.lookupTable
//        (
//			dword,			// Data type
//            $ff,			// Default value for empty holes.
//            10: 9, 
//            11: 10, 
//            12: 0, 
//            13: 5, 
//            14: 12, 
//            15: 8, 
//            16: 16, 
//            18: 14 15, 
//            19: 6 7 11 13, 
//            20: 1 
//        );
//
// This creates the following array:
//
//	luTable:dword[17] :=
//		[
//			12,			// from 12:0
//			20,			// from 20:1
//			$ff,
//			$ff,
//			$ff,
//			13,			// from 13:5
//			19,			// from 19:6 7 11 13
//			19,			//  "    "   "   "
//			15,			// from 15:8
//			10,			// from 10:9
//			11,			// from 11:10
//			19,			// from 19:6 7 11 13
//			14,			// from 14:12
//			19,			// from 19:6 7 11 13
//			18,			// from 18:14 15
//			18,			// from 18:14 15
//			16			// from 16:16
//	];
//
// This macro serves as a "data type" declaration returning the type and
// constant data for a lookup table. It also defines the following constants:
//
//	someID_minValue - Minimum lookup value appearing in the table.
//	someID_minIndex - Minimum lookup value times the size of a table entry.
//
//	someID_maxValue - Maximum lookup value appearing in the table.
//	someID_maxIndex - Maximum lookup value times the size of a table entry.


// Constants you may want to change to control warnings emitted by
// the mwjmp macro:

val
    maxCases    := 4096;    // Maximum # of cases we will allow
                            
    largeTable  := 256;     // A "large" table has at least 256 entries
    
    sparseTable := 4;       // A "sparse" table is one that has 4x as
                            // many (or more) unused entries as it has
                            // actual entries.

type
    caseRecord:
        record

            value   :dword;
            lblStr  :string;

        endrecord;
        
val
    cases   	:caseRecord[ maxCases ] := maxCases dup [caseRecord:[0,""]];
	
	leftItem	:caseRecord := caseRecord:[ 0, "" ];
	rightItem	:caseRecord := caseRecord:[ 0, "" ];
		
	#macro lessThan;
	
		(array.leftItem.value < array.rightItem.value)
		
	#endmacro

        
            
	#macro lookupTable( tableType, _defaultCase_, _entries_[] ):
	    _boundsError_,
	    _numEntries_, 
	    _i_,
	    _j_,
	    _k_,
		_m_,
	    _endLabel_,
	    _tableValue_,
	    _valueList_,
	    _slots_,
	    _minLabel_,
		_maxLabel_,
	    _tableID_;

	    // First, save the label applied to this array so we
	    // can generate the minLabel later.
	    
	    forward( _tableID_ );   
	    ?_numEntries_ := @elements( _entries_ );

	    
	    // Okay, parse each of the arguments and extract the constant
	    // and label components, and insert them into the array.cases 
	    // array:
	    
	    ?_i_ := 0;
	    ?_j_ := 0;
	    ?_boundsError_ := false;
	    #while( (_i_ < _numEntries_) & (!_boundsError_) )
	    
	        ?_endLabel_ := @index( _entries_[_i_], 0, ':' );
	        #if( _endLabel_ > 0 )
	                             
	            ?_tableValue_ := @substr( _entries_[_i_], 0, _endLabel_ );
				?_valueList_ := 
					@tokenize
					( 
						_entries_[_i_], 
						_endLabel_+1, 
						{#1..' '}, 
						{'(', '[', '{'} 
					); 
	            
	            // Okay, generate a array.cases entry for each of the values:
	            
	            // See if we've added too many entries to the cases array:
	            
	            ?_boundsError_ := _j_ >= array.maxCases;
	            
	            // Now, repeat for each value in the values list:
	             
				?_k_ := 0;
	            #while( (_k_ < @elements( _valueList_ )) & (!_boundsError_) )
	            
	                ?array.cases[_j_].lblStr := _tableValue_;
	                ?array.cases[_j_].value := 
	                    @text( _valueList_[_k_] );
	                    
					// Move on to the next entry:

					?_k_ += 1;

	                // Check for too many cases:
	                
	                ?_j_ := _j_ + 1;
	                ?_boundsError_ := _j_ >= array.maxCases;

	            #endwhile
	            	        
	        #else
	        
	            #error( "Error, mal-formed case entry: '", _entries_[_i_], "'" )
	            
	        #endif
	        ?_i_ := _i_ + 1;
	    
	    #endwhile

	    #if( _j_ > 0 )
	    
	        // Okay, now sort the case entries in ascending order:
	        
			?array.cases := 
				@sort
				( 
					array.cases, 
					_j_, 
					array.leftItem,
					array.rightItem,
					"array.lessThan"
				);
	        
	        
	        // A quick sanity check on the lookup table we're about to create.
	        // If the difference between the minimum and maximum values is
	        // quite large, and the table is sparse, we should warn the user
	        // about this situation. For the purposes of "large" we'll assume
	        // a distance of at least 1,024 items (see the constant in the
	        // hla namespace). For the purposes of "sparse", we'll assume
	        // that at least 75% of the entries are unused (again see the
	        // constant declarations in hla).
	        //
	        //
	        // Begin by computing the number of "slots" (entries) in the lookup
	        // table:
	        
	        ?_slots_ := 
	                array.cases[ _j_ - 1 ].value // Maximum case value 
	            -   array.cases[ 0 ].value       // Minimum case value
	            +   1;
	            
	        #if( _slots_ >= array.largeTable )
	        
	            #if( (real32( _j_ ) / real32( _slots_ )) < 0.25 )
	            
	                #print
	                ( 
	                    "Warning: lookup table created by chuck macro is LARGE" 
	                )
	                #print
	                ( 
	                    "and sparse (", 
	                    uns32( _j_ ), 
	                    " cases and ",
	                    uns32( _slots_ ),
	                    " entries)"
	                )
	                #print( "You might want to consider whether you really")
	                #print( "want to use a lookup table here." )  
	            
	            #endif
	            
	        #endif
	        
	        // Create the minLabel constants:

	        ?_minLabel_ := @string( @text( @string( _tableID_ )))+ "_minIndex";
	        ?@text(_minLabel_) := array.cases[0].value*@size(tableType);

	        ?_minLabel_ := @string( @text( @string( _tableID_ )))+ "_minValue";
	        ?@text(_minLabel_) := array.cases[0].value;

			// Create the maxLabel constants:

			?_maxLabel_ := @string( @text( @string( _tableID_ )))+ "_maxIndex";
	        ?@text(_maxLabel_) := 
	        	array.cases[_j_-1].value*@size(tableType);

			?_maxLabel_ := @string( @text( @string( _tableID_ )))+ "_maxValue";
	        ?@text(_maxLabel_) := 
	        	array.cases[_j_-1].value;

	        // Okay, emit the entries for the lookup table:
	        
	        _tableID_:tableType[ _slots_ ] :=
	        [   
	            // Always emit the first entry into the table:

	            @text( array.cases[0].lblStr )
	            
	            // Emit the remaining entries (if any);
	            
	            ?_curIndex_ := array.cases[0].value+1;
				?_m_ := 1;
				?_k_ := 1;
	            #while( _k_ < _slots_ )

					// Check for duplicate indexes into the table:

					#if( array.cases[_m_-1].value = array.cases[_m_].value )

						#error
						(
							"Encountered a duplicate index value (" +
							string( array.cases[_m_-1].value ) +
							") while generating lookup table"
						)

					#endif
	                
	                // Fill in any "holes" in the lookup table with
	                // the address of the default case label:
	                
	                #while( _curIndex_ < array.cases[_m_].value )
	                
	                    ,_defaultCase_
	                    ?_curIndex_ := _curIndex_ + 1;
						?_k_ := _k_ + 1;
	                    
	                #endwhile
	                
	                // Emit the next user-specified entry in the
	                // lookup table:
	                
	                ,@text( array.cases[_m_].lblStr )
	                ?_curIndex_ := _curIndex_ + 1;
					?_k_ := _k_ + 1;
					?_m_ := _m_ + 1;

	                
	            #endwhile 
	        
	        ]
	            
	        
	        
	        
	    #else
	    
	        #error( "chuck must have at least one valid case entry" )
	        
	    #endif  
	    
	#endmacro
	
            

end array;




#endif


