// stl.hhf -- HLA Standard Template Library
//
// 11/09/2005-
//	Added vector template to library.
//
// 11/12/2005-
//	Added deque template to library.


#includeonce( "memory.hhf" )
#includeonce( "strings.hhf" )
#includeonce( "cset.hhf" )
#includeonce( "excepts.hhf" )

namespace stl;

const
	true := @global:true;
	false := @global:false;

	hierarchyNames:string[] :=
		[
			"isContainer",			
			"isRandomAccess",
			"isArray",		
			"isVector",
			"isDeque",
			"isList",
			"isTable"		
		];

	capabilityNames:string[] :=
		[
			"supportsOutput",
			"supportsCompare",
			"supportsInsert",		
			"supportsRemove",		
			"supportsAppend",		
			"supportsPrepend",		
			"supportsSwap",
			"supportsForeach",
			"supportsrForeach",
			"supportsCursor",
			"supportsSearch",		
			"supportsElementSwap",
			"supportsObjSwap",
			"elementsAreObjects"
		];

	performanceNames:string[] :=
		[
			"fastInsert",			
			"fastRemove",			
			"fastAppend",			
			"fastPrepend",			
			"fastSwap",
			"fastSearch",			
			"fastElementSwap"		
		];

	// Generate a list of constant declarations, based on the
	// above strings. Each declaration takes the form:
	//
	//		<name>_c := @{i};
	//
	//	where "<name>" corresponds to one of the above strings and
	//	i is an incrementing value (0..n).

	?bitNum :uns32 := 0;
	#for( cn in capabilityNames )

		@text( cn + "_c := @{" + string(bitNum) + "}" );
		?bitNum := bitNum + 1;

	#endfor

	?bitNum :uns32 := 0;
	#for( cn in hierarchyNames )

		@text( cn + "_c := @{" + string(bitNum) + "}" );
		?bitNum := bitNum + 1;

	#endfor

	?bitNum :uns32 := 0;
	#for( cn in performanceNames )

		@text( cn + "_c := @{" + string(bitNum) + "}" );
		?bitNum := bitNum + 1;

	#endfor


/////////////////////////////////////////////////////////////////////////////
//
// parseCapabilities-
// parseHierarchy-
// parsePerformance-
//
//	Processes user-defined capability lists.
//
//	Each entry in a capability list takes the following form:
//
//		<name>:1
// -or-
//		<name>:0
//
//	Where <name> is one of the names in one of the capability lists.
//	Note that no spaces may appear around the ":" character.
//	A value of zero disables the capability, a value of one enables it.

#macro parseCapabilities( capabilities, userList ):
	caps,
	curCapability, 
	index,
	setting, 
	found;

	?caps := capabilities;

	#for( curCapability in userList )

		// See if the current user-specified entry begins with
		// one of the valid capability names:

		?index := 0;
		?found := false;
		#while( !found & index < @elements(stl.capabilityNames)  )

			?found := 
				@index( curCapability, 0, stl.capabilityNames[index] ) = 0;

			?index := index + 1;

		#endwhile

		// Okay, if we found a valid name, let's process it.

		#if( found )

			?index := index - 1;
			?setting :uns32:= 
				uns32
				( 
					@substr
					( 
						curCapability, 
						@length( stl.capabilityNames[index] )+1,
						10000
					)
				);

			#if( setting = 0 )

				?caps := caps & 
					!@text
					(
						"stl." +stl.capabilityNames[index] + "_c"
					);
					
			#else

				?caps := caps | 
					@text
					(
						"stl." +stl.capabilityNames[index] + "_c"
					);
					
			#endif
			
		#endif 
		
	#endfor
	caps
#endmacro



#macro parsePerformance( performance, userList ):
	perform,
	curPerform, 
	index,
	setting, 
	found;

	?perform := performance;

	#for( curPerform in userList )

		// See if the current user-specified entry begins with
		// one of the valid capability names:

		?index := 0;
		?found := false;
		#while( !found & index < @elements(stl.performanceNames)  )

			?found := 
				@index( curPerform, 0, stl.performanceNames[index] ) = 0;

			?index := index + 1;

		#endwhile

		// Okay, if we found a valid name, let's process it.

		#if( found )

			?index := index - 1;
			?setting := 
				uns32
				( 
					@substr
					( 
						curPerform, 
						@length( stl.performanceNames[index] )+1,
						10000
					)
				);

			#if( setting = 0 )

				?perform := perform & 
					!@text
					(
						"stl." +stl.performanceNames[index] + "_c"
					);
					
			#else

				?perform := perform | 
					@text
					(
						"stl." +stl.performanceNames[index] + "_c"
					);
					
			#endif
			
		#endif 
		
	#endfor
	perform
#endmacro


/////////////////////////////////////////////////////////////////////////////
//
// checkTraits-
//	Verifies that all user-specified traits (found in "toCheck") are present
//	in the list of valid traits ("validTraits")

#macro checkTraits( toCheck, validTraits ):
	curTrait, 
	userTrait,
	found;

	#for( userTrait in toCheck )

		// See if the current user-specified entry begins with
		// one of the valid capability names:

		?found :boolean := false;
		#for( curTrait in validTraits )

			?found := 
				found | (@index( userTrait, 0, curTrait ) = 0);

		#endfor

		// If we didn't find the user-specified trait, complain:

		#if( !found )

			#error
			( 
				"Unknown trait specified in template declaration: " +
				userTrait
			)
						
		#endif 
		
	#endfor
#endmacro



//////////////////////////////////////////////////////////////////////////////
//
// stdCompares-
//
//	Generates a standard set of comparison operations for built-in HLA types.

#macro stdCompares( theType );

	#if
	( 
			@ptype( theType ) = hla.ptBoolean
		|	@ptype( theType ) = hla.ptByte
		|	@ptype( theType ) = hla.ptUns8
		|	@ptype( theType ) = hla.ptChar
	)

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], al );
			mov( right, ebx );
			cmp( al, [ebx] );
			sete( al );
			and( $ff, eax );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], al );
			mov( right, ebx );
			cmp( al, [ebx] );
			setb( al );
			and( $ff, eax );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;


			push( ebx );
			mov( left, ebx );
			mov( [ebx], al );
			mov( right, ebx );
			cmp( al, [ebx] );
			setbe( al );
			and( $ff, eax );
			pop( ebx );

		end isLessEqual;


	#elseif
	( 
			@ptype( theType ) = hla.ptWord
		|	@ptype( theType ) = hla.ptUns16
		|	@ptype( theType ) = hla.ptWChar
	)

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], ax );
			mov( right, ebx );
			cmp( ax, [ebx] );
			sete( al );
			and( $ff, eax );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], ax );
			mov( right, ebx );
			cmp( ax, [ebx] );
			setb( al );
			and( $ff, eax );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;


			push( ebx );
			mov( left, ebx );
			mov( [ebx], ax );
			mov( right, ebx );
			cmp( ax, [ebx] );
			setbe( al );
			and( $ff, eax );
			pop( ebx );

		end isLessEqual;


	#elseif
	( 
			@ptype( theType ) = hla.ptDWord
		|	@ptype( theType ) = hla.ptUns32
	)

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], eax );
			mov( right, ebx );
			cmp( eax, [ebx] );
			sete( al );
			and( $ff, eax );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], eax );
			mov( right, ebx );
			cmp( eax, [ebx] );
			setb( al );
			and( $ff, eax );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;


			push( ebx );
			mov( left, ebx );
			mov( [ebx], eax );
			mov( right, ebx );
			cmp( eax, [ebx] );
			setbe( al );
			and( $ff, eax );
			pop( ebx );

		end isLessEqual;


	#elseif
	( 
			@ptype( theType ) = hla.ptQWord
		|	@ptype( theType ) = hla.ptUns64
	)

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+4], eax );
			mov( right, ecx );
			cmp( eax, [ecx+4] );
			if( @e ) then

				mov( [ebx], eax );
				cmp( eax, [ecx] );

			endif;
			sete( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+4], eax );
			mov( right, ecx );
			cmp( eax, [ecx+4] );
			if( @e ) then

				mov( [ebx], eax );
				cmp( eax, [ecx] );

			endif;
			setb( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+4], eax );
			mov( right, ecx );
			cmp( eax, [ecx+4] );
			if( @e ) then

				mov( [ebx], eax );
				cmp( eax, [ecx] );

			endif;
			setbe( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isLessEqual;


	#elseif
	( 
			@ptype( theType ) = hla.ptLWord
		|	@ptype( theType ) = hla.ptUns128
	)

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+12], eax );
			mov( right, ecx );
			cmp( eax, [ecx+12] );
			if( @e ) then

				mov( [ebx+8], eax );
				cmp( eax, [ecx+8] );
				if( @e ) then

					mov( [ebx+4], eax );
					cmp( eax, [ecx+4] );
					if( @e ) then

						mov( [ebx], eax );
						cmp( eax, [ecx] );

					endif;

				endif;

			endif;
			sete( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+12], eax );
			mov( right, ecx );
			cmp( eax, [ecx+12] );
			if( @e ) then

				mov( [ebx+8], eax );
				cmp( eax, [ecx+8] );
				if( @e ) then

					mov( [ebx+4], eax );
					cmp( eax, [ecx+4] );
					if( @e ) then

						mov( [ebx], eax );
						cmp( eax, [ecx] );

					endif;

				endif;

			endif;
			setb( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+12], eax );
			mov( right, ecx );
			cmp( eax, [ecx+12] );
			if( @e ) then

				mov( [ebx+8], eax );
				cmp( eax, [ecx+8] );
				if( @e ) then

					mov( [ebx+4], eax );
					cmp( eax, [ecx+4] );
					if( @e ) then

						mov( [ebx], eax );
						cmp( eax, [ecx] );

					endif;

				endif;

			endif;
			setbe( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isLessEqual;


	#elseif( @ptype( theType ) = hla.ptInt8 )

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], al );
			mov( right, ebx );
			cmp( al, [ebx] );
			sete( al );
			and( $ff, eax );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], al );
			mov( right, ebx );
			cmp( al, [ebx] );
			setl( al );
			and( $ff, eax );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;


			push( ebx );
			mov( left, ebx );
			mov( [ebx], al );
			mov( right, ebx );
			cmp( al, [ebx] );
			setle( al );
			and( $ff, eax );
			pop( ebx );

		end isLessEqual;

	#elseif( @ptype( theType ) = hla.ptInt16 )

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], ax );
			mov( right, ebx );
			cmp( ax, [ebx] );
			sete( al );
			and( $ff, eax );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], ax );
			mov( right, ebx );
			cmp( ax, [ebx] );
			setl( al );
			and( $ff, eax );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;


			push( ebx );
			mov( left, ebx );
			mov( [ebx], ax );
			mov( right, ebx );
			cmp( ax, [ebx] );
			setle( al );
			and( $ff, eax );
			pop( ebx );

		end isLessEqual;


	#elseif( @ptype( theType ) = hla.ptInt32 )

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], eax );
			mov( right, ebx );
			cmp( eax, [ebx] );
			sete( al );
			and( $ff, eax );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			mov( left, ebx );
			mov( [ebx], eax );
			mov( right, ebx );
			cmp( eax, [ebx] );
			setl( al );
			and( $ff, eax );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;


			push( ebx );
			mov( left, ebx );
			mov( [ebx], eax );
			mov( right, ebx );
			cmp( eax, [ebx] );
			setle( al );
			and( $ff, eax );
			pop( ebx );

		end isLessEqual;


	#elseif( @ptype( theType ) = hla.ptInt64 )

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+4], eax );
			mov( right, ecx );
			cmp( eax, [ecx+4] );
			if( @e ) then

				mov( [ebx], eax );
				cmp( eax, [ecx] );

			endif;
			sete( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+4], eax );
			mov( right, ecx );
			cmp( eax, [ecx+4] );
			if( @e ) then

				mov( [ebx], eax );
				cmp( eax, [ecx] );

			endif;
			setl( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+4], eax );
			mov( right, ecx );
			cmp( eax, [ecx+4] );
			if( @e ) then

				mov( [ebx], eax );
				cmp( eax, [ecx] );

			endif;
			setle( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isLessEqual;


	#elseif( @ptype( theType ) = hla.ptInt128 )

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+12], eax );
			mov( right, ecx );
			cmp( eax, [ecx+12] );
			if( @e ) then

				mov( [ebx+8], eax );
				cmp( eax, [ecx+8] );
				if( @e ) then

					mov( [ebx+4], eax );
					cmp( eax, [ecx+4] );
					if( @e ) then

						mov( [ebx], eax );
						cmp( eax, [ecx] );

					endif;

				endif;

			endif;
			sete( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+12], eax );
			mov( right, ecx );
			cmp( eax, [ecx+12] );
			if( @e ) then

				mov( [ebx+8], eax );
				cmp( eax, [ecx+8] );
				if( @e ) then

					mov( [ebx+4], eax );
					cmp( eax, [ecx+4] );
					if( @e ) then

						mov( [ebx], eax );
						cmp( eax, [ecx] );

					endif;

				endif;

			endif;
			setl( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;

			push( ebx );
			push( ecx );
			mov( left, ebx );
			mov( [ebx+12], eax );
			mov( right, ecx );
			cmp( eax, [ecx+12] );
			if( @e ) then

				mov( [ebx+8], eax );
				cmp( eax, [ecx+8] );
				if( @e ) then

					mov( [ebx+4], eax );
					cmp( eax, [ecx+4] );
					if( @e ) then

						mov( [ebx], eax );
						cmp( eax, [ecx] );

					endif;

				endif;

			endif;
			setle( al );
			and( $ff, eax );
			pop( ecx );
			pop( ebx );

		end isLessEqual;


	#elseif
	( 
			@ptype( theType ) = hla.ptReal32
		|	@ptype( theType ) = hla.ptReal64
		|	@ptype( theType ) = hla.ptReal80
	)


		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isEqual;

			mov( right, eax );
			fld( (type theType [eax]) );
			mov( left, eax );
			fld( (type theType [eax]) );
			fcomip();
			fstp( left );
			sete( al );
			and( $ff, eax );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLess;

			mov( right, eax );
			fld( (type theType [eax]) );
			mov( left, eax );
			fld( (type theType [eax]) );
			fcomip();
			fstp( left );
			setb( al );
			and( $ff, eax );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;

			mov( right, eax );
			fld( (type theType [eax]) );
			mov( left, eax );
			fld( (type theType [eax]) );
			fcomip();
			fstp( left );
			setbe( al );
			and( $ff, eax );

		end isLessEqual;


	#elseif( @ptype( theType ) = hla.ptString )

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;

		begin isEqual;

			mov( left, eax );
			pushd( [eax] );
			mov( right, eax );
			pushd( [eax] );
			call( str.eq );
			and( $ff, eax );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;

		begin isLess;

			mov( left, eax );
			pushd( [eax] );
			mov( right, eax );
			pushd( [eax] );
			call( str.lt );
			and( $ff, eax );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;

		begin isLessEqual;

			mov( left, eax );
			pushd( [eax] );
			mov( right, eax );
			pushd( [eax] );
			call( str.le );
			and( $ff, eax );

		end isLessEqual;


	#elseif( @ptype( theType ) = hla.ptCset )

		method symbol.isEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;

		begin isEqual;

			mov( left, eax );
			pushd( [eax] );
			mov( right, eax );
			pushd( [eax] );
			call( cs.eq );
			and( $ff, eax );

		end isEqual;

		method symbol.isLess
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;

		begin isLess;

			mov( left, eax );
			pushd( [eax] );
			mov( right, eax );
			pushd( [eax] );
			call( cs.lt );
			and( $ff, eax );

		end isLess;

		method symbol.isLessEqual
		( 
			var left:theType; 
			var right:theType 
		);	@nodisplay; @nostackalign;
		begin isLessEqual;

			mov( left, eax );
			pushd( [eax] );
			mov( right, eax );
			pushd( [eax] );
			call( cs.le );
			and( $ff, eax );

		end isLessEqual;


	#else

		// For non-primitive types, the user must write the
		// comparison routines, assuming the elements are
		// comparable.

	#endif

#endmacro


//////////////////////////////////////////////////////////////////////////////
//
// base-
// 	All STL objects are a subclass of base:

type

	base:
		class

			// isSTL_c exists so we can use the @defined compile-time
			// function to determine if an object is an STL object.

			const
				isSTL_c 				:boolean := @global:true;

			// Compile-time "traits":
			//
			// Once we know it's an STL object, we can use the
			// capabilities constant (at compile-time) to determine
			// the capabilities of an unknown STL type:

			val
				capabilities_c	:dword := 0;
				hierarchy_c		:dword := 0;
				performance_c	:dword := 0;



			var
				align( 4 );

				// Run-time traits:
				//
				// At run-time, we can test the capabilities variable to
				// determine the capabilities of an STL object.

				capabilities		:dword;
				hierarchy			:dword;
				performance			:dword;

				// Type name is initialized with a string specifying the
				// actual (user-defined) data type:

				typeName			:string;


				// This flag tells us whether the object was
				// allocated on the heap by the constructor.

				isAlloc				:boolean;


			// Method that will convert an STL object to a string (for output):

			method a_toString; @abstract;

		endclass;
		

static
	align(4);
	vmt( base ); 



//////////////////////////////////////////////////////////////////////////////
//
// Container-
//
// All container objects are a subclass of "Container"

type
	Container:
		class inherits( base );
			val
				hierarchy_c := hierarchy_c | isContainer_c;

			var
				align(4);

				// # of elements (nodes, whatever) in the container

				numElements	:uns32;

				// For containers (i.e., the isContainer_c bit is set in
				// capabilities), containerName specifies the name of
				// the container (e.g., "vector")

				containerName		:string;

			method getSize; @returns( "eax" );

		endclass;

static
	align( 4 );
	vmt(Container);

		// getSize-
		//	Returns the number of container items in EAX:

		method Container.getSize; @noframe;
		begin getSize;

			mov( this.numElements, eax );
			ret();

		end getSize;



////////////////////////////////////////////////////////////////////////////
//
// RandomAccessContainer-
// 	All Random Access class objects are a subclass of RandomAccessContainer:

type
	RandomAccessContainer:
		class inherits( Container );
			val
				hierarchy_c := hierarchy_c | isRandomAccess_c;

		endclass;

static
	vmt( RandomAccessContainer );
	


////////////////////////////////////////////////////////////////////////////
//
// ArrayContainer-
// 	All Array class objects are a subclass of ArrayContainer:

type
	ArrayContainer:
		class inherits( RandomAccessContainer );
			val
				hierarchy_c := hierarchy_c | isArray_c;

			var
				align( 4 );

				// Pointer to allocated storage:

				allocData		:dword;

				// Pointer to end of allocated storage

				endAllocData	:dword;

				// Max space for current allocation

				allocSize		:uns32;

				// Pointer to start of array data:

				data			:dword;

				// Pointer to end of array data:

				endData			:dword;

				// Size of array data currently in use

				dataSize		:uns32;
					

			method getAllocSize; @returns( "eax" );
			method getDataSize;	@returns( "eax" );
			method createArray( n:uns32; elementSize:uns32 );
			method clear;
			method destroy;

		endclass;


		method ArrayContainer.getAllocSize; @noframe;
		begin getAllocSize;

			mov( this.allocSize, eax );
			ret();

		end getAllocSize;


		method ArrayContainer.getDataSize; @noframe;
		begin getDataSize;

			mov( this.dataSize, eax );
			ret();

		end getDataSize;

		// Create a generic array object
		// (this is a private routine for use by derivative classes)

		method ArrayContainer.createArray( n:uns32; elementSize:uns32 );
			@nodisplay; @nostackalign;

		begin createArray;

			push( eax );

			// Allocate storage for the array and initialize
			// the appropriate fields:

			mov( 0, this.numElements );	// No actual elements in use yet.
			mov( 0, this.dataSize );
			mov( n, eax );
			intmul( elementSize, eax );
			mov( eax, this.allocSize );	// Allocated size for vector.
			@global:mem.alloc( eax );
			mov( eax, this.allocData );	// Pointer to allocated data.
			mov( eax, this.data );
			mov( eax, this.endData );	// Empty vector, endData is same as data
			add( this.allocSize, eax );	// Compute endAllocData
			mov( eax, this.endAllocData );
			pop( eax );

		end createArray;

		// Destroy-
		//	This is the generic destructor for array types.

		method ArrayContainer.destroy; @noframe;
		begin destroy;

			@global:mem.free( this.allocData );	// Free the data storage
			xor( eax, eax );
			mov( eax, this.allocData );
			mov( eax, this.endAllocData );
			mov( eax, this.data );
			mov( eax, this.endData );
			mov( eax, this.allocSize );
			mov( eax, this.numElements );
			mov( eax, this.dataSize );
			if( this.isAlloc ) then

				// If object was created on the heap, free it here:

				@global:mem.free( esi );

			endif;
			ret();

		end destroy;

		// Clear-
		//	Clears (but does not deallocate storage) all the elements
		//	in the array.

		method ArrayContainer.clear; @noframe;
		begin clear;

			push( eax );
			mov( 0, this.numElements );
			mov( 0, this.dataSize );
			mov( this.data, eax );
			mov( eax, this.endData );
			pop( eax );
			ret();

		end clear;



	static
		vmt( ArrayContainer );
		


//////////////////////////////////////////////////////////////////////////////
//
// _vector
//	This is a special "helper" class for the vector template that moves a lot
//	of code common to all vector types into a single class in order to reduce
//	the size of the code base produced by expanding a vector template. No
//	program should actually declare variables of type _vector, this class is
//	for internal use only.

type
	_vector:
		class inherits( ArrayContainer );
		
			procedure _append( toAppend:dword; appendSize:dword ); @use eax;
			procedure _insert
			( 
				toInsert:dword; 
				insertWhere:dword; 
				insertSize:dword 
			);

			procedure _remove( removeWhere:dword; removeSize:dword );
			

		endclass; 

		// _append-
		//	Appends a new element to the end of the vector.
		//
		// Inputs:
		//
		//	toAppend-
		//		Pointer to the data to append to the vector
		//
		//	appendSize-
		//		Size of the data object to append.

		procedure _vector._append( toAppend:dword; appendSize:dword );
			@nodisplay; @noalignstack;

		readonly
			sixteenCases:dword[17] :=
				[
					&defaultCase,
					&case1,
					&case2,
					&defaultCase,
					&case4,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&case8,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&case16
				];
		begin _append;

			// Begin by making sure we've got enough room in the
			// data array to hold the new object:

			mov( this.dataSize, edi );
			add( appendSize, edi );
			if( edi >= this.allocSize ) then

				// If the new element we're adding pushes us
				// beyond the end of the allocated storage,
				// reallocate by doubling the storage.

				shl( 1, edi );
				mov( edi, this.allocSize );
				@global:mem.realloc( this.allocData, edi );
				mov( eax, this.data );
				mov( eax, this.allocData );
				add( eax, edi );
				mov( edi, this.endAllocData );

			endif;

			// Special case out various small object sizes
			// for performance reasons.

			mov( appendSize, ecx );
			mov( this.data, edi );
			add( this.dataSize, edi );
			push( esi );
			mov( toAppend, esi );
			cld();
			cmp( ecx, 16 );
			ja defaultCase;
			jmp( sixteenCases[ ecx*4 ]);
			case1:
				movsb();
				jmp caseDone;

			case2:
				movsw();
				jmp caseDone;

			case4:
				movsd();
				jmp caseDone;

			case8:
				movsd();
				movsd();
				jmp caseDone;

			case16:
				movsd();
				movsd();
				movsd();
				movsd();
				jmp caseDone;

			defaultCase:
				rep.movsb();

			caseDone:
			pop( esi );
			mov( edi, this.endData );	// Maintain ptr to end of data.

			// Okay, bump up the element count by one:

			add( 1, this.numElements );
			mov( appendSize, eax );
			add(eax, this.dataSize );

		end _append;



		// _insert-
		//	Inserts an arbitrary "vector" object into a vector.
		//
		//	Inputs:
		//
		//	toInsert-
		//		Pointer to vector element to insert into the list.
		//
		//	insertWhere-
		//		Pointer to the spot in the vector where the new element
		//		is to be inserted.
		//
		//	insertSize-
		//		Size of the object being inserted.

		procedure _vector._insert
		( 
			toInsert:dword; 
			insertWhere:dword; 
			insertSize:dword 
		);
		begin _insert;

			push( esi );

			// As we're expanding the array by one element, let's make
			// sure we have room for the expansion:

			mov( this.dataSize, ecx );
			add( insertSize, ecx );
			if( ecx >= this.allocSize ) then

				// If the new element we're adding pushes us
				// beyond the end of the allocated storage,
				// reallocate by doubling the storage.

				lea( ecx, [ecx+ecx] );
				mov( ecx, this.allocSize );
				@global:mem.realloc( this.allocData, ecx );
				mov( eax, this.data );
				mov( eax, this.allocData );
				add( ecx, eax );
				mov( eax, this.endAllocData );
				sub( ecx, eax );
				add( this.dataSize, eax );
				mov( eax, this.endData );

			endif;


			// Okay, make room for the item we're going to insert:

			mov( insertWhere, eax );
			if( eax >= this.endData ) then

				mov( this.endData, eax );

			else

				// If we are inserting data at some point other than
				// at the end of the array, then we've got to move
				// everything along by one position to open up space
				// for the new element:

				std();
				mov( this.endData, edi );
				mov( edi, ecx );
				sub( eax, ecx );

				// Three variants of the actual insertion code,
				// based on the size of the object we're inserting:

				test( %11, insertSize );
				jz do4;
				test( %1, insertSize );
				jz do2;

					lea( esi, [edi-1] );
					add( insertSize, edi );
					sub( 1, edi );
					rep.movsb();
					jmp SpaceMade;

				do2:
					// Do this if the object's size is a multiple of 2 bytes:

					lea( esi, [edi-2] );
					add( insertSize, edi );
					sub( 2, edi );
					shr( 1, ecx );
					rep.movsw();
					jmp SpaceMade;


				do4:

					lea( esi, [edi-4] );
					add( insertSize, edi );
					sub( 4, edi );
					shr( 2, ecx );
					rep.movsd();
				
				SpaceMade:

			endif;

			// Okay, copy the data passed in toInsert into
			// the spot we've opened up:
			//
			// Three variants of the actual copy code,
			// based on the size of the object we're inserting:

			test( %11, insertSize );
			jz do4a;
			test( %1, insertSize );
			jz do2a;

				// Okay, copy the data passed in the toInsert
				// parameter into the location we've emptied up:

				cld();
				mov( insertSize, ecx );
				mov( toInsert, esi );
				mov( eax, edi );
				rep.movsb();
				jmp copyDone;

			do2a:
				// Do this if the object's size is a multiple of 2 bytes:

				cld();
				mov( insertSize, ecx );
				mov( toInsert, esi );
				shr( 1, ecx );
				mov( eax, edi );
				rep.movsw();
				jmp copyDone;


			do4a:
				// Okay, copy the data passed in the toInsert
				// parameter into the location we've emptied up:

				cld();
				mov( insertSize, ecx );
				mov( toInsert, esi );
				shr( 2, ecx );
				mov( eax, edi );
				rep.movsd();

			copyDone:
			pop( esi );

			// Update the endData pointer to reflect the new
			// array size:

			mov( insertSize, eax );
			add( eax, this.endData );
			add( eax, this.dataSize );

			// We're one element larger, so take that into
			// consideration:

			add( 1, this.numElements );
			
		end _insert;


		// _remove
		//	Helper routine that removes a vector element from a vector.
		//
		// Inputs:
		//
		//	removeWhere-
		//		Address of element to remove.
		//
		//	removeSize-
		//		Size of element to remove.

		procedure _vector._remove( removeWhere:dword; removeSize:dword );
		begin _remove;

			mov( removeWhere, eax );
			if( eax < this.endData ) then

				push( ecx );
				push( edi );
				push( esi );
				mov( this.endData, ecx );
				sub( eax, ecx );
				mov( eax, esi );
				add( removeSize, esi );
				mov( eax, edi );

				// Special cases for vectorTypes whoses sizes
				// are multiples of two or four bytes:

				mov( removeSize, eax );
				test( %11, eax );
				jz do4;
				test( %1, eax );
				jz do2;

					rep.movsb();
					jmp RemoveDone;


				do2:
					shr( 1, ecx );
					rep.movsw();
					jmp RemoveDone;

				do4:
					shr( 2, ecx );
					rep.movsd();

				RemoveDone:
				pop( esi );
				pop( edi );
				pop( ecx );
				sub( 1, this.numElements );
				sub( eax, this.dataSize );
				sub( eax, this.endData );

			endif;

		end _remove;

static
	vmt( _vector );



//////////////////////////////////////////////////////////////////////////////
//
// The vector type.
//
// This is a dynamic array (single dimension) whose size can change
// as needed at runtime.
//
//	Arguments:
//
//		vectorType-
//			data type for each element in the vector
//
//		specificCapabilities-
//			Enabled/disabled capabilities for this vector (used to alter
//			the default settings for a vector).
//
//
//	Produces:
//
//		Three different types:
//
//			vectorType-
//				a class for the specified vector type.
//
//			vectorType_cursor-
//				a type for cursors that point into the vectorType class.
//
//			p_vectorType-
//				a pointer to the vectorType class.
//
//		(Note: substitute the actual parameter name for "vectorType"
//		 in each of the above)
//
//	Publically accessible fields in the class created by this macro
//	(these fields should be treated as read-only):
// 
//		isSTL_c-
//			a constant, set to true, that you can use @define on to
//			determine that this type is an STL type.
//
//		capabilities_c	(compile-time)
//		capabilities	(run-time)
//			a bit-mapped array of booleans that specify the capabilities of
//			a vector object. Test for the presence of a capability by ANDing
//			with one of the *_c constants.
//
//      typeName-
//			a string holding the vectorType type name.
//
//      containerName-
//			the string "vector".
//
//
// procedures, methods, and iterators:
//
//      procedure create( numElements:uns32 );
//			Constructor for the vector class. If called with the class
//			name (e.g., symbol.create(n)) then it will create the object
//			on the heap and return a pointer to the new "symbol" object
//			in the ESI register. If called with an actual "symbol" variable,
//			this constructor initializes that variable.
//
//			Note: if the underlying vector type is a class type, this
//			constructor does *not* call the create procedure for each
//			of the underlying elements in the vector. That is the caller's
//			responsibility.
//
//      method destroy;
//			Destructor for the vector template class. Deallocates the storage
//			associated with the object.	Note that if the underlying elements
//			are a class type, this destructor does not call the destructor
//			for each of those elements. You must explicitly destroy them
//			prior to calling this destructor.
//
//		method getSize;
//			returns the number of vector elements in EAX. Operates in O(1) time.
//
//      method getAllocSize; @returns( "eax" );
//			Returns the number of bytes allocated for the data in the
//			vector (in EAX). Operates in O(1) time.
//
//      method getDataSize; @returns( "eax" );
//			Returns the number of bytes allocated for the data in actual
//			use in the vector. Operates in O(1) time.
//
//      method clear;
//			Removes all elements from the vector. Operates in O(1) time.
//
//      iterator forEachElement;
//			Iterates through the vector from beginning to end and on each
//			iteration returns a pointer to the current vector element in
//			the EAX register.
//
//      iterator rForEachElement;
//			As above, except it iterates through the vector from the end
//			back to the beginning.
//
//      method appendRef( var toAppend:vectorType );
//			Appends the object "toAppend" (passed by reference) to the end
//			of the vector. Operates in O(1) time.
//
//      method appendVal( toAppend:vectorType );
//			Appends the object "toAppend" (passed by value) to the end
//			of the vector. Operates in O(1) time.
//
//		method prependRef( var toPrepend:vectorType );
//			Inserts the object "toPrepend" at the beginning of the list.
//			toPrepend is passed by reference (great for large vectorType
//			objects). Operates in O(n) time.
//
//		method prependVal( toPrepend:vectorType );
//			Inserts the object "toPrepend" at the beginning of the list.
//			toPrepend is passed by value (great for smaller vectorType
//			objects). Operates in O(n) time.
//
//      method insertRef( var toInsert:vectorType; posn:uns32 );
//			Inserts the object "toInsert" in front the the posnTH object.
//			toInsert is passed by reference (great for large vectorType
//			objects). Operates in O(n) time.  Note that items are indexed
//			starting with position zero. If posn is greater than the
//			number of vector elements, this method appends the object
//			to the end of the vector.
//
//      method insertVal( toInsert:vectorType; posn:uns32 );
//			Inserts the object "toInsert" in front the the posnTH object.
//			toInsert is passed by value (great for small vectorType
//			objects). Operates in O(n) time.  Note that items are indexed
//			starting with position zero. If posn is greater than the
//			number of vector elements, this method appends the object
//			to the end of the vector.
//
//      method remove( n:uns32 );
//			Removes the object at posn "n" from the vector. If n is greater
//			than the number of vector elements, this method has no effect.
//			Operates in O(n) time.
//
//      method remove_first;
//			Removes the first element from the vector. 
//			Operates in O(n) time.
//
//      method remove_last;
//			Removes the last element from the vector. 
//			Operates in O(1) time.
//
//		Cursor methods:
//			Note: you should not assume that there is a correspondance
//			between cursors and pointers to vector elements. Though this
//			may be the actual implementation, subclassed vector types
//			may not guarantee this same implementation. Treat cursors as
//			opaque (private) types that are used internally by vector methods.
//
//      method nextCursor( var cursor:cursorType );
//			Modifies the cursor object passed by reference so that it
//			points at the next element of the vector (relative to where
//			it currently points). If this would advance the cursor beyond
//			the end of the vector, this method sets "cursor" to point at
//			just beyond the end of the vector (i.e., endCursor). Operates
//			in O(1) time.
//
//      method prevCursor( var cursor:cursorType );
//			Modifies the cursor object passed by reference so that it
//			points at the previous element of the vector (relative to where
//			it currently points). If this would advance the cursor before
//			the beginning of the vector, this method sets "cursor" to point at
//			the start of the vector (i.e., beginCursor). Operates in O(1)
//			time.
//
//      method beginCursor( var cursor:cursorType );
//			Points the cursor object passed by reference at the start of
//			the vector. Operates in O(1) time.
//
//      method endCursor( var cursor:cursorType );
//			Points the cursor object passed by reference to the point
//			just beyond the end of the vector. Operates in O(1) time.
//
//      method front; @returns( "eax" );
//			Returns a cursor value in EAX that corresponds to the start
//			of the vector. Operates in O(1) time.
//
//      method back; @returns( "eax" );
//			Returns a cursor value in EAX that corresponds to the end
//			of the vector (points beyond the end of the vector). Operates
//			in O(1) time.
//
//      method atBack( cursor:cursorType ); @returns( "@z" );
//			Compares the cursor passed by reference against the end of
//			the vector and sets the Z flag if the cursor is at the end
//			of the vector. Operates in O(1) time.
//
//      method atFront( cursor:cursorType ); @returns( "@z" );
//			Compares the cursor passed by reference against the beginning
//			of the vector and sets the Z flag if the cursor as at the
//			start of the vector. Operates in O(1) time.
//
//      method at( cursor:cursorType in eax ); @returns( "eax" );
//			Returns a pointer (in EAX) to the vector element data referenced by
//			the cursor passed by reference. You should use this method to
//			convert a cursor to a data element pointer and not assume that
//			cursors and data element pointers are equivalent. Operates in
//			O(1) time.
//
//      method getAt( cursor:cursorType; var dest:vectorType );
//			Copies the data at the vector element referenced by the cursor
//			you pass as the first argument to the location specified by
//			the second argument. Operates in O(1) time relative to n (the
//			number of vector elements).
//
//      method insertAtVal( toInsert:vectorType; cursor:cursorType );
//			Inserts the value "toInsert" before the item referenced by
//			the cursor passed as the second argument. Value (toInsert) is
//			passed by value, making this routine good for small vectorType
//			objects. Operates in O(n) time.
//
//      method insertAtRef( var toInsert:vectorType; cursor:cursorType );
//			Inserts the value "toInsert" before the item referenced by
//			the cursor passed as the second argument. Value (toInsert) is
//			passed by reference, making this routine good for large vectorType
//			objects. Operates in O(n) time.
//
//      method removeAt( cursor:cursorType );
//			Removes the vector entry referenced by the cursor passed
//			as the argument. Operates in O(n) time.
//
//      method getRef( n:uns32 in eax ); @returns( "eax" );
//			Computes and returns the address (in EAX) of the nTH element
//			in the vector. Operates in O(1) time.
//
//      method getVal( n:uns32; var dest:vectorType );
//			Copies the value in the nTH vector element to the location
//			specified by the second parameter.
//
//		method swapObj( var obj:symbol );
//			Swaps the current vector object (THIS) with the one specified
//			by the parameter. This routine operates in O(1) time and is
//			very fast.
//
//		method swapElements( var first:cursorType; second:cursorType );
//			Swaps two vector elements (not necessarily in the same vector).
//			Operates in O(1) time.
//
//      method isEqual
//      ( 
//      	var left:vectorType; 
//      	var right:vectorType 
//      );  @returns( "al" );
//
//			Compares two vectorType objects that are passed by reference
//			and returns AL=1 (and clears the Z flag) if they are equal.
//      
//      method isLess
//      ( 
//      	var left:vectorType; 
//      	var right:vectorType 
//      );  @returns( "al" );
//
//			Compares two vectorType objects that are passed by reference
//			and returns AL=1 (and clears the Z flag) if left < right.
//      
//      
//      method isLessEqual
//      ( 
//      	var left:vectorType; 
//      	var right:vectorType 
//      );  @returns( "al" );
//
//			Compares two vectorType objects that are passed by reference
//			and returns AL=1 (and clears the Z flag) if left <= right.
// 
//		Note: you can simulate <>, >, and >= by inverting the value in AL
//		upon return from the above three routines.     
//      
//      method a_toString; @external( outputFunc[0] );
//			(Optional implementation) Converts an object of type "symbol"
//			to a string for use by output routines like stdout.put.
//
//
// Note class _vector is a generic helper class for the vector template
// that is used to reduce the amount of code generated for multiple vector
// types.



#macro vector( rawVectorType, specificTraits[] ):
	symbol,
	vectorType,
	section,
	cursorType,
	ptrType,
	temp;

	forward( symbol );
		
	vectorType : rawVectorType;

	?section := @section;
	#if( (section & @global:hla.inType) <> @global:hla.inType )

		#error( "VECTOR declarations may only appear in a TYPE section" )

	#else

		// Create a cursor type for this class:

		?temp 			:string := @string( @text( symbol ) );
		?cursorType 	:string := temp + "_cursor";
		?cursorType		:text   := cursorType;
		cursorType		:pointer to vectorType;

		// Create a pointer type for this class:

		?ptrType 		:string := "p_" + temp;
		?ptrType		:text   := ptrType;
		ptrType			:pointer to symbol;

		// Create the actual class:

		symbol:
			class inherits( stl._vector );

				// Set up the default capabilities for a vector:

				val
					hierarchy_c := hierarchy_c | stl.isVector_c;

					capabilities_c := 
							capabilities_c 
							#if( @isClass( vectorType ))
								| stl.elementsAreObjects_c
							#endif

						|	stl.supportsAppend_c		
						|	stl.supportsPrepend_c		
						|	stl.supportsInsert_c		
						|	stl.supportsRemove_c		
						|	stl.supportsSwap_c			
						|	stl.supportsForeach_c			
						|	stl.supportsrForeach_c			
						|	stl.supportsCursor_c			
						|	stl.supportsElementSwap_c
						|	stl.supportsObjSwap_c;

						
					// Okay, process any specific capabilities provided in
					// the vector declaration:
					
					capabilities_c := 
						stl.parseCapabilities
						( 
							capabilities_c, 
							specificTraits 
						);


					// Set up the default performance traits:

					performance_c :=
							performance_c
							#if( @size( vectorType ) <= 16 )
								| stl.fastElementSwap_c
							#endif
						|	stl.fastAppend_c			
						|	stl.fastSwap_c;				

						
					// Okay, process any specific performance traits
					//  provided in the vector declaration:
					
					performance_c := 
						stl.parsePerformance
						( 
							performance_c, 
							specificTraits 
						);


					// Just as a safety net, let's verify that all
					// the user-specified traits are valid:

					stl.checkTraits
					( 
						specificTraits, 
						[[stl.performanceNames],[stl.capabilityNames]] 
					);


				readonly
					typeName_ro	:string := temp;


				// Public entities begin here:
				//
				// Constructor and destructor.
				// Note that all vector types have a constructor and destructor

				procedure create( numElements:uns32 );

				// Note: inherits destructor from arrayContainer class
				// method destroy;


				// iterators:

				#if( (symbol.capabilities_c & stl.supportsForeach_c) <> 0 )

					iterator forEachElement;

				#endif

				#if( (symbol.capabilities_c & stl.supportsrForeach_c) <> 0 )

					iterator rForEachElement;

				#endif

				// Element append, insert, and removal:

				#if( (symbol.capabilities_c & stl.supportsAppend_c) <> 0 )

					method appendRef( var toAppend:vectorType );
					method appendVal( toAppend:vectorType );

				#endif

				#if( (symbol.capabilities_c & stl.supportsPrepend_c) <> 0 )

					method prependRef( var toPrepend:vectorType );
					method prependVal( toPrepend:vectorType );

				#endif


				#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )
				
					method insertRef( var toInsert:vectorType; posn:uns32 );
					method insertVal( toInsert:vectorType; posn:uns32 );

				#endif


				#if( (symbol.capabilities_c & stl.supportsRemove_c) <> 0 )

					method remove( n:uns32 );
					method remove_first;
					method remove_last;

				#endif



				#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

					// Cursor manipulation routines:

					method nextCursor( var cursor:cursorType );
					method prevCursor( var cursor:cursorType );
					method beginCursor( var cursor:cursorType );
					method endCursor( var cursor:cursorType );
					method front; @returns( "eax" );
					method back; @returns( "eax" );

					method atBack( cursor:cursorType ); @returns( "@z" );
					method atFront( cursor:cursorType ); @returns( "@z" );
					method at( cursor:cursorType in eax ); @returns( "eax" );
					method atIndex( n:uns32 in eax ); @returns( "eax" );

					method getAt( cursor:cursorType; var dest:vectorType );

					#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )

						method insertAtVal
						( 
							toInsert:vectorType; 
							cursor:cursorType 
						);
						method insertAtRef
						( 
							var toInsert:vectorType; 
								cursor:cursorType 
						);

					#endif

					#if( (symbol.capabilities_c & stl.supportsRemove_c) <> 0 )

						method removeAt( cursor:cursorType );

					#endif

				#endif

				// Accessor methods:

				method getRef( n:uns32 in eax ); @returns( "eax" );
				method getVal( n:uns32; var dest:vectorType );
				 
				// Element & object swapping:

				#if( (symbol.capabilities_c & stl.supportsObjSwap_c) <> 0 )
		
					method swapObj( var obj:symbol );

				#endif

				#if( (symbol.capabilities_c & stl.supportsElementSwap_c) <> 0 )

					method swapElements
					( 
						first:cursorType; 
						second:cursorType 
					);

				#endif

				// Comparisons:
				
				#if( (capabilities_c & stl.supportsCompare_c) <> 0 )

					method isEqual
					( 
						var left:vectorType; 
						var right:vectorType 
					);  @returns( "al" );

					method isLess
					( 
						var left:vectorType; 
						var right:vectorType 
					);  @returns( "al" );


					method isLessEqual
					( 
						var left:vectorType; 
						var right:vectorType 
					);  @returns( "al" );

				#endif

								

				// Output method

				#if( (capabilities_c & stl.supportsOutput_c) <> 0 )

					override method a_toString;

				#endif


			endclass;

		// Emit the VMT for this class:

		static
			vmt( symbol );


		// Object constructor.
		// If called with ESI = 0 (class constructor call) then
		// this routine allocates storage for the object itself
		// and returns a pointer to that object in ESI. For all
		// objects, this code also allocates storage for a vector
		// with "numElements" entries.

		procedure symbol.create( numElements:uns32 );
			@nodisplay; @noalignstack;
		begin create;

			push( eax );
			xor( eax, eax );	// Init isAlloc to false.
			if( esi = 0 ) then
			
				mem.alloc( @size( @text( @string( @text( symbol )))));
				mov( eax, esi );
				mov( true, al );	// Set isAlloc true.
				
			endif;
			mov( al, this.isAlloc );

			// Initialize the VMT pointer:

			mov( &symbol._VMT_, this._pVMT_ );

			// Allocate storage for the vector and initialize
			// the array fields:

			this.createArray( numElements, @size( vectorType ));

			// Runtime information:
			// Begin by initializing the standard boolean variables with
			// their respective values for a vector.
			
			mov( symbol.capabilities_c, this.capabilities );
			mov( symbol.performance_c, this.performance );
			mov( symbol.hierarchy_c, this.hierarchy );			

			// Other vector specific-initialization:

			lea( eax, "vector" );
			mov( eax, this.containerName );

			mov( symbol.typeName_ro, eax );
			mov( eax, this.typeName );


			pop( eax );

		end create;



	#if( (symbol.capabilities_c & stl.supportsAppend_c) <> 0 )

		// appendRef-
		//	Appends a new element to the end of the array.
		//	The value passed as the argument is passed by reference.
		//	You should use this append function when the vector element
		//	type is large.

		method symbol.appendRef( var toAppend:vectorType );
			@nodisplay; @noalignstack;
		begin appendRef;

			// Begin by making sure we've got enough room in the
			// data array to hold the new object:

			pushfd();
			push( eax );
			push( ecx );
			push( edi );
			cld();

			this._append
			( 
				#{ push( toAppend ); }#, 
				@size( vectorType )
			);

			pop( edi );
			pop( ecx );
			pop( eax );
			popfd();

		end appendRef;



		// appendVal-
		//	Appends a new element to the end of the array.
		//	The value passed as the argument is passed by value.
		//	You should use this append function when the vector element
		//	type is small (typically 16 bytes or less).


		method symbol.appendVal( toAppend:vectorType );
			@nodisplay; @noalignstack;
		begin appendVal;

			// Begin by making sure we've got enough room in the
			// data array to hold the new object:

			pushfd();
			push( eax );
			push( ecx );
			push( edi );
			cld();

			this._append
			( 
				#{ 
					lea( eax, toAppend );
					push( eax ); 
				}#, 
				@size( vectorType )
			);

			pop( edi );
			pop( ecx );
			pop( eax );
			popfd();

		end appendVal;

	#endif



	#if( (symbol.capabilities_c & stl.supportsPrepend_c) <> 0 )


		// prependRef-
		//
		//	Inserts an array element (toInsert) at the beginning of
		//	the array.
		//
		//	prependRef passes toInsert by reference, so you should use this
		//	function to insert large objects into the array.

		method symbol.prependRef( var toPrepend:vectorType );
			@nodisplay; @noalignstack;
		begin prependRef;

			push( eax );
			push( ecx );
			pushfd();
			push( edi );

			this._insert
			(
				#{ push( toPrepend ); }#,
				this.data,
				@size( vectorType )
			);

			
			pop( edi );
			popfd();
			pop( ecx );
			pop( eax );

		end prependRef;



		// prependVal-
		//
		//	Inserts an array element (toInsert) at the beginning of
		//	the array. 
		//
		//	prependVal passes toInsert by value, so you should use this
		//	function to insert small objects into the array.


		method symbol.prependVal( toPrepend:vectorType );
			@nodisplay; @noalignstack;
		begin prependVal;

			push( eax );
			push( ecx );
			pushfd();
			push( edi );

			this._insert
			(
				#{ 
					lea( eax, toPrepend );
					push( eax ); 
				}#,
				this.data,
				@size( vectorType )
			);

			
			pop( edi );
			popfd();
			pop( ecx );
			pop( eax );

		end prependVal;

				
	#endif


				
	#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )
	

		// insertRef-
		//
		//	Inserts an array element (toInsert) at position posn within
		//	the array. If posn is beyond the end of the array, then this
		//	code appends the value to the end of the array.
		//
		//	insertRef passes toInsert by reference, so you should use this
		//	function to insert large objects into the array.

		method symbol.insertRef( var toInsert:vectorType; posn:uns32 );
			@nodisplay; @noalignstack;
		begin insertRef;

			push( eax );
			push( ecx );
			pushfd();
			push( edi );

			intmul( @size( vectorType ), posn, eax );
			add( this.data, eax );
			this._insert
			(
				#{ push( toInsert ); }#,
				eax,
				@size( vectorType )
			);

			
			pop( edi );
			popfd();
			pop( ecx );
			pop( eax );

		end insertRef;



		// insertVal-
		//
		//	Inserts an array element (toInsert) at position posn within
		//	the array. If posn is beyond the end of the array, then this
		//	code appends the value to the end of the array.
		//
		//	insertVal passes toInsert by value, so you should use this
		//	function to insert small objects into the array.


		method symbol.insertVal( toInsert:vectorType; posn:uns32 );
			@nodisplay; @noalignstack;
		begin insertVal;

			push( eax );
			push( ecx );
			pushfd();
			push( edi );

			this._insert
			(
				#{ 
					lea( eax, toInsert ); 
					push( eax );
				}#,
				#{
					intmul( @size( vectorType ), posn, eax );
					add( this.data, eax );
					push( eax );
				}#,
				@size( vectorType )
			);
			
			pop( edi );
			popfd();
			pop( ecx );
			pop( eax );

		end insertVal;


		#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

			// insertAtRef-
			//
			//	Inserts an array element just before the element specified
			//	by the cursor passed as the second argument.
			//
			//	insertAtRef passes toInsert by reference, so you should use this
			//	function to insert large objects into the array.

			method symbol.insertAtRef( var toInsert:vectorType; cursor:cursorType );
				@nodisplay; @noalignstack;
			begin insertAtRef;

				push( eax );
				push( ecx );
				pushfd();
				push( edi );

				this._insert
				(
					#{ push( toInsert ); }#,
					cursor,
					@size( vectorType )
				);

				
				pop( edi );
				popfd();
				pop( ecx );
				pop( eax );

			end insertAtRef;

			// insertAtVal-
			//
			//	Inserts an array element (toInsert) in front of the item
			//	specified by the cursor passed as the second argument.
			//
			//	insertAtVal passes toInsert by value, so you should use this
			//	function to insert small objects into the array.


			method symbol.insertAtVal( toInsert:vectorType; cursor:cursorType );
				@nodisplay; @noalignstack;
			begin insertAtVal;

				push( eax );
				push( ecx );
				pushfd();
				push( edi );

				this._insert
				(
					#{ 
						lea( eax, toInsert ); 
						push( eax );
					}#,
					cursor,
					@size( vectorType )
				);
				
				pop( edi );
				popfd();
				pop( ecx );
				pop( eax );

			end insertAtVal;

		#endif

	#endif


	#if( (symbol.capabilities_c & stl.supportsRemove_c) <> 0 )
	

		// remove-
		//	Removes the nTH item from the end of the array.
		//
		//	If n is greater than the number of items in the array,
		//	then this function has no effect. 

		method symbol.remove( n:uns32 );
			@nodisplay; @noalignstack;
		begin remove;

			push( eax );
			intmul( @size( vectorType ), n, eax );
			add( this.data, eax );
			this._remove( eax, @size( vectorType ));
			pop( eax );

		end remove;
		
		// remove_first-
		//	Removes the first item from a vector.
			

		method symbol.remove_first; @noframe;
		begin remove_first;

			push( eax );
			this._remove( this.data, @size( vectorType ));
			pop( eax );
			ret();

		end remove_first;


		// remove_last-
		//	Removes the last item from a vector.

		method symbol.remove_last; @noframe;
		begin remove_last;

			push( eax );
			mov( this.endData, eax );
			sub( @size( vectorType ), eax );
			if( eax > this.data ) then

				mov( eax, this.endData );
				sub( 1, this.numElements );

			endif;
			pop( eax );

		end remove_last;


		#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

			// removeAt-
			//	Removes the item appearing at the location specified
			//	by the cursor passed as a parameter.

			method symbol.removeAt( cursor:cursorType );
				@nodisplay; @noalignstack;
			begin removeAt;

				push( eax );
				mov( cursor, eax );
				this._remove( eax, @size( vectorType ));
				pop( eax );

			end removeAt;

		#endif

	#endif
	   

	#if( (symbol.capabilities_c & stl.supportsForeach_c) <> 0 )

		// The following iterators will sequence through
		// all the elements of the array. On each iteration
		// of the corresponding foreach loop, this iterator
		// will return the *address* of the respective vector
		// element.
		//
		// forEachElement returns items from the start to the end of the object
		// rForEachElement returns items from the end to the start.

		iterator symbol.forEachElement;
			@nodisplay; @noalignstack;
		begin forEachElement;

			push( eax );
			push( edx );
			mov( this.data, edx );
			while( edx < this.endData ) do

				push( esi );
				push( edx );
				mov( edx, eax );
				yield();
				pop( edx );
				pop( esi );
				add( @size( vectorType ), edx );

			endwhile;
			pop( edx );
			pop( eax );

		end forEachElement;


	#endif
	
	#if( (symbol.capabilities_c & stl.supportsrForeach_c) <> 0 )
					

		iterator symbol.rForEachElement;
			@nodisplay; @noalignstack;
		begin rForEachElement;

			push( eax );
			push( edx );
			mov( this.endData, edx );
			while( edx > this.data ) do

				sub( @size( vectorType ), edx );
				push( esi );
				push( edx );
				mov( edx, eax );
				yield();
				pop( edx );
				pop( esi );

			endwhile;
			pop( edx );
			pop( eax );

		end rForEachElement;
				
	#endif


	#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

		// nextCursor-
		//	Adjusts the cursor to point at the next element of the
		//	vector and returns this pointer in EAX. If this operation
		//	would cause the cursor to move beyond the end of the
		//	vector, then it just returns this.endData.

		method symbol.nextCursor( var cursor:cursorType ); @noframe;
		begin nextCursor;

			push( eax );
			mov( [esp+@offset( cursor )], eax );
			push( ebx );
			mov( [eax], ebx );
			add( @size( vectorType ), ebx );
			if( ebx > this.endData ) then

				mov( this.endData, ebx );

			endif;
			mov( ebx, [eax] );
			pop( ebx );
			pop( eax );
			ret( 4 );

		end nextCursor;

		// prevCursor-
		//	Adjust the cursor to point at the previous element in the vector.
		//	If doing this would position the cursor before the start of the
		//	array, then this just sets the cursor position to the start of
		//	the array.

		method symbol.prevCursor( var cursor:cursorType ); @noframe;
		begin prevCursor;

			push( eax );
			mov( [esp+@offset( cursor )], eax );
			push( ebx );
			mov( [eax], ebx );
			sub( @size( vectorType ), ebx );
			if( ebx < this.data ) then

				mov( this.data, ebx );

			endif;
			mov( ebx, [eax] );
			pop( ebx );
			pop( eax );
			ret( 4 );

		end prevCursor;



		// beginCursor-
		//	Puts a pointer to the start of the vector in cursor:

		method symbol.beginCursor( var cursor:cursorType ); @noframe;
		begin beginCursor;

			push( eax );
			mov( [esp+@offset( cursor )], eax );
			mov( this.data, [eax] );
			pop( eax );
			ret( 4 );

		end beginCursor;

		// endCursor-
		//	Puts a pointer to the end of the vector in cursor:

		method symbol.endCursor( var cursor:cursorType ); @noframe;
		begin endCursor;

			push( eax );
			mov( [esp+@offset( cursor )], eax );
			mov( this.endData, [eax] );
			pop( eax );
			ret( 4 );

		end endCursor;

		// at-
		//	Moves the address of the data element referenced by the
		// cursor passed as the argument into the EAX register.

		method symbol.at( cursor:cursorType in eax ); @noframe;
		begin at;

			// This is a trivial function, as cursors and pointers
			// to data elements are the same thing for vectors.

			ret();

		end at;




		// getAt-
		//	Copies the data item specified by the cursor to
		//	the variable specified by the second argument.
		//  If cursor is out of range, no action is taken.
													  
		method symbol.getAt( cursor:cursorType; var dest:vectorType );
			@nodisplay; @noalignstack;
		begin getAt;

			pushfd();
			push( edi );
			cld();
			mov( cursor, edi );
			if( edi < this.endData ) then

				push( esi );
				mov( edi, esi );
				mov( dest, edi );
				#if( @size( vectorType ) = 1 )

					movsb();

				#elseif( @size( vectorType ) = 2 )

					movsw();

				#elseif( @size( vectorType ) = 4 )

					movsd();

				#else

					push( ecx );
					#if( (@size( vectorType ) & %11) = 0 )

						mov( @size( vectorType ) div 4, ecx );
						rep.movsd();

					#elseif( (@size( vectorType ) & %01) = 0 )

						mov( @size( vectorType ) div 2, ecx );
						rep.movsw();

					#else

						mov( @size( vectorType ), ecx );
						rep.movsb();

					#endif
					pop( ecx );

				#endif
				pop( esi );
					
			endif;
			pop( edi );
			popfd();						

		end getAt;

		// front-
		//	Returns a cursor value that points at the first element
		// of the vector in EAX.

		method symbol.front; @noframe;
		begin front;

			mov( this.data, eax );
			ret();

		end front;


		// back-
		//	Returns a pointer to the first item *beyond* the end of
		//	the vector in EAX:

		method symbol.back; @noframe;
		begin back;

			mov( this.endData, eax );
			ret();

		end back;


		// atFront
		//	Compares the cursor passed as a parameter against the
		//	start of the vector and sets the zero flag if they
		//	are equal (that is, the cursor points at the start
		//	of the vector).

		method symbol.atFront( cursor:cursorType ); @noframe;
		begin atFront;

			push( eax );
			mov( [esp+@offset(cursor)], eax );
			cmp( eax, this.data );
			pop( eax );
			ret();

		end atFront;


		// atBack
		//	Compares the cursor passed as a parameter against the
		//	end of the vector and sets the zero flag if they
		//	are equal (that is, the cursor points just beyond the
		//	end of the vector).

		method symbol.atBack( cursor:cursorType ); @noframe;
		begin atBack;

			push( eax );
			mov( [esp+@offset(cursor)], eax );
			cmp( eax, this.endData );
			pop( eax );
			ret();

		end atBack;
		
		
		// atIndex -
		//	Returns a cursor (in EAX) that references the nTH element
		// in the vector. Returns endData if n is beyond the end of the
		// vector.
		
		method symbol.atIndex( n:uns32 in eax ); @noframe;
		begin atIndex;
		
			if( eax >= this.numElements ) then
			
				mov( this.endData, eax );
				
			else
			
				intmul( @size( vectorType ), eax );
				add( this.data, eax );
				
			endif;
			ret();
			
		end atIndex; 
		

	#endif




		// getRef-
		//	Computes the address of element n in the array
		//	and returns this value in EAX. If n exceeds the
		//	array bounds, then at returns the address of the
		//	end of the array.

		method symbol.getRef( n:uns32 in eax ); @noframe;
		begin getRef;

			intmul( @size( vectorType ), eax );
			add( this.data, eax );
			if( eax > this.endData ) then

				mov( this.endData, eax );

			endif;
			ret();

		end getRef;


		// getVal-
		//	Copies the nTH data item to the specified variable.
		//  If n is out of range, no action is taken.
													  
		method symbol.getVal( n:uns32; var dest:vectorType );
			@nodisplay; @noalignstack;
		begin getVal;

			pushfd();
			push( edi );
			cld();
			intmul( @size( vectorType ), n, edi );
			add( this.data, edi );
			if( edi < this.endData ) then

				push( esi );
				mov( edi, esi );
				mov( dest, edi );
				#if( @size( vectorType ) = 1 )

					movsb();

				#elseif( @size( vectorType ) = 2 )

					movsw();

				#elseif( @size( vectorType ) = 4 )

					movsd();

				#else

					push( ecx );
					#if( (@size( vectorType ) & %11) = 0 )

						mov( @size( vectorType ) div 4, ecx );
						rep.movsd();

					#elseif( (@size( vectorType ) & %01) = 0 )

						mov( @size( vectorType ) div 2, ecx );
						rep.movsw();

					#else

						mov( @size( vectorType ), ecx );
						rep.movsb();

					#endif
					pop( ecx );

				#endif
				pop( esi );
					
			endif;
			pop( edi );
			popfd();						

		end getVal;



		#if( (symbol.capabilities_c & stl.supportsObjSwap_c) <> 0 )

			// swapObj-
			//	Swaps another object with this one:

			method symbol.swapObj( var obj:symbol ); 
				@nodisplay; @nostackalign;

			const
				objEBX:text := "(type " + @string( symbol ) + " [ebx])";

			begin swapObj;


				push( eax );
				push( ebx );
				push( ecx );

				mov( obj, ebx );
				mov( this.isAlloc, al );
				mov( objEBX.isAlloc, ah );
				mov( al, objEBX.isAlloc );
				mov( ah, this.isAlloc );

				mov( this.typeName, ecx );
				mov( objEBX.typeName, eax );
				mov( ecx, objEBX.typeName );
				mov( eax, this.typeName );

				mov( this.numElements, ecx );
				mov( objEBX.numElements, eax );
				mov( ecx, objEBX.numElements );
				mov( eax, this.numElements );

				mov( this.dataSize, ecx );
				mov( objEBX.dataSize, eax );
				mov( ecx, objEBX.dataSize );
				mov( eax, this.dataSize );

				mov( this.allocSize, ecx );
				mov( objEBX.allocSize, eax );
				mov( ecx, objEBX.allocSize );
				mov( eax, this.allocSize );

				mov( this.data, ecx );
				mov( objEBX.data, eax );
				mov( ecx, objEBX.data );
				mov( eax, this.data );

				mov( this.endData, ecx );
				mov( objEBX.endData, eax );
				mov( ecx, objEBX.endData );
				mov( eax, this.endData );

				pop( ecx );
				pop( ebx );
				pop( eax );

			end swapObj;

		#endif

		#if( (symbol.capabilities_c & stl.supportsElementSwap_c) <> 0 )

			method symbol.swapElements
			( 
				first:cursorType; 
				second:cursorType 
			);
				@noframe;
				
			begin swapElements;
			
				push( ecx );
				push( esi );
				push( edi );
				
				#if( @size( vectorType ) = 1 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					mov( [esi], cl );
					mov( [edi], ch );
					mov( cl, [edi] );
					mov( ch, [esi] );
					 
				#elseif( @size( vectorType ) = 2 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], ax );
					mov( [edi], cx );
					mov( ax, [edi] );
					mov( cx, [esi] );
					pop( eax );
					
				#elseif( @size( vectorType ) = 4 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], eax );
					mov( [edi], ecx );
					mov( eax, [edi] );
					mov( ecx, [esi] );
					pop( eax );
					
				#elseif( @size( vectorType ) = 8 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], eax );
					mov( [edi], ecx );
					mov( eax, [edi] );
					mov( ecx, [esi] );
					mov( [esi+4], eax );
					mov( [edi+4], ecx );
					mov( eax, [edi+4] );
					mov( ecx, [esi+4] );
					pop( eax );
					
				#elseif( @size( vectorType ) = 16 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], eax );
					mov( [edi], ecx );
					mov( eax, [edi] );
					mov( ecx, [esi] );
					mov( [esi+4], eax );
					mov( [edi+4], ecx );
					mov( eax, [edi+4] );
					mov( ecx, [esi+4] );
					mov( [esi+8], eax );
					mov( [edi+8], ecx );
					mov( eax, [edi+8] );
					mov( ecx, [esi+8] );
					mov( [esi+12], eax );
					mov( [edi+12], ecx );
					mov( eax, [edi+12] );
					mov( ecx, [esi+12] );
					pop( eax );
					
				#elseif( (@size( vectorType ) & %11) = 0 )
				
					shr( 2, ecx );
					rep.movsd();
					
				#elseif( (@size( vectorType ) & %1) = 0 )
				
					shr( 1, ecx );
					rep.movsw();
					
				#else
				
					rep.movsb();
					
				#endif

					
				pop( edi );
				pop( esi );
				pop( ecx );
				ret( 8 );
				
			end swapElements;

		#endif


		// Comparisons-
		//	Handle the built-in types, but require the user to
		//	supply comparisons for other types.

		#if( (symbol.capabilities_c & stl.supportsCompare_c) <> 0 )

			stl.stdCompares( vectorType )

		#endif

				



		// Set us back to the TYPE section:

		type

	#endif

#endmacro




//////////////////////////////////////////////////////////////////////////////
//
// _deque
//	This is a special "helper" class for the deque template that moves a lot
//	of code common to all deque types into a single class in order to reduce
//	the size of the code base produced by expanding a deque template. No
//	program should actually declare variables of type _deque, this class is
//	for internal use only.

type
	_deque:
		class inherits( ArrayContainer );
		
			procedure _append( toAppend:dword; appendSize:dword );
			procedure _prepend( toPrepend:dword; prependSize:dword );
			procedure _insert
			( 
				toInsert:dword; 
				insertWhere:dword; 
				insertSize:dword 
			);

			procedure _remove( removeWhere:dword; removeSize:dword );
			

		endclass; 

		// _append-
		//	Appends a new element to the end of the deque.
		//
		// Inputs:
		//
		//	toAppend-
		//		Pointer to the data to append to the deque
		//
		//	appendSize-
		//		Size of the data object to append.

		procedure _deque._append( toAppend:dword; appendSize:dword );
			@nodisplay; @noalignstack;
			
		var
			thisSave:dword;

		readonly
			sixteenCases:dword[17] :=
				[
					&defaultCase,
					&case1,
					&case2,
					&defaultCase,
					&case4,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&case8,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&case16
				];
		begin _append;
		
			// Begin by making sure we've got enough room in the
			// data array to hold the new object:

			mov( this.dataSize, edi );
			add( appendSize, edi );
			add( this.data, edi );
			if( edi > this.endAllocData ) then

				// If the new element we're adding pushes us
				// beyond the end of the allocated storage,
				// reallocate by quadrupling the storage (we
				// quadruple the storage, rather than double it
				// as is done for vectors, so we can add the
				// some amount of storage before and after the
				// data block; as this is an append operation,
				// we'll favor the end of the block and add
				// more there).

				mov( this.allocSize, edi );
				lea( edi, [edi*4] );
				mov( esi, thisSave );
				mov( edi, this.allocSize );
				@global:mem.realloc2
				( 
					this.allocData, 
					edi,
					thunk
					#{
						// If a memcopy is done, we need to adjust all
						// the data pointers after the move.
						// Also note that we aren't going to move the
						// entire block, only the valid data (i.e., the
						// source value passed in ESI is irrelevant).
						
						mov( thisSave, esi );
						
						// Divide the amount of free space in quarters and
						// place the actual data starting at the second
						// quarter (so the data is in the middle of the
						// allocated block):
						
						mov( this.allocSize, eax );
						shr( 2, eax );
						add( eax, edi );		// True destination for move
						push( this.data );		// Save as data src for move.
						mov( edi, this.data );	// New data block pointer.
						
						// Mark the end of the data block:
						
						mov( this.dataSize, ecx );
						lea( eax, [edi+ecx] );
						mov( eax, this.endData );
						
						// Start of data to copy:
						
						pop( esi );
						
						// Okay, do the actual block move:
						
						test( %11, ecx );
						jz do4;
						test( %1, ecx );
						jz do2;
						
							rep.movsb();
							jmp moveDone;
							
						do2:
							shr( 1, ecx );
							rep.movsw();
							jmp moveDone;
							
						do4:
							shr( 2, ecx );
							rep.movsd();
							
						moveDone:						
						
					}# 
				);
				mov( eax, this.allocData );
				add( eax, edi );
				mov( edi, this.endAllocData );

			endif;

			// Special case out various small object sizes
			// for performance reasons.

			mov( appendSize, ecx );
			mov( this.data, edi );
			add( this.dataSize, edi );
			push( esi );
			mov( toAppend, esi );
			cld();
			cmp( ecx, 16 );
			ja defaultCase;
			jmp( sixteenCases[ ecx*4 ]);
			case1:
				movsb();
				jmp caseDone;

			case2:
				movsw();
				jmp caseDone;

			case4:
				movsd();
				jmp caseDone;

			case8:
				movsd();
				movsd();
				jmp caseDone;

			case16:
				movsd();
				movsd();
				movsd();
				movsd();
				jmp caseDone;

			defaultCase:
				rep.movsb();

			caseDone:
			pop( esi );
			mov( edi, this.endData );	// Maintain ptr to end of data.

			// Okay, bump up the element count by one:

			add( 1, this.numElements );
			mov( appendSize, eax );
			add(eax, this.dataSize );

		end _append;




		// _prepend-
		//	Prepends a new element to the front of the deque.
		//
		// Inputs:
		//
		//	toPrepend-
		//		Pointer to the data to prepend to the deque
		//
		//	prependSize-
		//		Size of the data object to prepend.

		procedure _deque._prepend( toPrepend:dword; prependSize:dword );
			@nodisplay; @noalignstack;
			
		var
			thisSave:dword;

		readonly
			sixteenCases:dword[17] :=
				[
					&defaultCase,
					&case1,
					&case2,
					&defaultCase,
					&case4,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&case8,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&defaultCase,
					&case16
				];
		begin _prepend;
		
			// Begin by making sure we've got enough room in the
			// data array to hold the new object:

			mov( this.data, edi );
			add( prependSize, edi );
			sub( this.allocData, edi );
			if( edi > this.data ) then

				// If the new element we're adding pushes us
				// before the beginning of the allocated storage,
				// reallocate by quadrupling the storage (we
				// quadruple the storage, rather than double it
				// as is done for vectors, so we can add the
				// some amount of storage before and after the
				// data block; as this is an prepend operation,
				// we'll favor the start of the block and add
				// more there).

				mov( this.allocSize, edi );
				lea( edi, [edi*4] );
				mov( esi, thisSave );
				mov( edi, this.allocSize );
				@global:mem.realloc2
				( 
					this.allocData, 
					edi,
					thunk
					#{
						// If a memcopy is done, we need to adjust all
						// the data pointers after the move.
						// Also note that we aren't going to move the
						// entire block, only the valid data (i.e., the
						// source value passed in ESI is irrelevant).
						
						mov( thisSave, esi );
						
						// Divide the amount of free space in quarters and
						// place the actual data starting at the third
						// quarter (so the data is in the middle of the
						// allocated block):
						
						mov( this.allocSize, eax );
						shr( 1, eax );			// Start of third quarter
						add( eax, edi );		// True destination for move
						push( this.data );		// Save as data src for move.
						mov( edi, this.data );	// New data block pointer.
						
						// Mark the end of the data block:
						
						mov( this.dataSize, ecx );
						lea( eax, [edi+ecx] );
						mov( eax, this.endData );
						
						// Start of data to copy:
						
						pop( esi );
						
						// Okay, do the actual block move:
						
						test( %11, ecx );
						jz do4;
						test( %1, ecx );
						jz do2;
						
							rep.movsb();
							jmp moveDone;
							
						do2:
							shr( 1, ecx );
							rep.movsw();
							jmp moveDone;
							
						do4:
							shr( 2, ecx );
							rep.movsd();
							
						moveDone:						
						
					}# 
				);
				mov( eax, this.allocData );
				add( eax, edi );
				mov( edi, this.endAllocData );

			endif;

			// Clean up the data pointers:
			
			mov( prependSize, ecx );
			add( ecx, this.dataSize );
			add( 1, this.numElements );
			
			mov( this.data, edi );
			sub( ecx, edi );
			mov( edi, this.data );
			
			mov( toPrepend, esi );

			// Special case out various small object sizes
			// for performance reasons.

			cld();
			cmp( ecx, 16 );
			ja defaultCase;
			jmp( sixteenCases[ ecx*4 ]);
			case1:
				movsb();
				jmp caseDone;

			case2:
				movsw();
				jmp caseDone;

			case4:
				movsd();
				jmp caseDone;

			case8:
				movsd();
				movsd();
				jmp caseDone;

			case16:
				movsd();
				movsd();
				movsd();
				movsd();
				jmp caseDone;

			defaultCase:
				rep.movsb();

			caseDone:

		end _prepend;



		// _insert-
		//	Inserts an arbitrary "deque" object into a deque.
		//
		//	Inputs:
		//
		//	toInsert-
		//		Pointer to deque element to insert into the list.
		//
		//	insertWhere-
		//		Pointer to the spot in the deque where the new element
		//		is to be inserted.
		//
		//	insertSize-
		//		Size of the object being inserted.

		procedure _deque._insert
		( 
			toInsert:dword; 
			insertWhere:dword; 
			insertSize:dword 
		);
		var
			thisSave:dword;
			
		begin _insert;

			push( esi );

			// Begin by making sure we've got enough room in the
			// data array to hold the new object:

			mov( this.dataSize, edi );
			add( insertSize, edi );
			add( this.data, edi );
			if( edi > this.endAllocData ) then

				// TODO: we could actually make this operation more
				// efficient by opening up room for the inserted object
				// if we do a data move during a reallocation. But for
				// simplicity's sake we'll skip that for now.
				//
				//
				// If the new element we're adding pushes us
				// beyond the end of the allocated storage,
				// reallocate by quadrupling the storage (we
				// quadruple the storage, rather than double it
				// as is done for vectors, so we can add the
				// some amount of storage before and after the
				// data block; as this is an insert operation,
				// we'll favor the end of the block and add
				// more there).

				mov( this.allocSize, edi );
				lea( edi, [edi*4] );
				mov( esi, thisSave );
				mov( edi, this.allocSize );
				@global:mem.realloc2
				( 
					this.allocData, 
					edi,
					thunk
					#{
						// If a memcopy is done, we need to adjust all
						// the data pointers after the move.
						// Also note that we aren't going to move the
						// entire block, only the valid data (i.e., the
						// source value passed in ESI is irrelevant).
						
						mov( thisSave, esi );
						
						// Divide the amount of free space in quarters and
						// place the actual data starting at the second
						// quarter. This leaves a larger block of free space
						// at the end, which is good because we're inserting
						// data here.
						
						mov( this.allocSize, eax );
						shr( 2, eax );
						add( eax, edi );		// True destination for move
						mov( this.data, eax );	// Save as data src for move.
						push( eax );
						mov( edi, this.data );	// New data block pointer.
						
						// Fix the "insertWhere" parameter, as it's now
						// pointing at the wrong block:
						
						sub( insertWhere, eax );
						neg( eax );				// Really need iw-data
						add( edi, eax );		// New insertWhere value
						mov( eax, insertWhere );
						
						// Mark the end of the data block:
						
						mov( this.dataSize, ecx );
						lea( eax, [edi+ecx] );
						mov( eax, this.endData );
						
						// Start of data to copy:
						
						pop( esi );
						
						// Okay, do the actual block move:
						
						test( %11, ecx );
						jz do4;
						test( %1, ecx );
						jz do2;
						
							rep.movsb();
							jmp moveDone;
							
						do2:
							shr( 1, ecx );
							rep.movsw();
							jmp moveDone;
							
						do4:
							shr( 2, ecx );
							rep.movsd();
							
						moveDone:						
						
					}# 
				);
				mov( eax, this.allocData );
				add( eax, edi );
				mov( edi, this.endAllocData );

			endif;


			// Okay, make room for the item we're going to insert:

			mov( insertWhere, eax );
			if( eax >= this.endData ) then

				mov( this.endData, eax );

			else

				// If we are inserting data at some point other than
				// at the end of the array, then we've got to move
				// everything along by one position to open up space
				// for the new element:

				std();
				mov( this.endData, edi );
				mov( edi, ecx );
				sub( eax, ecx );

				// Three variants of the actual insertion code,
				// based on the size of the object we're inserting:

				test( %11, insertSize );
				jz do4a;
				test( %1, insertSize );
				jz do2a;

					lea( esi, [edi-1] );
					add( insertSize, edi );
					sub( 1, edi );
					rep.movsb();
					jmp SpaceMade;

				do2a:
					// Do this if the object's size is a multiple of 2 bytes:

					lea( esi, [edi-2] );
					add( insertSize, edi );
					sub( 2, edi );
					shr( 1, ecx );
					rep.movsw();
					jmp SpaceMade;


				do4a:

					lea( esi, [edi-4] );
					add( insertSize, edi );
					sub( 4, edi );
					shr( 2, ecx );
					rep.movsd();
				
				SpaceMade:

			endif;

			// Okay, copy the data passed in toInsert into
			// the spot we've opened up:
			//
			// Three variants of the actual copy code,
			// based on the size of the object we're inserting:

			test( %11, insertSize );
			jz do4b;
			test( %1, insertSize );
			jz do2b;

				// Okay, copy the data passed in the toInsert
				// parameter into the location we've emptied up:

				cld();
				mov( insertSize, ecx );
				mov( toInsert, esi );
				mov( eax, edi );
				rep.movsb();
				jmp copyDone;

			do2b:
				// Do this if the object's size is a multiple of 2 bytes:

				cld();
				mov( insertSize, ecx );
				mov( toInsert, esi );
				shr( 1, ecx );
				mov( eax, edi );
				rep.movsw();
				jmp copyDone;


			do4b:
				// Okay, copy the data passed in the toInsert
				// parameter into the location we've emptied up:

				cld();
				mov( insertSize, ecx );
				mov( toInsert, esi );
				shr( 2, ecx );
				mov( eax, edi );
				rep.movsd();

			copyDone:
			pop( esi );

			// Update the endData pointer to reflect the new
			// array size:

			mov( insertSize, eax );
			add( eax, this.endData );
			add( eax, this.dataSize );

			// We're one element larger, so take that into
			// consideration:

			add( 1, this.numElements );
			
		end _insert;


		// _remove
		//	Helper routine that removes a deque element from a deque.
		//
		// Inputs:
		//
		//	removeWhere-
		//		Address of element to remove.
		//
		//	removeSize-
		//		Size of element to remove.

		procedure _deque._remove( removeWhere:dword; removeSize:dword );
		begin _remove;

			mov( removeWhere, eax );
			if( eax < this.endData ) then

				push( ecx );
				push( edi );
				push( esi );
				mov( this.endData, ecx );
				sub( eax, ecx );
				mov( eax, esi );
				add( removeSize, esi );
				mov( eax, edi );

				// Special cases for dequeTypes whoses sizes
				// are multiples of two or four bytes:

				mov( removeSize, eax );
				test( %11, eax );
				jz do4;
				test( %1, eax );
				jz do2;

					rep.movsb();
					jmp RemoveDone;


				do2:
					shr( 1, ecx );
					rep.movsw();
					jmp RemoveDone;

				do4:
					shr( 2, ecx );
					rep.movsd();

				RemoveDone:
				pop( esi );
				pop( edi );
				pop( ecx );
				sub( 1, this.numElements );
				sub( eax, this.dataSize );
				sub( eax, this.endData );

			endif;

		end _remove;



static
	vmt( _deque );




/////////////////////////////////////////////////////////////////////////////
//
// deque-
//	Double-ended queue class template
//




#macro deque( rawDequeType, specificTraits[] ):
	symbol,
	dequeType,
	section,
	cursorType,
	ptrType,
	temp;

	@forward( symbol );
	dequeType : rawDequeType;

	?section := @section;
	#if( (section & @global:hla.inType) <> @global:hla.inType )

		#error( "DEQUE declarations may only appear in a TYPE section" )

	#else

		// Create a cursor type for this class:

		?temp 			:string := @string( @text( symbol ) );
		?cursorType 	:string := temp + "_cursor";
		?cursorType		:text   := cursorType;
		cursorType		:pointer to dequeType;

		// Create a pointer type for this class:

		?ptrType 		:string := "p_" + temp;
		?ptrType		:text   := ptrType;
		ptrType			:pointer to symbol;

		// Create the actual class:

		symbol:
			class inherits( stl._deque );

				// Set up the default capabilities for a deque:

				val
					hierarchy_c := hierarchy_c | stl.isDeque_c;

					capabilities_c := 
							capabilities_c 
							#if( @isClass( dequeType ))
								| stl.elementsAreObjects_c
							#endif

						|	stl.supportsAppend_c		
						|	stl.supportsPrepend_c		
						|	stl.supportsInsert_c		
						|	stl.supportsRemove_c		
						|	stl.supportsSwap_c			
						|	stl.supportsForeach_c			
						|	stl.supportsrForeach_c			
						|	stl.supportsCursor_c			
						|	stl.supportsElementSwap_c
						|	stl.supportsObjSwap_c;

						
					// Okay, process any specific capabilities provided in
					// the deque declaration:
					
					capabilities_c := 
						stl.parseCapabilities
						( 
							capabilities_c, 
							specificTraits 
						);


					// Set up the default performance traits:

					performance_c :=
							performance_c
							#if( @size( dequeType ) <= 16 )
								| stl.fastElementSwap_c
							#endif
						|	stl.fastAppend_c
						|	stl.fastPrepend_c			
						|	stl.fastSwap_c;				

						
					// Okay, process any specific performance traits
					//  provided in the deque declaration:
					
					performance_c := 
						stl.parsePerformance
						( 
							performance_c, 
							specificTraits 
						);


					// Just as a safety net, let's verify that all
					// the user-specified traits are valid:

					stl.checkTraits
					( 
						specificTraits, 
						[[stl.performanceNames],[stl.capabilityNames]] 
					);


				readonly
					typeName_ro	:string := temp;


				// Public entities begin here:
				//
				// Constructor and destructor.
				// Note that all deque types have a constructor and destructor

				procedure create( numElements:uns32 );

				// Note: inherits destructor from arrayContainer class
				// method destroy;


				// iterators:

				#if( (symbol.capabilities_c & stl.supportsForeach_c) <> 0 )

					iterator forEachElement;

				#endif

				#if( (symbol.capabilities_c & stl.supportsrForeach_c) <> 0 )

					iterator rForEachElement;

				#endif

				// Element append, insert, and removal:

				#if( (symbol.capabilities_c & stl.supportsAppend_c) <> 0 )

					method appendRef( var toAppend:dequeType );
					method appendVal( toAppend:dequeType );

				#endif

				#if( (symbol.capabilities_c & stl.supportsPrepend_c) <> 0 )

					method prependRef( var toPrepend:dequeType );
					method prependVal( toPrepend:dequeType );

				#endif


				#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )
				
					method insertRef( var toInsert:dequeType; posn:uns32 );
					method insertVal( toInsert:dequeType; posn:uns32 );

				#endif


				#if( (symbol.capabilities_c & stl.supportsRemove_c) <> 0 )

					method remove( n:uns32 );
					method remove_first;
					method remove_last;

				#endif



				#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

					// Cursor manipulation routines:

					method nextCursor( var cursor:cursorType );
					method prevCursor( var cursor:cursorType );
					method beginCursor( var cursor:cursorType );
					method endCursor( var cursor:cursorType );
					method front; @returns( "eax" );
					method back; @returns( "eax" );

					method atBack( cursor:cursorType ); @returns( "@z" );
					method atFront( cursor:cursorType ); @returns( "@z" );
					method at( cursor:cursorType in eax ); @returns( "eax" );
					method atIndex( n:uns32 in eax ); @returns( "eax" );

					method getAt( cursor:cursorType; var dest:dequeType );

					#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )

						method insertAtVal
						( 
							toInsert:dequeType; 
							cursor:cursorType 
						);
						method insertAtRef
						( 
							var toInsert:dequeType; 
								cursor:cursorType 
						);

					#endif

					#if( (symbol.capabilities_c & stl.supportsRemove_c) <> 0 )

						method removeAt( cursor:cursorType );

					#endif

				#endif

				// Accessor methods:

				method getRef( n:uns32 in eax ); @returns( "eax" );
				method getVal( n:uns32; var dest:dequeType );
				 
				// Element & object swapping:

				#if( (symbol.capabilities_c & stl.supportsObjSwap_c) <> 0 )
		
					method swapObj( var obj:symbol );

				#endif

				#if( (symbol.capabilities_c & stl.supportsElementSwap_c) <> 0 )

					method swapElements
					( 
						first:cursorType; 
						second:cursorType 
					);

				#endif

				// Comparisons:
				
				#if( (capabilities_c & stl.supportsCompare_c) <> 0 )

					method isEqual
					( 
						var left:dequeType; 
						var right:dequeType 
					);  @returns( "al" );

					method isLess
					( 
						var left:dequeType; 
						var right:dequeType 
					);  @returns( "al" );


					method isLessEqual
					( 
						var left:dequeType; 
						var right:dequeType 
					);  @returns( "al" );

				#endif

								

				// Output method

				#if( (capabilities_c & stl.supportsOutput_c) <> 0 )

					override method a_toString;

				#endif


			endclass;

		// Emit the VMT for this class:

		static
			vmt( symbol );


		// Object constructor.
		// If called with ESI = 0 (class constructor call) then
		// this routine allocates storage for the object itself
		// and returns a pointer to that object in ESI. For all
		// objects, this code also allocates storage for a deque
		// with "numElements" entries.

		procedure symbol.create( numElements:uns32 );
			@nodisplay; @noalignstack;
		begin create;

			push( eax );
			xor( eax, eax );	// Init isAlloc to false.
			if( esi = 0 ) then
			
				mem.alloc( @size( @text( @string( @text( symbol )))));
				mov( eax, esi );
				mov( true, al );	// Set isAlloc true.
				
			endif;
			mov( al, this.isAlloc );

			// Initialize the VMT pointer:

			mov( &symbol._VMT_, this._pVMT_ );

			// Allocate storage for the deque and initialize
			// the array fields. Note that we are going to cheat
			// and actually allocate twice as many elements as
			// the user called for, so we can grow the specified
			// number of elements in *either* direction (prepend or
			// append).
			
			mov( numElements, eax );
			shl( 1, eax );
			this.createArray( eax, @size( dequeType ));

			// Position the start of the deque in the middle of the
			// allocated storage so we can efficiently grow in both
			// directions.

			mov( numElements, eax );
			intmul( @size( dequeType ), eax );
			add( this.data, eax );
			mov( eax, this.data );
			mov( eax, this.endData );

			// Runtime information:
			// Begin by initializing the standard boolean variables with
			// their respective values for a deque.
			
			mov( symbol.capabilities_c, this.capabilities );
			mov( symbol.performance_c, this.performance );
			mov( symbol.hierarchy_c, this.hierarchy );			

			// Other deque specific-initialization:

			lea( eax, "deque" );
			mov( eax, this.containerName );

			mov( symbol.typeName_ro, eax );
			mov( eax, this.typeName );


			pop( eax );

		end create;



	#if( (symbol.capabilities_c & stl.supportsAppend_c) <> 0 )

		// appendRef-
		//	Appends a new element to the end of the array.
		//	The value passed as the argument is passed by reference.
		//	You should use this append function when the deque element
		//	type is large.

		method symbol.appendRef( var toAppend:dequeType );
			@nodisplay; @noalignstack;
		begin appendRef;

			// Begin by making sure we've got enough room in the
			// data array to hold the new object:

			pushfd();
			push( eax );
			push( ecx );
			push( edi );
			cld();

			this._append
			( 
				#{ push( toAppend ); }#, 
				@size( dequeType )
			);

			pop( edi );
			pop( ecx );
			pop( eax );
			popfd();

		end appendRef;



		// appendVal-
		//	Appends a new element to the end of the array.
		//	The value passed as the argument is passed by value.
		//	You should use this append function when the deque element
		//	type is small (typically 16 bytes or less).


		method symbol.appendVal( toAppend:dequeType );
			@nodisplay; @noalignstack;
		begin appendVal;

			// Begin by making sure we've got enough room in the
			// data array to hold the new object:

			pushfd();
			push( eax );
			push( ecx );
			push( edi );
			cld();

			this._append
			( 
				#{ 
					lea( eax, toAppend );
					push( eax ); 
				}#, 
				@size( dequeType )
			);

			pop( edi );
			pop( ecx );
			pop( eax );
			popfd();

		end appendVal;

	#endif



	#if( (symbol.capabilities_c & stl.supportsPrepend_c) <> 0 )


		// prependRef-
		//
		//	Inserts an array element (toInsert) at the beginning of
		//	the array.
		//
		//	prependRef passes toInsert by reference, so you should use this
		//	function to insert large objects into the array.

		method symbol.prependRef( var toPrepend:dequeType );
			@nodisplay; @noalignstack;
		begin prependRef;

			push( eax );
			push( ecx );
			pushfd();
			push( edi );

			this._prepend
			(
				#{ push( toPrepend ); }#,
				@size( dequeType )
			);

			
			pop( edi );
			popfd();
			pop( ecx );
			pop( eax );

		end prependRef;



		// prependVal-
		//
		//	Inserts an array element (toInsert) at the beginning of
		//	the array. 
		//
		//	prependVal passes toInsert by value, so you should use this
		//	function to insert small objects into the array.


		method symbol.prependVal( toPrepend:dequeType );
			@nodisplay; @noalignstack;
		begin prependVal;

			push( eax );
			push( ecx );
			pushfd();
			push( edi );

			this._prepend
			(
				#{ 
					lea( eax, toPrepend );
					push( eax ); 
				}#,
				@size( dequeType )
			);

			
			pop( edi );
			popfd();
			pop( ecx );
			pop( eax );

		end prependVal;

				
	#endif


				
	#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )
	

		// insertRef-
		//
		//	Inserts an array element (toInsert) at position posn within
		//	the array. If posn is beyond the end of the array, then this
		//	code appends the value to the end of the array.
		//
		//	insertRef passes toInsert by reference, so you should use this
		//	function to insert large objects into the array.

		method symbol.insertRef( var toInsert:dequeType; posn:uns32 );
			@nodisplay; @noalignstack;
		begin insertRef;

			push( eax );
			push( ecx );
			pushfd();
			push( edi );

			intmul( @size( dequeType ), posn, eax );
			add( this.data, eax );
			this._insert
			(
				#{ push( toInsert ); }#,
				eax,
				@size( dequeType )
			);

			
			pop( edi );
			popfd();
			pop( ecx );
			pop( eax );

		end insertRef;



		// insertVal-
		//
		//	Inserts an array element (toInsert) at position posn within
		//	the array. If posn is beyond the end of the array, then this
		//	code appends the value to the end of the array.
		//
		//	insertVal passes toInsert by value, so you should use this
		//	function to insert small objects into the array.


		method symbol.insertVal( toInsert:dequeType; posn:uns32 );
			@nodisplay; @noalignstack;
		begin insertVal;

			push( eax );
			push( ecx );
			pushfd();
			push( edi );

			this._insert
			(
				#{ 
					lea( eax, toInsert ); 
					push( eax );
				}#,
				#{
					intmul( @size( dequeType ), posn, eax );
					add( this.data, eax );
					push( eax );
				}#,
				@size( dequeType )
			);
			
			pop( edi );
			popfd();
			pop( ecx );
			pop( eax );

		end insertVal;


		#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

			// insertAtRef-
			//
			//	Inserts an array element just before the element specified
			//	by the cursor passed as the second argument.
			//
			//	insertAtRef passes toInsert by reference, so you should use this
			//	function to insert large objects into the array.

			method symbol.insertAtRef( var toInsert:dequeType; cursor:cursorType );
				@nodisplay; @noalignstack;
			begin insertAtRef;

				push( eax );
				push( ecx );
				pushfd();
				push( edi );

				this._insert
				(
					#{ push( toInsert ); }#,
					cursor,
					@size( dequeType )
				);

				
				pop( edi );
				popfd();
				pop( ecx );
				pop( eax );

			end insertAtRef;

			// insertAtVal-
			//
			//	Inserts an array element (toInsert) in front of the item
			//	specified by the cursor passed as the second argument.
			//
			//	insertAtVal passes toInsert by value, so you should use this
			//	function to insert small objects into the array.


			method symbol.insertAtVal( toInsert:dequeType; cursor:cursorType );
				@nodisplay; @noalignstack;
			begin insertAtVal;

				push( eax );
				push( ecx );
				pushfd();
				push( edi );

				this._insert
				(
					#{ 
						lea( eax, toInsert ); 
						push( eax );
					}#,
					cursor,
					@size( dequeType )
				);
				
				pop( edi );
				popfd();
				pop( ecx );
				pop( eax );

			end insertAtVal;

		#endif

	#endif


	#if( (symbol.capabilities_c & stl.supportsRemove_c) <> 0 )
	

		// remove-
		//	Removes the nTH item from the end of the array.
		//
		//	If n is greater than the number of items in the array,
		//	then this function has no effect. 

		method symbol.remove( n:uns32 );
			@nodisplay; @noalignstack;
		begin remove;

			push( eax );
			intmul( @size( dequeType ), n, eax );
			add( this.data, eax );
			this._remove( eax, @size( dequeType ));
			pop( eax );

		end remove;
		
		// remove_first-
		//	Removes the first item from a deque.
			

		method symbol.remove_first; @noframe;
		begin remove_first;

			push( eax );
			this._remove( this.data, @size( dequeType ));
			pop( eax );
			ret();

		end remove_first;


		// remove_last-
		//	Removes the last item from a deque.

		method symbol.remove_last; @noframe;
		begin remove_last;

			push( eax );
			mov( this.endData, eax );
			sub( @size( dequeType ), eax );
			if( eax > this.data ) then

				mov( eax, this.endData );
				sub( 1, this.numElements );

			endif;
			pop( eax );

		end remove_last;


		#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

			// removeAt-
			//	Removes the item appearing at the location specified
			//	by the cursor passed as a parameter.

			method symbol.removeAt( cursor:cursorType );
				@nodisplay; @noalignstack;
			begin removeAt;

				push( eax );
				mov( cursor, eax );
				this._remove( eax, @size( dequeType ));
				pop( eax );

			end removeAt;

		#endif

	#endif
	   

	#if( (symbol.capabilities_c & stl.supportsForeach_c) <> 0 )

		// The following iterators will sequence through
		// all the elements of the array. On each iteration
		// of the corresponding foreach loop, this iterator
		// will return the *address* of the respective deque
		// element.
		//
		// forEachElement returns items from the start to the end of the object
		// rForEachElement returns items from the end to the start.

		iterator symbol.forEachElement;
			@nodisplay; @noalignstack;
		begin forEachElement;

			push( eax );
			push( edx );
			mov( this.data, edx );
			while( edx < this.endData ) do

				push( esi );
				push( edx );
				mov( edx, eax );
				yield();
				pop( edx );
				pop( esi );
				add( @size( dequeType ), edx );

			endwhile;
			pop( edx );
			pop( eax );

		end forEachElement;


	#endif
	
	#if( (symbol.capabilities_c & stl.supportsrForeach_c) <> 0 )
					

		iterator symbol.rForEachElement;
			@nodisplay; @noalignstack;
		begin rForEachElement;

			push( eax );
			push( edx );
			mov( this.endData, edx );
			while( edx > this.data ) do

				sub( @size( dequeType ), edx );
				push( esi );
				push( edx );
				mov( edx, eax );
				yield();
				pop( edx );
				pop( esi );

			endwhile;
			pop( edx );
			pop( eax );

		end rForEachElement;
				
	#endif


	#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

		// nextCursor-
		//	Adjusts the cursor to point at the next element of the
		//	deque and returns this pointer in EAX. If this operation
		//	would cause the cursor to move beyond the end of the
		//	deque, then it just returns this.endData.

		method symbol.nextCursor( var cursor:cursorType ); @noframe;
		begin nextCursor;

			push( eax );
			mov( [esp+@offset( cursor )], eax );
			push( ebx );
			mov( [eax], ebx );
			add( @size( dequeType ), ebx );
			if( ebx > this.endData ) then

				mov( this.endData, ebx );

			endif;
			mov( ebx, [eax] );
			pop( ebx );
			pop( eax );
			ret( 4 );

		end nextCursor;

		// prevCursor-
		//	Adjust the cursor to point at the previous element in the deque.
		//	If doing this would position the cursor before the start of the
		//	array, then this just sets the cursor position to the start of
		//	the array.

		method symbol.prevCursor( var cursor:cursorType ); @noframe;
		begin prevCursor;

			push( eax );
			mov( [esp+@offset( cursor )], eax );
			push( ebx );
			mov( [eax], ebx );
			sub( @size( dequeType ), ebx );
			if( ebx < this.data ) then

				mov( this.data, ebx );

			endif;
			mov( ebx, [eax] );
			pop( ebx );
			pop( eax );
			ret( 4 );

		end prevCursor;



		// beginCursor-
		//	Puts a pointer to the start of the deque in cursor:

		method symbol.beginCursor( var cursor:cursorType ); @noframe;
		begin beginCursor;

			push( eax );
			mov( [esp+@offset( cursor )], eax );
			mov( this.data, [eax] );
			pop( eax );
			ret( 4 );

		end beginCursor;

		// endCursor-
		//	Puts a pointer to the end of the deque in cursor:

		method symbol.endCursor( var cursor:cursorType ); @noframe;
		begin endCursor;

			push( eax );
			mov( [esp+@offset( cursor )], eax );
			mov( this.endData, [eax] );
			pop( eax );
			ret( 4 );

		end endCursor;

		// at-
		//	Moves the address of the data element referenced by the
		// cursor passed as the argument into the EAX register.

		method symbol.at( cursor:cursorType in eax ); @noframe;
		begin at;

			// This is a trivial function, as cursors and pointers
			// to data elements are the same thing for deques.

			ret();

		end at;




		// getAt-
		//	Copies the data item specified by the cursor to
		//	the variable specified by the second argument.
		//  If cursor is out of range, no action is taken.
													  
		method symbol.getAt( cursor:cursorType; var dest:dequeType );
			@nodisplay; @noalignstack;
		begin getAt;

			pushfd();
			push( edi );
			cld();
			mov( cursor, edi );
			if( edi < this.endData ) then

				push( esi );
				mov( edi, esi );
				mov( dest, edi );
				#if( @size( dequeType ) = 1 )

					movsb();

				#elseif( @size( dequeType ) = 2 )

					movsw();

				#elseif( @size( dequeType ) = 4 )

					movsd();

				#else

					push( ecx );
					#if( (@size( dequeType ) & %11) = 0 )

						mov( @size( dequeType ) div 4, ecx );
						rep.movsd();

					#elseif( (@size( dequeType ) & %01) = 0 )

						mov( @size( dequeType ) div 2, ecx );
						rep.movsw();

					#else

						mov( @size( dequeType ), ecx );
						rep.movsb();

					#endif
					pop( ecx );

				#endif
				pop( esi );
					
			endif;
			pop( edi );
			popfd();						

		end getAt;

		// front-
		//	Returns a cursor value that points at the first element
		// of the deque in EAX.

		method symbol.front; @noframe;
		begin front;

			mov( this.data, eax );
			ret();

		end front;


		// back-
		//	Returns a pointer to the first item *beyond* the end of
		//	the deque in EAX:

		method symbol.back; @noframe;
		begin back;

			mov( this.endData, eax );
			ret();

		end back;


		// atFront
		//	Compares the cursor passed as a parameter against the
		//	start of the deque and sets the zero flag if they
		//	are equal (that is, the cursor points at the start
		//	of the deque).

		method symbol.atFront( cursor:cursorType ); @noframe;
		begin atFront;

			push( eax );
			mov( [esp+@offset(cursor)], eax );
			cmp( eax, this.data );
			pop( eax );
			ret();

		end atFront;


		// atBack
		//	Compares the cursor passed as a parameter against the
		//	end of the deque and sets the zero flag if they
		//	are equal (that is, the cursor points just beyond the
		//	end of the deque).

		method symbol.atBack( cursor:cursorType ); @noframe;
		begin atBack;

			push( eax );
			mov( [esp+@offset(cursor)], eax );
			cmp( eax, this.endData );
			pop( eax );
			ret();

		end atBack;
		
		
		
		// atIndex -
		//	Returns a cursor (in EAX) that references the nTH element
		// in the deque. Returns endData if n is beyond the end of the
		// deque.
		
		method symbol.atIndex( n:uns32 in eax ); @noframe;
		begin atIndex;
		
			if( eax >= this.numElements ) then
			
				mov( this.endData, eax );
				
			else
			
				intmul( @size( dequeType ), eax );
				add( this.data, eax );
				
			endif;
			ret();
			
		end atIndex; 
		

	#endif




		// getRef-
		//	Computes the address of element n in the array
		//	and returns this value in EAX. If n exceeds the
		//	array bounds, then at returns the address of the
		//	end of the array.

		method symbol.getRef( n:uns32 in eax ); @noframe;
		begin getRef;

			intmul( @size( dequeType ), eax );
			add( this.data, eax );
			if( eax > this.endData ) then

				mov( this.endData, eax );

			endif;
			ret();

		end getRef;


		// getVal-
		//	Copies the nTH data item to the specified variable.
		//  If n is out of range, no action is taken.
													  
		method symbol.getVal( n:uns32; var dest:dequeType );
			@nodisplay; @noalignstack;
		begin getVal;

			pushfd();
			push( edi );
			cld();
			intmul( @size( dequeType ), n, edi );
			add( this.data, edi );
			if( edi < this.endData ) then

				push( esi );
				mov( edi, esi );
				mov( dest, edi );
				#if( @size( dequeType ) = 1 )

					movsb();

				#elseif( @size( dequeType ) = 2 )

					movsw();

				#elseif( @size( dequeType ) = 4 )

					movsd();

				#else

					push( ecx );
					#if( (@size( dequeType ) & %11) = 0 )

						mov( @size( dequeType ) div 4, ecx );
						rep.movsd();

					#elseif( (@size( dequeType ) & %01) = 0 )

						mov( @size( dequeType ) div 2, ecx );
						rep.movsw();

					#else

						mov( @size( dequeType ), ecx );
						rep.movsb();

					#endif
					pop( ecx );

				#endif
				pop( esi );
					
			endif;
			pop( edi );
			popfd();						

		end getVal;



		#if( (symbol.capabilities_c & stl.supportsObjSwap_c) <> 0 )

			// swapObj-
			//	Swaps another object with this one:

			method symbol.swapObj( var obj:symbol ); 
				@nodisplay; @nostackalign;

			const
				objEBX:text := "(type " + @string( symbol ) + " [ebx])";

			begin swapObj;


				push( eax );
				push( ebx );
				push( ecx );

				mov( obj, ebx );
				mov( this.isAlloc, al );
				mov( objEBX.isAlloc, ah );
				mov( al, objEBX.isAlloc );
				mov( ah, this.isAlloc );

				mov( this.typeName, ecx );
				mov( objEBX.typeName, eax );
				mov( ecx, objEBX.typeName );
				mov( eax, this.typeName );

				mov( this.numElements, ecx );
				mov( objEBX.numElements, eax );
				mov( ecx, objEBX.numElements );
				mov( eax, this.numElements );

				mov( this.dataSize, ecx );
				mov( objEBX.dataSize, eax );
				mov( ecx, objEBX.dataSize );
				mov( eax, this.dataSize );

				mov( this.allocSize, ecx );
				mov( objEBX.allocSize, eax );
				mov( ecx, objEBX.allocSize );
				mov( eax, this.allocSize );

				mov( this.data, ecx );
				mov( objEBX.data, eax );
				mov( ecx, objEBX.data );
				mov( eax, this.data );

				mov( this.endData, ecx );
				mov( objEBX.endData, eax );
				mov( ecx, objEBX.endData );
				mov( eax, this.endData );

				pop( ecx );
				pop( ebx );
				pop( eax );

			end swapObj;

		#endif

		#if( (symbol.capabilities_c & stl.supportsElementSwap_c) <> 0 )


			method symbol.swapElements
			( 
				first:cursorType; 
				second:cursorType 
			);
				@noframe;
				
			begin swapElements;
			
				push( ecx );
				push( esi );
				push( edi );
				
				#if( @size( dequeType ) = 1 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					mov( [esi], cl );
					mov( [edi], ch );
					mov( cl, [edi] );
					mov( ch, [esi] );
					 
				#elseif( @size( dequeType ) = 2 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], ax );
					mov( [edi], cx );
					mov( ax, [edi] );
					mov( cx, [esi] );
					pop( eax );
					
				#elseif( @size( dequeType ) = 4 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], eax );
					mov( [edi], ecx );
					mov( eax, [edi] );
					mov( ecx, [esi] );
					pop( eax );
					
				#elseif( @size( dequeType ) = 8 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], eax );
					mov( [edi], ecx );
					mov( eax, [edi] );
					mov( ecx, [esi] );
					mov( [esi+4], eax );
					mov( [edi+4], ecx );
					mov( eax, [edi+4] );
					mov( ecx, [esi+4] );
					pop( eax );
					
				#elseif( @size( dequeType ) = 16 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], eax );
					mov( [edi], ecx );
					mov( eax, [edi] );
					mov( ecx, [esi] );
					mov( [esi+4], eax );
					mov( [edi+4], ecx );
					mov( eax, [edi+4] );
					mov( ecx, [esi+4] );
					mov( [esi+8], eax );
					mov( [edi+8], ecx );
					mov( eax, [edi+8] );
					mov( ecx, [esi+8] );
					mov( [esi+12], eax );
					mov( [edi+12], ecx );
					mov( eax, [edi+12] );
					mov( ecx, [esi+12] );
					pop( eax );
					
				#elseif( (@size( dequeType ) & %11) = 0 )
				
					shr( 2, ecx );
					rep.movsd();
					
				#elseif( (@size( dequeType ) & %1) = 0 )
				
					shr( 1, ecx );
					rep.movsw();
					
				#else
				
					rep.movsb();
					
				#endif

					
				pop( edi );
				pop( esi );
				pop( ecx );
				ret( 8 );
				
			end swapElements;

		#endif


		// Comparisons-
		//	Handle the built-in types, but require the user to
		//	supply comparisons for other types.

		#if( (symbol.capabilities_c & stl.supportsCompare_c) <> 0 )

			stl.stdCompares( dequeType )

		#endif

				



		// Set us back to the TYPE section:

		type

	#endif

#endmacro



//////////////////////////////////////////////////////////////////////////////
//
// list template-


#macro list( rawListType, specificTraits[] ):
	symbol,
	listType,
	section,
	cursorType,
	ptrType,
	nodeType,
	temp;

	@forward( symbol );
	listType : rawListType;

	?section := @section;
	#if( (section & @global:hla.inType) <> @global:hla.inType )

		#error( "LIST declarations may only appear in a TYPE section" )

	#else


		// Create a pointer type for this class:

		?temp 			:string := @string( @text( symbol ) );
		?ptrType 		:string := "p_" + temp;
		?ptrType		:text   := ptrType;
		ptrType			:pointer to symbol;
		
		// Create a node type for the elements of the list:

		?nodeType 		:string := temp + "_node";
		?nodeType		:text   := nodeType;
		nodeType		:record

							data	:listType;

							isAlloc	:boolean;
							
							align(4);
							prev	:ptrType;
							next	:ptrType;

						 endrecord;
		
		
		// Create a cursor type for this class:

		?cursorType 	:string := temp + "_cursor";
		?cursorType		:text   := cursorType;
		cursorType		:pointer to nodeType;
		

		// Create the actual class:

		symbol:
			class inherits( stl.Container );

				// Set up the default capabilities for a list:

				val
					hierarchy_c := hierarchy_c | stl.isList_c;

					capabilities_c := 
							capabilities_c 
							#if( @isClass( listType ))
								| stl.elementsAreObjects_c
							#endif

						|	stl.supportsAppend_c		
						|	stl.supportsPrepend_c		
						|	stl.supportsInsert_c		
						|	stl.supportsRemove_c		
						|	stl.supportsSwap_c			
						|	stl.supportsForeach_c			
						|	stl.supportsrForeach_c			
						|	stl.supportsCursor_c			
						|	stl.supportsElementSwap_c
						|	stl.supportsObjSwap_c;

						
					// Okay, process any specific capabilities provided in
					// the list declaration:
					
					capabilities_c := 
						stl.parseCapabilities
						( 
							capabilities_c, 
							specificTraits 
						);


					// Set up the default performance traits:

					performance_c :=
							performance_c
						|	stl.fastElementSwap_c
						|	stl.fastAppend_c
						|	stl.fastInsert_c
						|	stl.fastPrepend_c
						|	stl.fastRemove_c			
						|	stl.fastSwap_c;				

						
					// Okay, process any specific performance traits
					//  provided in the list declaration:
					
					performance_c := 
						stl.parsePerformance
						( 
							performance_c, 
							specificTraits 
						);


					// Just as a safety net, let's verify that all
					// the user-specified traits are valid:

					stl.checkTraits
					( 
						specificTraits, 
						[[stl.performanceNames],[stl.capabilityNames]] 
					);


				readonly
					typeName_ro	:string := temp;
					
				var
					head	:ptrType;
					tail	:ptrType;


				// Public entities begin here:
				//
				// Constructor and destructor.
				// Note that all list types have a constructor and destructor

				procedure create( numElements:uns32 );
				method destroy;


				// iterators:

				#if( (symbol.capabilities_c & stl.supportsForeach_c) <> 0 )

					iterator forEachElement;

				#endif

				#if( (symbol.capabilities_c & stl.supportsrForeach_c) <> 0 )

					iterator rForEachElement;

				#endif

				// Element append, insert, and removal:

				#if( (symbol.capabilities_c & stl.supportsAppend_c) <> 0 )

					method appendNode( var toAppend:nodeType );
					method appendRef( var toAppend:listType );
					method appendVal( toAppend:listType );

				#endif

				#if( (symbol.capabilities_c & stl.supportsPrepend_c) <> 0 )

					method prependNode( var toPrepend:nodeType );
					method prependRef( var toPrepend:listType );
					method prependVal( toPrepend:listType );

				#endif


				#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )
				
					method insertNode( var toInsert:nodeType; posn:uns32 );
					method insertRef( var toInsert:listType; posn:uns32 );
					method insertVal( toInsert:listType; posn:uns32 );

				#endif


				#if( (symbol.capabilities_c & stl.supportsRemove_c) <> 0 )

					method remove( n:uns32 );
					method remove_first;
					method remove_last;

				#endif



				#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

					// Cursor manipulation routines:

					method nextCursor( var cursor:cursorType );
					method prevCursor( var cursor:cursorType );
					method beginCursor( var cursor:cursorType );
					method endCursor( var cursor:cursorType );
					method front; @returns( "eax" );
					method back; @returns( "eax" );

					method atBack( cursor:cursorType ); @returns( "@z" );
					method atFront( cursor:cursorType ); @returns( "@z" );
					method at( cursor:cursorType in eax ); @returns( "eax" );
					method atIndex( n:uns32 in eax ); @returns( "eax" );

					method getAt( cursor:cursorType; var dest:listType );

					#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )

						method insertAtVal
						( 
							toInsert:listType; 
							cursor:cursorType 
						);
						method insertAtRef
						( 
							var toInsert:listType; 
								cursor:cursorType 
						);
						method insertAtNode
						( 
							var toInsert:nodeType; 
								cursor:cursorType 
						);

					#endif

					#if( (symbol.capabilities_c & stl.supportsRemove_c) <> 0 )

						method removeAt( cursor:cursorType );

					#endif

				#endif

				// Accessor methods:

				method getRef( n:uns32 in eax ); @returns( "eax" );
				method getVal( n:uns32; var dest:listType );
				 
				// Element & object swapping:

				#if( (symbol.capabilities_c & stl.supportsObjSwap_c) <> 0 )
		
					method swapObj( var obj:symbol );

				#endif

				#if( (symbol.capabilities_c & stl.supportsElementSwap_c) <> 0 )

					method swapElements
					( 
						first	:cursorType; 
						second	:cursorType 
					);

				#endif

				// Comparisons:
				
				#if( (capabilities_c & stl.supportsCompare_c) <> 0 )

					method isEqual
					( 
						var left:listType; 
						var right:listType 
					);  @returns( "al" );

					method isLess
					( 
						var left:listType; 
						var right:listType 
					);  @returns( "al" );


					method isLessEqual
					( 
						var left:listType; 
						var right:listType 
					);  @returns( "al" );

				#endif

								

				// Output method

				#if( (capabilities_c & stl.supportsOutput_c) <> 0 )

					override method a_toString;

				#endif


			endclass;

		// Emit the VMT for this class:

		static
			vmt( symbol );


		// Object constructor.
		// If called with ESI = 0 (class constructor call) then
		// this routine allocates storage for the object itself
		// and returns a pointer to that object in ESI. 
		//
		// For list objects, the numElements parameter is completely
		// ignored (all nodes are allocated dynamically as needed).
		// This parameter is included here for compatibility with
		// other STL objects.

		procedure symbol.create( numElements:uns32 );
			@nodisplay; @noalignstack;
		begin create;

			push( eax );
			xor( eax, eax );	// Init isAlloc to false.
			if( esi = 0 ) then
			
				mem.alloc( @size( @text( @string( @text (symbol )))));
				mov( eax, esi );
				mov( true, al );	// Set isAlloc true.
				
			endif;
			mov( al, this.isAlloc );

			// Initialize the VMT pointer:

			mov( &symbol._VMT_, this._pVMT_ );

			// Initialize the internal data fields:
			
			mov( 0, this.numElements );
			mov( NULL, this.head );
			mov( NULL, this.tail );
			
			// Runtime information:
			// Begin by initializing the standard boolean variables with
			// their respective values for a list.
			
			mov( symbol.capabilities_c, this.capabilities );
			mov( symbol.performance_c, this.performance );
			mov( symbol.hierarchy_c, this.hierarchy );			

			// Other list specific-initialization:

			lea( eax, "list" );
			mov( eax, this.containerName );

			mov( symbol.typeName_ro, eax );
			mov( eax, this.typeName );


			pop( eax );

		end create;
		
		
		
		// destroy-
		//	Destructor for the list class.
		//
		//	Walks the list and deallocates the storage for each (allocated)
		//	node on the list. The deallocates the storage associated with the
		//	list itself.
		
		method symbol.destroy; @nodisplay; @noalignstack;
		begin destroy;
		
			push( eax );
			mov( this.head, edi );
			while( edi <> NULL ) do
			
				mov( (type nodeType [edi]).next, eax );
				if( (type nodeType [edi]).isAlloc ) then
				
					mem.free( edi );
					
				endif;
				mov( eax, edi );
				
			endwhile;
			if( this.isAlloc ) then
			
				mem.free( esi );
				
			endif;
			pop( eax );
			
		end destroy;



		#if( (symbol.capabilities_c & stl.supportsAppend_c) <> 0 )

			// appendNode-
			//	Appends a listType node to the end of the current list:

			method symbol.appendNode( var toAppend:nodeType );
			begin appendNode;
			
				push( eax );
				
				mov( this.tail, edi );
				mov( toAppend, eax );
				assert( eax<>NULL );
				mov( eax, this.tail );
				if( edi = NULL ) then
				
					// Note: the only time this.tail contains NULL
					// is when this.head also contains NULL (because
					// the list is empty). In that case, we need to
					// initialize this.head:
					
					mov( eax, this.head );
					
				else
				
					mov( eax, (type nodeType [edi]).next );
										
				endif;
				mov( edi, (type nodeType [eax]).prev );
				mov( NULL, (type nodeType [eax]).next );
				add( 1, this.numElements );
				
				pop( eax );			

			end appendNode;
			
			

			// appendRef-
			//	Appends a new value to the end of the list.
			//	The value passed as the argument is passed by reference.
			//	This is an actual listType value, not a node. appendRef
			//	will allocate storage for a node, copy the data to the
			//	new node, and then append the node to the end of the list.
			//
			//	You should use this append function when the list element
			//	type is large.

			method symbol.appendRef( var toAppend:listType );
				@nodisplay; @noalignstack;
			begin appendRef;

				push( eax );
				push( ecx );
				push( esi );
				
				// First, we need to allocate storage for a list node:
				
				mov( @size( nodeType ), ecx );
				mem.alloc( ecx );
				mov( true, (type nodeType [eax]).isAlloc );
				lea( edi, (type nodeType [eax]).data );
				mov( toAppend, esi );
				#if( @size( listType ) = 1 )
				
					mov( [esi], cl );
					mov( cl, [edi] );
					 
				#elseif( @size( listType ) = 2 )
				
					mov( [esi], cx );
					mov( cx, [edi] );
					
				#elseif( @size( listType ) = 4 )
				
					mov( [esi], ecx );
					mov( ecx, [edi] );
					
				#elseif( @size( listType ) = 8 )
				
					mov( [esi], ecx );
					mov( ecx, [edi] );
					mov( [esi+4], ecx );
					mov( ecx, [edi+4] );
					
				#elseif( @size( listType ) = 16 )
				
					mov( [esi], ecx );
					mov( ecx, [edi] );
					mov( [esi+4], ecx );
					mov( ecx, [edi+4] );
					mov( [esi+8], ecx );
					mov( ecx, [edi+8] );
					mov( [esi+12], ecx );
					mov( ecx, [edi+12] );
					
				#elseif( (@size( listType ) & %11) = 0 )
				
					pushfd();
					cld();
					shr( 2, ecx );
					rep.movsd();
					popfd();
					
				#elseif( (@size( listType ) & %1) = 0 )
				
					pushfd();
					cld();
					shr( 1, ecx );
					rep.movsw();
					popfd();
					
				#else
				
					pushfd();
					cld();
					rep.movsb();
					popfd();
					
				#endif
				pop( esi );
				
				// Okay, do the actual append here:
				
				mov( this.tail, edi );
				mov( eax, this.tail );
				if( edi = NULL ) then
				
					// Note: the only time this.tail contains NULL
					// is when this.head also contains NULL (because
					// the list is empty). In that case, we need to
					// initialize this.head:
					
					mov( eax, this.head );

				else
				
					mov( eax, (type nodeType [edi]).next );
										
				endif;
				mov( edi, (type nodeType [eax]).prev );
				mov( NULL, (type nodeType [eax]).next );
				add( 1, this.numElements );

				pop( ecx );
				pop( eax );

			end appendRef;



			// appendVal-
			//	Appends a new node to the end of the list.
			//	The value passed as the argument is passed by value.
			//	This function creates a new node on the heap, initializes
			//	it with the value passed by value, and appends the node
			//	to the end of the list.
			//	You should use this append function when the list element
			//	type is small (typically 16 bytes or less).


			method symbol.appendVal( toAppend:listType );
				@nodisplay; @noalignstack;
			begin appendVal;

				push( eax );
				push( ecx );
				
				// First, we need to allocate storage for a list node:
				
				mov( @size( nodeType ), ecx );
				mem.alloc( ecx );
				mov( true, (type nodeType [eax]).isAlloc );
				
				// Now copy the data from the parameter list to the
				// newly allocated node:
				
				lea( edi, (type nodeType [eax]).data );
				#if( @size( listType ) = 1 )
				
					mov( (type byte toAppend), cl );
					mov( cl, [edi] );
					 
				#elseif( @size( listType ) = 2 )
				
					mov( (type word toAppend), cx );
					mov( cx, [edi] );
					
				#elseif( @size( listType ) = 4 )
				
					mov( (type dword toAppend), ecx );
					mov( ecx, [edi] );
					
				#elseif( @size( listType ) = 8 )
				
					mov( (type dword toAppend), ecx );
					mov( ecx, [edi] );
					mov( (type dword toAppend[4]), ecx );
					mov( ecx, [edi+4] );
					
				#elseif( @size( listType ) = 16 )
				
					mov( (type dword toAppend), ecx );
					mov( ecx, [edi] );
					mov( (type dword toAppend[4]), ecx );
					mov( ecx, [edi+4] );
					mov( (type dword toAppend[8]), ecx );
					mov( ecx, [edi+8] );
					mov( (type dword toAppend[12]), ecx );
					mov( ecx, [edi+12] );
					
				#elseif( (@size( listType ) & %11) = 0 )
				
					push( esi );
					lea( esi, toAppend );
					pushfd();
					cld();
					shr( 2, ecx );
					rep.movsd();
					popfd();
					pop( esi );
					
				#elseif( (@size( listType ) & %1) = 0 )
				
					push( esi );
					lea( esi, toAppend );
					pushfd();
					cld();
					shr( 1, ecx );
					rep.movsw();
					popfd();
					pop( esi );
					
				#else
				
					push( esi );
					lea( esi, toAppend );
					pushfd();
					cld();
					rep.movsb();
					popfd();
					pop( esi );
					
				#endif
				
				// Okay, do the actual append here:
				
				mov( this.tail, edi );
				mov( eax, this.tail );
				if( edi = NULL ) then
				
					// Note: the only time this.tail contains NULL
					// is when this.head also contains NULL (because
					// the list is empty). In that case, we need to
					// initialize this.head:
					
					mov( eax, this.head );

				else
				
					mov( eax, (type nodeType [edi]).next );
					
				endif;
				mov( edi, (type nodeType [eax]).prev );
				mov( NULL, (type nodeType [eax]).next );
				add( 1, this.numElements );

				pop( ecx );
				pop( eax );

			end appendVal;

		#endif



		#if( (symbol.capabilities_c & stl.supportsPrepend_c) <> 0 )

			// prependNode-
			//	Prepends a listType node to the front of the current list:

			method symbol.prependNode( var toPrepend:nodeType );
			begin prependNode;
			
				push( eax );
				
				mov( this.head, edi );
				mov( toPrepend, eax );
				assert( eax<>NULL );

				mov( eax, this.head );
				if( edi = NULL ) then
				
					// Note: the only time this.head contains NULL
					// is when this.tail also contains NULL (because
					// the list is empty). In that case, we need to
					// initialize this.tail:
					
					mov( eax, this.tail );
					
				else
				
					mov( eax, (type nodeType [edi]).prev );
					
				endif;
				mov( edi, (type nodeType [eax]).next );
				mov( NULL, (type nodeType [eax]).prev );
				add( 1, this.numElements );
				
				pop( eax );			

			end prependNode;
			
			

			
			

			// prependRef-
			//	Prepends a new value to the start of the list.
			//	The value passed as the argument is passed by reference.
			//	This is an actual listType value, not a node. prependRef
			//	will allocate storage for a node, copy the data to the
			//	new node, and then prepend the node to the start of the list.
			//
			//	You should use this append function when the list element
			//	type is large.

			method symbol.prependRef( var toPrepend:listType );
				@nodisplay; @noalignstack;
			begin prependRef;

				push( eax );
				push( ecx );
				push( esi );
				
				// First, we need to allocate storage for a list node:
				
				mov( @size( nodeType ), ecx );
				mem.alloc( ecx );
				mov( true, (type nodeType [eax]).isAlloc );
				lea( edi, (type nodeType [eax]).data );
				mov( toPrepend, esi );
				#if( @size( listType ) = 1 )
				
					mov( [esi], cl );
					mov( cl, [edi] );
					 
				#elseif( @size( listType ) = 2 )
				
					mov( [esi], cx );
					mov( cx, [edi] );
					
				#elseif( @size( listType ) = 4 )
				
					mov( [esi], ecx );
					mov( ecx, [edi] );
					
				#elseif( @size( listType ) = 8 )
				
					mov( [esi], ecx );
					mov( ecx, [edi] );
					mov( [esi+4], ecx );
					mov( ecx, [edi+4] );
					
				#elseif( @size( listType ) = 16 )
				
					mov( [esi], ecx );
					mov( ecx, [edi] );
					mov( [esi+4], ecx );
					mov( ecx, [edi+4] );
					mov( [esi+8], ecx );
					mov( ecx, [edi+8] );
					mov( [esi+12], ecx );
					mov( ecx, [edi+12] );
					
				#elseif( (@size( listType ) & %11) = 0 )
				
					pushfd();
					cld();
					shr( 2, ecx );
					rep.movsd();
					popfd();
					
				#elseif( (@size( listType ) & %1) = 0 )
				
					pushfd();
					cld();
					shr( 1, ecx );
					rep.movsw();
					popfd();
					
				#else
				
					pushfd();
					cld();
					rep.movsb();
					popfd();
					
				#endif
				pop( esi );
				
				// Okay, do the actual append here:
				
				mov( this.head, edi );
				mov( eax, this.head );
				if( edi = NULL ) then
				
					// Note: the only time this.head contains NULL
					// is when this.tail also contains NULL (because
					// the list is empty). In that case, we need to
					// initialize this.tail:
					
					mov( eax, this.tail );

				else
				
					mov( eax, (type nodeType [edi]).prev );
									
				endif;
				mov( edi, (type nodeType [eax]).next );
				mov( NULL, (type nodeType [eax]).prev );
				add( 1, this.numElements );

				pop( ecx );
				pop( eax );

			end prependRef;



			// prependVal-
			//	Prepends a new element to the front of the list.
			//	The value passed as the argument is passed by value.
			//	prependVal allocates a new node and copies the data
			//	passed to the new node and then inserts that node
			//	at the front of the list.
			//
			//	You should use this append function when the list element
			//	type is small (typically 16 bytes or less).


			method symbol.prependVal( toPrepend:listType );
				@nodisplay; @noalignstack;
			begin prependVal;

				push( eax );
				push( ecx );
				
				// First, we need to allocate storage for a list node:
				
				mov( @size( nodeType ), ecx );
				mem.alloc( ecx );
				mov( true, (type nodeType [eax]).isAlloc );
				
				// Now copy the data from the parameter list to the
				// newly allocated node:
				
				lea( edi, (type nodeType [eax]).data );
				#if( @size( listType ) = 1 )
				
					mov( (type byte toPrepend), cl );
					mov( cl, [edi] );
					 
				#elseif( @size( listType ) = 2 )
				
					mov( (type word toPrepend), cx );
					mov( cx, [edi] );
					
				#elseif( @size( listType ) = 4 )
				
					mov( (type dword toPrepend), ecx );
					mov( ecx, [edi] );
					
				#elseif( @size( listType ) = 8 )
				
					mov( (type dword toPrepend), ecx );
					mov( ecx, [edi] );
					mov( (type dword toPrepend[4]), ecx );
					mov( ecx, [edi+4] );
					
				#elseif( @size( listType ) = 16 )
				
					mov( (type dword toPrepend), ecx );
					mov( ecx, [edi] );
					mov( (type dword toPrepend[4]), ecx );
					mov( ecx, [edi+4] );
					mov( (type dword toPrepend[8]), ecx );
					mov( ecx, [edi+8] );
					mov( (type dword toPrepend[12]), ecx );
					mov( ecx, [edi+12] );
					
				#elseif( (@size( listType ) & %11) = 0 )
				
					push( esi );
					lea( esi, toPrepend );
					pushfd();
					cld();
					shr( 2, ecx );
					rep.movsd();
					popfd();
					pop( esi );
					
				#elseif( (@size( listType ) & %1) = 0 )
				
					push( esi );
					lea( esi, toPrepend );
					pushfd();
					cld();
					shr( 1, ecx );
					rep.movsw();
					popfd();
					pop( esi );
					
				#else
				
					push( esi );
					lea( esi, toPrepend );
					pushfd();
					cld();
					rep.movsb();
					popfd();
					pop( esi );
					
				#endif
				
				// Okay, do the actual append here:
				
				mov( this.head, edi );
				mov( eax, this.head );
				if( edi = NULL ) then
				
					// Note: the only time this.head contains NULL
					// is when this.tail also contains NULL (because
					// the list is empty). In that case, we need to
					// initialize this.tail:
					
					mov( eax, this.tail );
					
				else
				
					mov( eax, (type nodeType [edi]).prev );
					
				endif;
				mov( edi, (type nodeType [eax]).next );
				mov( NULL, (type nodeType [eax]).prev );
				add( 1, this.numElements );

				pop( ecx );
				pop( eax );

			end prependVal;

					
		#endif


				
		#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )
		


			// insertNode-
			//	Inserts a listType node at an arbitrary point 
			//  in the current list:

			method symbol.insertNode( var toInsert:nodeType; posn:uns32 );
			begin insertNode;
			
				push( eax );
				push( ecx );
				
				assert( toInsert <> NULL );
				
				// First, we have to find the node we're going to insert
				// in front of:
				
				mov( posn, ecx );
				if( ecx >= this.numElements ) then
				
					// If the insertion position is beyond the end of the
					// list, then just do an append. Note that this also
					// handles the case where the list is empty.
					
					this.appendNode( toInsert );
				
				elseif( ecx = 0 ) then
				
					// Handle insertion at the beginning of the list
					// specially (because we have to update the this.head
					// field, which we normally don't need to do for an
					// insertion operation):
					
					this.prependNode( toInsert );
					
				else // Inserting at some position in the middle of the list.
				
					// Okay, find the node we're supposed to insert in front
					// of:
					
					mov( this.head, edi );
					while( ecx <> 0 ) do
					
						mov( (type nodeType [edi]).next, edi );
						sub( 1, ecx );
						
					endwhile;
					mov( toInsert, eax );
					mov( (type nodeType [edi]).prev, ecx );
					mov( eax, (type nodeType [edi]).prev );
					mov( ecx, (type nodeType [eax]).prev );
					mov( edi, (type nodeType [eax]).next );

					// Note: we know that this isn't the first
					// node in the list (hence ECX is non-NULL)
					// because we handled the first item above.

					mov( eax, (type nodeType [ecx]).next );
					add( 1, this.numElements );
				
				endif;
				
				pop( ecx );
				pop( eax );			

			end insertNode;
			
			

			// insertRef-
			//
			//	Inserts a list value (toInsert) at position posn within
			//	the array. If posn is beyond the end of the list, then this
			//	code appends the value to the end of the list. Note that
			//	the parameter is a listType value, not a nodeType object.
			//	This method allocates storage for a new node and copies the
			//	parameter value to the newly created node and appends the
			//	new node to the list in front of the node specified by posn.
			//
			//	insertRef passes toInsert by reference, so you should use this
			//	function to insert large objects into the array.

			method symbol.insertRef( var toInsert:listType; posn:uns32 );
				@nodisplay; @noalignstack;
			begin insertRef;

				push( eax );
				push( ecx );
				push( esi );
				
				// First, we need to allocate storage for a list node:
				
				mov( @size( nodeType ), ecx );
				mem.alloc( ecx );
				mov( true, (type nodeType [eax]).isAlloc );
				lea( edi, (type nodeType [eax]).data );
				mov( toInsert, esi );
				#if( @size( listType ) = 1 )
				
					mov( [esi], cl );
					mov( cl, [edi] );
					 
				#elseif( @size( listType ) = 2 )
				
					mov( [esi], cx );
					mov( cx, [edi] );
					
				#elseif( @size( listType ) = 4 )
				
					mov( [esi], ecx );
					mov( ecx, [edi] );
					
				#elseif( @size( listType ) = 8 )
				
					mov( [esi], ecx );
					mov( ecx, [edi] );
					mov( [esi+4], ecx );
					mov( ecx, [edi+4] );
					
				#elseif( @size( listType ) = 16 )
				
					mov( [esi], ecx );
					mov( ecx, [edi] );
					mov( [esi+4], ecx );
					mov( ecx, [edi+4] );
					mov( [esi+8], ecx );
					mov( ecx, [edi+8] );
					mov( [esi+12], ecx );
					mov( ecx, [edi+12] );
					
				#elseif( (@size( listType ) & %11) = 0 )
				
					pushfd();
					cld();
					shr( 2, ecx );
					rep.movsd();
					popfd();
					
				#elseif( (@size( listType ) & %1) = 0 )
				
					pushfd();
					cld();
					shr( 1, ecx );
					rep.movsw();
					popfd();
					
				#else
				
					pushfd();
					cld();
					rep.movsb();
					popfd();
					
				#endif
				pop( esi );
				
				// Okay, do the actual insertion here:
				
				this.insertNode( (type nodeType [eax]), posn );
				
				pop( ecx );
				pop( eax );

			end insertRef;



			// insertVal-
			//
			//	Inserts an array element (toInsert) at position posn within
			//	the array. If posn is beyond the end of the array, then this
			//	code appends the value to the end of the array.
			//
			//	insertVal passes toInsert by value, so you should use this
			//	function to insert small objects into the array.


			method symbol.insertVal( toInsert:listType; posn:uns32 );
				@nodisplay; @noalignstack;
			begin insertVal;

				push( eax );
				push( ecx );
				
				// First, we need to allocate storage for a list node:
				
				mov( @size( nodeType ), ecx );
				mem.alloc( ecx );
				mov( true, (type nodeType [eax]).isAlloc );
				lea( edi, (type nodeType [eax]).data );
				#if( @size( listType ) = 1 )
				
					mov( (type byte toInsert), cl );
					mov( cl, [edi] );
					 
				#elseif( @size( listType ) = 2 )
				
					mov( (type word toInsert), cx );
					mov( cx, [edi] );
					
				#elseif( @size( listType ) = 4 )
				
					mov( (type dword toInsert), ecx );
					mov( ecx, [edi] );
					
				#elseif( @size( listType ) = 8 )
				
					mov( (type dword toInsert), ecx );
					mov( ecx, [edi] );
					mov( (type dword toInsert[4]), ecx );
					mov( ecx, [edi+4] );
					
				#elseif( @size( listType ) = 16 )
				
					mov( (type dword toInsert), ecx );
					mov( ecx, [edi] );
					mov( (type dword toInsert[4]), ecx );
					mov( ecx, [edi+4] );
					mov( (type dword toInsert[8]), ecx );
					mov( ecx, [edi+8] );
					mov( (type dword toInsert[12]), ecx );
					mov( ecx, [edi+12] );
					
				#elseif( (@size( listType ) & %11) = 0 )
				
					push( esi );
					lea( esi, toInsert );
					pushfd();
					cld();
					shr( 2, ecx );
					rep.movsd();
					popfd();
					pop( esi );
					
				#elseif( (@size( listType ) & %1) = 0 )
				
					push( esi );
					lea( esi, toInsert );
					pushfd();
					cld();
					shr( 1, ecx );
					rep.movsw();
					popfd();
					pop( esi );
					
				#else
				
					push( esi );
					lea( esi, toInsert );
					pushfd();
					cld();
					rep.movsb();
					popfd();
					pop( esi );
					
				#endif
				
				// Okay, do the actual insertion here:
				
				this.insertNode( (type nodeType [eax]), posn );
				
				pop( ecx );
				pop( eax );

			end insertVal;


			#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

				// insertAtNode-
				//
				//	Inserts a list node just before the node specified
				//	by the cursor passed as the second argument.

				method symbol.insertAtNode
				( 
					var toInsert	:nodeType; 
						cursor		:cursorType 
				);
					@nodisplay; @noalignstack;
				begin insertAtNode;

					push( eax );
					push( ecx );

					assert( toInsert <> NULL );
					assert( cursor <> NULL );

					// Note: if cursor contains NULL, then we
					// append the node to the end of the list
					// (special case because we use NULL as the
					// cursor value for the end of the list).
									
					mov( cursor, edi );
					if( edi = NULL ) then
					
						this.appendNode( toInsert );
						
					else
					
						mov( toInsert, ecx );
						mov( (type nodeType [edi]).prev, eax );
						mov( eax, (type nodeType [ecx]).prev );
						mov( ecx, (type nodeType [edi]).prev );
						mov( edi, (type nodeType [ecx]).next );
						
						// If we inserted this node at the front of the
						// list, then we need to update this.head.
						
						if( eax = NULL ) then
						
							mov( ecx, this.head );
							
						else
						
							mov( ecx, (type nodeType [eax]).next );
							
						endif;
						
					endif;
									
					pop( ecx );
					pop( eax );

				end insertAtNode;
				
				

				// insertAtRef-
				//
				//	Inserts an array element just before the element specified
				//	by the cursor passed as the second argument.
				//
				//	insertAtRef passes toInsert by reference, so you should use this
				//	function to insert large objects into the array.

				method symbol.insertAtRef
				( 
					var toInsert:listType; 
						cursor:cursorType 
				);
					@nodisplay; @noalignstack;
				begin insertAtRef;

					push( eax );
					push( ecx );
					push( esi );
					
					assert( toInsert <> NULL );
					assert( cursor <> NULL );
					
					// First, we need to allocate storage for a list node:
					
					mov( @size( nodeType ), ecx );
					mem.alloc( ecx );
					mov( true, (type nodeType [eax]).isAlloc );
					lea( edi, (type nodeType [eax]).data );
					mov( toInsert, esi );
					#if( @size( listType ) = 1 )
					
						mov( [esi], cl );
						mov( cl, [edi] );
						 
					#elseif( @size( listType ) = 2 )
					
						mov( [esi], cx );
						mov( cx, [edi] );
						
					#elseif( @size( listType ) = 4 )
					
						mov( [esi], ecx );
						mov( ecx, [edi] );
						
					#elseif( @size( listType ) = 8 )
					
						mov( [esi], ecx );
						mov( ecx, [edi] );
						mov( [esi+4], ecx );
						mov( ecx, [edi+4] );
						
					#elseif( @size( listType ) = 16 )
					
						mov( [esi], ecx );
						mov( ecx, [edi] );
						mov( [esi+4], ecx );
						mov( ecx, [edi+4] );
						mov( [esi+8], ecx );
						mov( ecx, [edi+8] );
						mov( [esi+12], ecx );
						mov( ecx, [edi+12] );
						
					#elseif( (@size( listType ) & %11) = 0 )
					
						pushfd();
						cld();
						shr( 2, ecx );
						rep.movsd();
						popfd();
						
					#elseif( (@size( listType ) & %1) = 0 )
					
						pushfd();
						cld();
						shr( 1, ecx );
						rep.movsw();
						popfd();
						
					#else
					
						pushfd();
						cld();
						rep.movsb();
						popfd();
						
					#endif
					pop( esi );
					
					// Okay, do the actual insertion here:
					
					this.insertAtNode( (type nodeType [eax]), cursor );
					
					pop( ecx );
					pop( eax );

				end insertAtRef;

				// insertAtVal-
				//
				//	Inserts a listType value (toInsert) in front of the list item
				//	specified by the cursor passed as the second argument.
				//
				//	insertAtVal passes toInsert by value, so you should use this
				//	function to insert small objects into the list.


				method symbol.insertAtVal( toInsert:listType; cursor:cursorType );
					@nodisplay; @noalignstack;
				begin insertAtVal;

					push( eax );
					push( ecx );
					
					assert( toInsert <> NULL );
					assert( cursor <> NULL );
					
					// First, we need to allocate storage for a list node:
					
					mov( @size( nodeType ), ecx );
					mem.alloc( ecx );
					mov( true, (type nodeType [eax]).isAlloc );
					lea( edi, (type nodeType [eax]).data );
					#if( @size( listType ) = 1 )
					
						mov( (type byte toInsert), cl );
						mov( cl, [edi] );
						 
					#elseif( @size( listType ) = 2 )
					
						mov( (type word toInsert), cx );
						mov( cx, [edi] );
						
					#elseif( @size( listType ) = 4 )
					
						mov( (type dword toInsert), ecx );
						mov( ecx, [edi] );
						
					#elseif( @size( listType ) = 8 )
					
						mov( (type dword toInsert), ecx );
						mov( ecx, [edi] );
						mov( (type dword toInsert[4]), ecx );
						mov( ecx, [edi+4] );
						
					#elseif( @size( listType ) = 16 )
					
						mov( (type dword toInsert), ecx );
						mov( ecx, [edi] );
						mov( (type dword toInsert[4]), ecx );
						mov( ecx, [edi+4] );
						mov( (type dword toInsert[8]), ecx );
						mov( ecx, [edi+8] );
						mov( (type dword toInsert[12]), ecx );
						mov( ecx, [edi+12] );
						
					#elseif( (@size( listType ) & %11) = 0 )
					
						push( esi );
						lea( esi, toInsert );
						pushfd();
						cld();
						shr( 2, ecx );
						rep.movsd();
						popfd();
						pop( esi );
						
					#elseif( (@size( listType ) & %1) = 0 )
					
						push( esi );
						lea( esi, toInsert );
						pushfd();
						cld();
						shr( 1, ecx );
						rep.movsw();
						popfd();
						pop( esi );
						
					#else
					
						push( esi );
						lea( esi, toInsert );
						pushfd();
						cld();
						rep.movsb();
						popfd();
						
					#endif
					
					// Okay, do the actual insertion here:
					
					this.insertAtNode( (type nodeType [eax]), cursor );
					
					pop( ecx );
					pop( eax );

				end insertAtVal;

			#endif

		#endif


		#if( (symbol.capabilities_c & stl.supportsRemove_c) <> 0 )
		
			// remove-
			//	Removes the nTH item from the list.
			//
			//	If n is greater than the number of items in the list,
			//	then this function has no effect. 

			method symbol.remove( n:uns32 );
				@nodisplay; @noalignstack;
			begin remove;
			
				push( eax );
				push( ecx );
				mov( n, ecx );
				if( ecx < this.numElements ) then
				
				
					// First, we have to find the node we're going to remove.
					// Begin with a quick check for the last item
					// in the list.
					
					lea( eax, [ecx+1] );
					if( eax = this.numElements ) then
						
						// No need to search for the last element of the
						// list as we've already got a pointer to it:
						
						mov( this.tail, edi );
						mov( (type nodeType [edi]).prev, eax );
						mov( eax, this.tail );
						if( eax <> NULL ) then
						
							// If prev was not NULL, then we have
							// a previous node and we have to set its
							// next field to NULL as it is the new tail.
							
							mov( NULL, (type nodeType [eax]).next );
							
						else
						
							// If there was only one node, then we've just
							// emptied the list and we have to set this.head
							// to NULL.
							
							mov( NULL, this.head );
							
						endif;
						
						// If the node was allocated on the heap, then
						// free the storage associated with it.
						
						if( (type nodeType [edi]).isAlloc ) then
						
							mem.free( edi );
							
						endif;
					
						
					elseif( ecx = 0 ) then
					
						// Handle the first node as a special case (because
						// we've got to tweak this.head).
						
						mov( this.head, edi );
						mov( (type nodeType [edi]).next, eax );
						mov( eax, this.head );

						// Note: it can never be the case that EAX is
						// NULL at this point because if there were only
						// one node in the list (the situation when ".next"
						// would be NULL) we would have already handled this
						// case above.
						
						mov( NULL, (type nodeType [eax]).next );
						
						// If the node was allocated on the heap, then
						// free the storage associated with it.
						
						if( (type nodeType [edi]).isAlloc ) then
						
							mem.free( edi );
							
						endif;					
						
					else 
					
						// Removing the first element (cheap) or some other
						// element from the list.  Find the particular node.
						
						mov( this.head, edi );
						while( ecx <> 0 ) do
						
							mov( (type nodeType [edi]).next, edi );
							sub( 1, ecx );
							
						endwhile;
						
						// Okay, unlink the specified node. We know that this
						// isn't the first or last node, so we don't have to
						// handle those two special cases.
						
						mov( (type nodeType [edi]).prev, eax );
						mov( (type nodeType [edi]).next, ecx );
						mov( eax, (type nodeType [ecx]).prev );
						mov( ecx, (type nodeType [eax]).next );
						if( (type nodeType [edi]).isAlloc ) then
						
							mem.free( edi );
							
						endif;
					
					endif;
					sub( 1, this.numElements );
					
				endif;			
				pop( ecx );
				pop( eax );			

			end remove;
			
			
			
			// remove_first-
			//	Removes the first item from a list.
				

			method symbol.remove_first; @noframe;
			begin remove_first;

				if( this.numElements <> 0 ) then
				
					mov( this.head, eax );
					mov( (type nodeType [eax]).next, ecx );
					mov( ecx, this.head );
					if( ecx = NULL ) then
					
						// If there was only one item in the list, then
						// we've got to clear out this.tail, too.
						
						mov( ecx, this.tail );

					else

						mov( NULL, (type nodeType [ecx]).prev );
						
					endif;
					if( (type nodeType [eax]).isAlloc ) then
					
						mem.free( eax );
						
					endif;
					sub( 1, this.numElements );
					
				endif;
				ret();			
					
			end remove_first;


			// remove_last-
			//	Removes the last item from a list.

			method symbol.remove_last; @noframe;
			begin remove_last;

				if( this.numElements <> 0 ) then
				
					mov( this.tail, eax );
					mov( (type nodeType [eax]).prev, ecx );
					mov( ecx, this.tail );
					if( ecx = NULL ) then
					
						// If there was only one item in the list, then
						// we've got to clear out this.head, too.
						
						mov( ecx, this.head );

					else

						// Mark the end of the list with NULL:

						mov( NULL, (type nodeType [ecx]).next );
						
					endif;
					if( (type nodeType [eax]).isAlloc ) then
					
						mem.free( eax );
						
					endif;
					sub( 1, this.numElements );
					
				endif;
				ret();			
					
			end remove_last;


			#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

				// removeAt-
				//	Removes the item appearing at the location specified
				//	by the cursor passed as a parameter.

				method symbol.removeAt( cursor:cursorType );
					@nodisplay; @noalignstack;
				begin removeAt;
				
					push( eax );
					assert( cursor <> NULL );
					
					mov( cursor, eax );
					if( eax = this.tail ) then
					
						mov( (type nodeType [eax]).prev, ecx );
						mov( ecx, this.tail );
						if( ecx = NULL ) then
						
							// If there was only one item in the list, then
							// we've got to clear out this.head, too.
							
							mov( ecx, this.head );
							
						else
						
							// If there was a previous node in the
							// list, then set its next field to NULL
							// because it's now the end of the list:
							
							mov( NULL, (type nodeType [ecx]).next );
							
						endif;
						if( (type nodeType [eax]).isAlloc ) then
						
							mem.free( eax );
							
						endif;

					elseif( eax = this.head ) then
					
						mov( (type nodeType [eax]).next, ecx );
						mov( ecx, this.head );
						
						// We know there is a next node because if there were
						// only one node in the system we would have handled
						// it in the previous case.
						
						mov( NULL, (type nodeType [ecx]).prev );
						if( (type nodeType [eax]).isAlloc ) then
						
							mem.free( eax );
							
						endif;
					
					else
					
					endif;
					sub( 1, this.numElements );
					pop( eax );

				end removeAt;

			#endif

		#endif
		   

		#if( (symbol.capabilities_c & stl.supportsForeach_c) <> 0 )

			// The following iterators will sequence through
			// all the elements of the array. On each iteration
			// of the corresponding foreach loop, this iterator
			// will return the *address* of the respective list
			// element.
			//
			// forEachElement returns items from the start to the end of the object
			// rForEachElement returns items from the end to the start.

			iterator symbol.forEachElement;
				@nodisplay; @noalignstack;
			begin forEachElement;

				push( eax );
				push( edx );
				mov( this.head, edx );
				while( edx <> NULL ) do

					push( esi );
					push( edx );
					lea( eax, (type nodeType [edx]).data );
					yield();
					pop( edx );
					pop( esi );
					mov( (type nodeType [edx]).next, edx );

				endwhile;
				pop( edx );
				pop( eax );

			end forEachElement;


		#endif
		
		#if( (symbol.capabilities_c & stl.supportsrForeach_c) <> 0 )
						

			iterator symbol.rForEachElement;
				@nodisplay; @noalignstack;
			begin rForEachElement;

				push( eax );
				push( edx );
				mov( this.tail, edx );
				while( edx <> NULL ) do

					push( esi );
					push( edx );
					lea( eax, (type nodeType [edx]).data );
					yield();
					pop( edx );
					pop( esi );
					mov( (type nodeType [edx]).prev, edx );

				endwhile;
				pop( edx );
				pop( eax );

			end rForEachElement;
					
		#endif


		#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

			// nextCursor-
			//	Adjusts the cursor to point at the next element of the
			//	list and returns this pointer in EAX. Note that NULL
			//	is used to mark the end of the list, so if the cursor
			//	contains NULL upon entry, this code simply returns with
			// 	cursor still containing NULL.

			method symbol.nextCursor( var cursor:cursorType ); @noframe;
			begin nextCursor;

				push( eax );
				mov( [esp+@offset( cursor )], eax );
				assert( eax <> NULL );
				push( ebx );
				mov( [eax], ebx );
				if( ebx <> NULL ) then
				
					mov( (type nodeType [ebx]).next, ebx );
				
				endif;
				mov( ebx, [eax] );
				pop( ebx );
				pop( eax );
				ret( 4 );

			end nextCursor;



			// prevCursor-
			//	Adjust the cursor to point at the previous element in the list.
			//	If doing this would position the cursor before the start of the
			//	list, then this just sets the cursor position to the start of
			//	the list. If cursor is a variable containing NULL, then this
			//	code sets cursor to point at the tail object as NULL is used
			//	to mark the spot beyond the end of the list.

			method symbol.prevCursor( var cursor:cursorType ); @noframe;
			begin prevCursor;


				push( eax );
				mov( [esp+@offset( cursor )], eax );
				assert( eax <> NULL );
				push( ebx );
				mov( [eax], ebx );
				if( ebx <> this.head && ebx <> NULL ) then
				
					mov( (type nodeType [ebx]).prev, ebx );
				
				endif;
				mov( ebx, [eax] );
				pop( ebx );
				pop( eax );
				ret( 4 );

			end prevCursor;



			// beginCursor-
			//	Puts a pointer to the start of the list in cursor:

			method symbol.beginCursor( var cursor:cursorType ); @noframe;
			begin beginCursor;

				push( eax );
				mov( [esp+@offset( cursor )], eax );
				mov( this.head, [eax] );
				pop( eax );
				ret();

			end beginCursor;

			// endCursor-
			//	Puts a pointer to the end of the list in cursor. This is
			//	just the value NULL.

			method symbol.endCursor( var cursor:cursorType ); @noframe;
			begin endCursor;

				push( eax );
				mov( [esp+@offset( cursor )], eax );
				mov( NULL, (type dword [eax]) );
				pop( eax );
				ret();

			end endCursor;

			// at-
			//	Moves the address of the data element referenced by the
			// cursor passed as the argument into the EAX register.

			method symbol.at( cursor:cursorType in eax ); @noframe;
			begin at;

				lea( eax, (type nodeType [eax]).data );
				ret();

			end at;




			// getAt-
			//	Copies the data item specified by the cursor to
			//	the variable specified by the second argument.
			//  If cursor is out of range (NULL), no action is taken.
														  
			method symbol.getAt( cursor:cursorType; var dest:listType );
				@nodisplay; @noalignstack;
			begin getAt;

				pushfd();
				push( edi );
				cld();
				mov( cursor, edi );
				if( edi <> NULL ) then

					push( esi );
					lea( esi, (type nodeType [edi]).data );
					mov( dest, edi );
					#if( @size( listType ) = 1 )

						movsb();

					#elseif( @size( listType ) = 2 )

						movsw();

					#elseif( @size( listType ) = 4 )

						movsd();

					#elseif( @size( listType ) = 8 )

						movsd();
						movsd();

					#elseif( @size( listType ) = 16 )

						movsd();
						movsd();
						movsd();
						movsd();

					#else

						push( ecx );
						#if( (@size( listType ) & %11) = 0 )

							mov( @size( listType ) div 4, ecx );
							rep.movsd();

						#elseif( (@size( listType ) & %01) = 0 )

							mov( @size( listType ) div 2, ecx );
							rep.movsw();

						#else

							mov( @size( listType ), ecx );
							rep.movsb();

						#endif
						pop( ecx );

					#endif
					pop( esi );
						
				endif;
				pop( edi );
				popfd();						

			end getAt;

			// front-
			//	Returns a cursor value that points at the first element
			// of the list in EAX.

			method symbol.front; @noframe;
			begin front;

				mov( this.head, eax );
				ret();

			end front;


			// back-
			//	Returns a cursor value corresponding to the point beyond
			//	the end of the list (for lists, this is the value NULL).

			method symbol.back; @noframe;
			begin back;

				mov( NULL, eax );
				ret();

			end back;


			// atFront
			//	Compares the cursor passed as a parameter against the
			//	start of the list and sets the zero flag if they
			//	are equal (that is, the cursor points at the start
			//	of the list).

			method symbol.atFront( cursor:cursorType ); @noframe;
			begin atFront;

				push( eax );
				mov( [esp+@offset(cursor)], eax );
				cmp( eax, this.head );
				pop( eax );
				ret();

			end atFront;


			// atBack
			//	Compares the cursor passed as a parameter against the
			//	end of the list and sets the zero flag it points
			//	beyond the end of the list (denoted by a NULL pointer).

			method symbol.atBack( cursor:cursorType ); @noframe;
			begin atBack;

				push( eax );
				mov( [esp+@offset(cursor)], eax );
				cmp( eax, NULL );
				pop( eax );
				ret();

			end atBack;
			
			
			// atIndex-
			//	Returns a cursor (in EAX) to the nTH node in the list.
			
			method symbol.atIndex( n:uns32 in eax ); @noframe;
			begin atIndex;

				if( eax >= this.numElements ) then
				
					xor( eax, eax );	// Return NULL to mark endData
					
				else
				
					// Locate the nTH item in the list:
					
					push( ecx );
					mov( eax, ecx );
					mov( this.head, eax );
					while( ecx <> 0 ) do
					
						mov( (type nodeType [eax]).next, eax );
						sub( 1, ecx );
						
					endwhile;
					pop( ecx );
					
				endif;
				ret();
			
			end atIndex;
			

		#endif




		// getRef-
		//	Computes the address of node n in the list
		//	and returns this value in EAX. If n exceeds the
		//	list bounds, then at returns NULL.

		method symbol.getRef( n:uns32 in eax ); @noframe;
		begin getRef;

			mov( n, eax );
			if( eax >= this.numElements ) then
			
				xor( eax, eax );	// Return NULL
				
			else
			
				// Locate the nTH item in the list:
				
				push( ecx );
				mov( eax, ecx );
				mov( this.head, eax );
				while( ecx <> 0 ) do
				
					mov( (type nodeType [eax]).next, eax );
					sub( 1, ecx );
					
				endwhile;
				pop( ecx );
				lea( eax, (type nodeType [eax]).data );
				
			endif;
			ret();

		end getRef;


		// getVal-
		//	Copies the nTH node's data to the specified variable.
		//  If n is out of range, no action is taken.
													  
		method symbol.getVal( n:uns32; var dest:listType );
			@nodisplay; @noalignstack;
		begin getVal;

			push( ecx );
			assert( dest <> NULL );
			mov( n, ecx );
			if( ecx < this.numElements ) then

				push( eax );
				mov( this.head, eax );
				while( ecx <> 0 ) do
				
					mov( (type nodeType [eax]).next, eax );
					sub( 1, ecx );
					
				endwhile;

				push( esi );
				lea( esi, (type nodeType [eax]).data );
				mov( dest, edi );
				#if( @size( listType ) = 1 )

					movsb();

				#elseif( @size( listType ) = 2 )

					movsw();

				#elseif( @size( listType ) = 4 )

					movsd();

				#elseif( @size( listType ) = 8 )

					movsd();
					movsd();

				#elseif( @size( listType ) = 16 )

					movsd();
					movsd();

				#else

					pushfd();
					cld();
					#if( (@size( listType ) & %11) = 0 )

						mov( @size( listType ) div 4, ecx );
						rep.movsd();

					#elseif( (@size( listType ) & %01) = 0 )

						mov( @size( listType ) div 2, ecx );
						rep.movsw();

					#else

						mov( @size( listType ), ecx );
						rep.movsb();

					#endif
					popfd();

				#endif
				pop( esi );
				pop( eax );
					
			endif;
			pop( ecx );

		end getVal;



		#if( (symbol.capabilities_c & stl.supportsObjSwap_c) <> 0 )

			// swapObj-
			//	Swaps another object with this one:

			method symbol.swapObj( var obj:symbol ); 
				@nodisplay; @nostackalign;

			const
				objEBX:text := "(type " + @string( symbol ) + " [ebx])";

			begin swapObj;


				push( eax );
				push( ebx );
				push( ecx );

				mov( obj, ebx );
				mov( this.isAlloc, al );
				mov( objEBX.isAlloc, ah );
				mov( al, objEBX.isAlloc );
				mov( ah, this.isAlloc );

				mov( this.typeName, ecx );
				mov( objEBX.typeName, eax );
				mov( ecx, objEBX.typeName );
				mov( eax, this.typeName );

				mov( this.numElements, ecx );
				mov( objEBX.numElements, eax );
				mov( ecx, objEBX.numElements );
				mov( eax, this.numElements );

				mov( this.head, ecx );
				mov( objEBX.head, eax );
				mov( ecx, objEBX.head );
				mov( eax, this.head );

				mov( this.tail, ecx );
				mov( objEBX.tail, eax );
				mov( ecx, objEBX.tail );
				mov( eax, this.tail );

				pop( ecx );
				pop( ebx );
				pop( eax );

			end swapObj;

		#endif

		#if( (symbol.capabilities_c & stl.supportsElementSwap_c) <> 0 )

			// swapElements-
			// Exchange the data between two nodes.
			// Does *not* affect the node meta-data.
			//
			// If we were always guaranteed that the two nodes were on some
			// list, then we could just swap links and have a really efficient
			// data swap. Alas, there are problems with nodes at the beginning
			// and end of the list and problems with nodes that aren't on
			// any list.
			
			method symbol.swapElements
			( 
				first	:cursorType; 
				second	:cursorType 
			);
				@noframe;
				
			begin swapElements;
			
				push( ecx );
				push( esi );
				push( edi );
				
				#if( @size( listType ) = 1 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					mov( [esi], cl );
					mov( [edi], ch );
					mov( cl, [edi] );
					mov( ch, [esi] );
					 
				#elseif( @size( listType ) = 2 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], ax );
					mov( [edi], cx );
					mov( ax, [edi] );
					mov( cx, [esi] );
					pop( eax );
					
				#elseif( @size( listType ) = 4 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], eax );
					mov( [edi], ecx );
					mov( eax, [edi] );
					mov( ecx, [esi] );
					pop( eax );
					
				#elseif( @size( listType ) = 8 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], eax );
					mov( [edi], ecx );
					mov( eax, [edi] );
					mov( ecx, [esi] );
					mov( [esi+4], eax );
					mov( [edi+4], ecx );
					mov( eax, [edi+4] );
					mov( ecx, [esi+4] );
					pop( eax );
					
				#elseif( @size( listType ) = 16 )
				
					mov( [esp+@offset(first)+8], edi );
					mov( [esp+@offset(first)+8], esi );
					push( eax );
					mov( [esi], eax );
					mov( [edi], ecx );
					mov( eax, [edi] );
					mov( ecx, [esi] );
					mov( [esi+4], eax );
					mov( [edi+4], ecx );
					mov( eax, [edi+4] );
					mov( ecx, [esi+4] );
					mov( [esi+8], eax );
					mov( [edi+8], ecx );
					mov( eax, [edi+8] );
					mov( ecx, [esi+8] );
					mov( [esi+12], eax );
					mov( [edi+12], ecx );
					mov( eax, [edi+12] );
					mov( ecx, [esi+12] );
					pop( eax );
					
				#elseif( (@size( listType ) & %11) = 0 )
				
					shr( 2, ecx );
					rep.movsd();
					
				#elseif( (@size( listType ) & %1) = 0 )
				
					shr( 1, ecx );
					rep.movsw();
					
				#else
				
					rep.movsb();
					
				#endif

					
				pop( edi );
				pop( esi );
				pop( ecx );
				ret( 8 );
				
			end swapElements;

		#endif


		// Comparisons-
		//	Handle the built-in types, but require the user to
		//	supply comparisons for other types.

		#if( (symbol.capabilities_c & stl.supportsCompare_c) <> 0 )

			stl.stdCompares( listType )

		#endif

				



		// Set us back to the TYPE section:

		type

	#endif

#endmacro

///////////////////////////////////////////////////////////////////////////////
//
// table-
//
//	Class template for the hash table type.



#macro table( rawTableType, specificTraits[] ):
	symbol,
	tableType,
	section,
	cursorType,
	ptrType,
	nodeType,
	temp;

	@forward( symbol );
	tableType : rawTableType;

	?section := @section;
	#if( (section & @global:hla.inType) <> @global:hla.inType )

		#error( "TABLE declarations may only appear in a TYPE section" )

	#else


		// Create a pointer type for this class:

		?temp 			:string := @string( @text( symbol ) );
		?ptrType 		:string := "p_" + temp;
		?ptrType		:text   := ptrType;
		ptrType			:pointer to symbol;
		
		// Create a node type for the elements of the table:

		?nodeType 		:string := temp + "_node";
		?nodeType		:text   := nodeType;
		nodeType		:record

							// Warning! Table algorithms
							// rely upon the fact that
							// link is the first field
							// at offset zero in this record.

							link	:pointer to nodeType;	// Hash bucket link
							
							next	:pointer to nodeType;	// Used by cursors
							prev	:pointer to nodeType;	// and iterators
							
							key		:string;
							isAlloc	:boolean;
							
							align(4);

							data	:tableType;

						 endrecord;
		
		
		// Create a cursor type for this class:

		?cursorType 	:string := temp + "_cursor";
		?cursorType		:text   := cursorType;
		cursorType		:pointer to nodeType;
		

		// Create the actual class:

		symbol:
			class inherits( stl.Container );

				// Set up the default capabilities for a table:

				val
					hierarchy_c := hierarchy_c | stl.isTable_c;

					capabilities_c := 
							capabilities_c 
							#if( @isClass( tableType ))
								| stl.elementsAreObjects_c
							#endif

						|	stl.supportsForeach_c			
						|	stl.supportsrForeach_c			
						|	stl.supportsCursor_c			
						|	stl.supportsObjSwap_c;

						
					// Okay, process any specific capabilities provided in
					// the table declaration:
					
					capabilities_c := 
						stl.parseCapabilities
						( 
							capabilities_c, 
							specificTraits 
						);


					// Set up the default performance traits:

					performance_c :=
							performance_c
						|	stl.fastSearch_c;				

						
					// Okay, process any specific performance traits
					//  provided in the table declaration:
					
					performance_c := 
						stl.parsePerformance
						( 
							performance_c, 
							specificTraits 
						);


					// Just as a safety net, let's verify that all
					// the user-specified traits are valid:

					stl.checkTraits
					( 
						specificTraits, 
						[[stl.performanceNames],[stl.capabilityNames]] 
					);


				readonly
					typeName_ro	:string := temp;
					
				var
					align(4);
					HashMask	:dword;
					HashCnt		:uns32;
					HashTable	:dword;
					
					// The following exist so we can iterator through
					// the nodes in the hash table:
					
					head		:cursorType;
					tail		:cursorType;


				// Public entities begin here:
				//
				// Constructor and destructor.
				// Note that all table types have a constructor and destructor

				procedure create( HashSize:uns32 );
				method destroy;
				
				// _hash-
				//	Internal procedure used to compute a hash function.
				
				method _hash; @returns( "eax" );
				
				
				// getRef-
				// getVal-
				//	Retrieve values in the hash table:
				
				method getRef( key:string in eax ); @returns( "eax" );
				method getVal( key:string; var dest:tableType );
				


				// iterators:

				#if( (symbol.capabilities_c & stl.supportsForeach_c) <> 0 )

					iterator forEachElement;

				#endif

				#if( (symbol.capabilities_c & stl.supportsrForeach_c) <> 0 )

					iterator rForEachElement;

				#endif

				#if( (symbol.capabilities_c & stl.supportsInsert_c) <> 0 )
				
					method insertRef( var toInsert:vectorType; key:string );
					method insertVal( toInsert:vectorType; key:string );

				#endif


				#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

					// Cursor manipulation routines:

					method nextCursor( var cursor:cursorType );
					method prevCursor( var cursor:cursorType );
					method beginCursor( var cursor:cursorType );
					method endCursor( var cursor:cursorType );
					method front; @returns( "eax" );
					method back; @returns( "eax" );

					method atBack( cursor:cursorType ); @returns( "@z" );
					method atFront( cursor:cursorType ); @returns( "@z" );
					method at( cursor:cursorType in eax ); @returns( "eax" );
					method atIndex( key:string ); @returns( "eax" );
					
					method getAt( cursor:cursorType; var dest:tableType );


				#endif

				 
				// Element & object swapping:

				#if( (symbol.capabilities_c & stl.supportsObjSwap_c) <> 0 )
		
					method swapObj( var obj:symbol );

				#endif


				// Comparisons:
				
				#if( (capabilities_c & stl.supportsCompare_c) <> 0 )

					method isEqual
					( 
						var left:tableType; 
						var right:tableType 
					);  @returns( "al" );

					method isLess
					( 
						var left:tableType; 
						var right:tableType 
					);  @returns( "al" );


					method isLessEqual
					( 
						var left:tableType; 
						var right:tableType 
					);  @returns( "al" );

				#endif

								

				// Output method

				#if( (capabilities_c & stl.supportsOutput_c) <> 0 )

					override method a_toString;

				#endif


			endclass;

		// Emit the VMT for this class:

		static
			vmt( symbol );
			
			
		// _hash-
		//
		// This is a function that attempts to translate the
		// string pointed at by ebx to an unsigned integer
		// in the range 0..HashCnt-1.  This function attempts
		// to randomly (and uniformly) distribute its return
		// values based on typical input strings.
		//
		// Note that this function generates a semi-unique
		// value from the string based upon its length and
		// all the characters in the string.	

		method symbol._hash; @nodisplay; @noframe;
		begin _hash;

			mov( (type str.strRec [ebx]).length, ecx );
			mov( ecx, eax );
			xchg( al, ah );
			xor( edx, edx );
			while( ecx > 0 ) do
			
				mov( [ebx], dl );
				rol( 3, ax );
				add( edx, eax );
				dec( ecx );
				inc( ebx );
				
			endwhile;

			// If any bits were shifted into the H.O. word
			// of eax, facter them in here.

			mov( eax, edx );
			bswap( eax );
			xor( edx, eax );
			
			// Take the mod of the result with the
			// size of the table.
			
			and( (type symbol [esi]).HashMask, eax );
			ret();
			
		end _hash;
		
		
		// Constructor for the table class.

		procedure symbol.create( HashSize:uns32 ); @nodisplay; @nostackalign;
		begin create;

			push( eax );
			push( ecx );
			push( edi );
			pushfd();
			
			if( esi = 0 ) then
			
				malloc( @size( symbol ) );
				mov( eax, esi );
				
			endif;
			mov( &symbol._VMT_, this._pVMT_ );
			
			// Save away the HashSize value and then
			// allocate 4*HashSize bytes for the Hash Table.
			
			mov( HashSize, eax );
			if( eax > $1_0000 ) then
			
				raise( ex.ValueOutOfRange );
				
			endif;
			
			// Runtime information:
			// Begin by initializing the standard boolean variables with
			// their respective values for a list.
			
			mov( symbol.capabilities_c, this.capabilities );
			mov( symbol.performance_c, this.performance );
			mov( symbol.hierarchy_c, this.hierarchy );			

			// Other table specific-initialization:

			lea( eax, "table" );
			mov( eax, this.containerName );

			mov( symbol.typeName_ro, eax );
			mov( eax, this.typeName );
			
			// Start off with an empty list of nodes in this table:
			
			mov( NULL, this.head );
			mov( NULL, this.tail );

			
			// Calculate the size of the hash table
			// as the first power of two that
			// is greater than HashSize.
			
			mov( 1, eax );
			while( HashSize <> 0 ) do

				shl( 1, eax );
				shr( 1, HashSize );
					
			endwhile;
			mov( eax, this.HashCnt );

			// Compute a mask we can and with
			// a value to produce "value mod HashCnt".
			
			dec( eax );
			mov( eax, this.HashMask );

			// Allocate storage for the array of
			// pointers into the hash table.
				
			inc( eax );
			mov( eax, ecx );
			shl( 2, eax );
			malloc( eax );
			mov( eax, this.HashTable );
			
			// Set each of the pointers to NULL.
			
			mov( eax, edi );
			xor( eax, eax );
			cld();
			rep.stosd();
			
			popfd();
			pop( edi );
			pop( ecx );	
			pop( eax );
			
		end create;



		// Destructor for the table class (note that it is the caller's
		// responsibility to clean up all nodes in the class before
		// calling this guy).

		method symbol.destroy; @nodisplay; @noalignstack;
		begin destroy;

			push( eax );
			if( this.isAlloc ) then
			
				mem.free( esi );
				
			endif;
			pop( eax );
						
		end destroy;
			
	
		
				
	
		#if( (symbol.capabilities_c & stl.supportsObjSwap_c) <> 0 )

			// swapObj-
			//	Swaps another table object with this one:

			method symbol.swapObj( var obj:symbol ); 
				@nodisplay; @nostackalign;

			const
				objEBX:text := "(type " + @string( symbol ) + " [ebx])";

			begin swapObj;


				push( eax );
				push( ebx );
				push( ecx );

				mov( obj, ebx );
				mov( this.isAlloc, al );
				mov( objEBX.isAlloc, ah );
				mov( al, objEBX.isAlloc );
				mov( ah, this.isAlloc );

				mov( this.typeName, ecx );
				mov( objEBX.typeName, eax );
				mov( ecx, objEBX.typeName );
				mov( eax, this.typeName );

				mov( this.numElements, ecx );
				mov( objEBX.numElements, eax );
				mov( ecx, objEBX.numElements );
				mov( eax, this.numElements );

				mov( this.HashMask, ecx );
				mov( objEBX.HashMask, eax );
				mov( ecx, objEBX.HashMask );
				mov( eax, this.HashMask );

				mov( this.HashCnt, ecx );
				mov( objEBX.HashCnt, eax );
				mov( ecx, objEBX.HashCnt );
				mov( eax, this.HashCnt );

				mov( this.HashTable, ecx );
				mov( objEBX.HashTable, eax );
				mov( ecx, objEBX.HashTable );
				mov( eax, this.HashTable );


				pop( ecx );
				pop( ebx );
				pop( eax );

			end swapObj;

		#endif
		
		
		
		
		// getRef-                                      
		//                                              
		// This method searches for the specified string
		// in the hash table.  If it finds the string,  
		// it returns a pointer to the data at the node   
		// holding the string in the EAX register.  If it   
		// does not find the string, it returns NULL in the      
		// EAX register.                                

		method symbol.getRef( key:string in eax ); @nodisplay; @nostackalign;
		begin getRef;

			pushfd();
			push( ebx );
			push( ecx );
			push( edx );
			push( edi );
			push( esi );
			
			cld();
			
			// Compute the hash value for this string and
			// put it into the EAX register:
			
			mov( key, ebx );
			this._hash();
			mov( this.HashTable, ebx );
			
			// Save a pointer to the string we're searching for in ESI.
			// Also save the string length in ECX.
			
			mov( key, esi );
			mov( (type str.strRec [esi]).length, ecx );
			
			
			// Find the last node in the current hash chain
			// (which is a list of nodeType records).
			// Sneaky trick in play here!  EBX+EAX*4 is a
			// pointer into the array of pointers to the
			// nodeType lists.  Therefore, the first stmt in the
			// while loop below does not access a nodeType
			// object, instead it accesses a field of the
			// array of pointers.  However, the "link" field
			// is at offset zero so this code correctly fetches
			// the pointer.  For this code to continue to operate
			// properly, the link field of the nodeType
			// record must be at offset zero.
			
			lea( ebx, [ebx+eax*4] );
			forever
			
				mov( (type nodeType [ebx]).link, eax );
				breakif( eax = NULL );
				mov( eax, ebx );
			
				mov( (type nodeType [ebx]).key, edi );
				
				// If the lengths are unequal, the strings cannot match!
				
				if( ecx = (type str.strRec [edi]).length ) then
				
					push( esi );
					push( ecx );
					repe.cmpsb();
					pop( ecx );
					pop( esi );
					if( @z ) then
					
						lea( eax, (type nodeType [eax]).data );
						break;
						
					endif;
					
				endif;
				
			endfor;

			pop( esi );
			pop( edi );
			pop( edx );
			pop( ecx );
			pop( ebx );
			popfd();
			
		end getRef;
				
		
		
		// getVal-                                      
		//                                              
		// This method searches for the specified string
		// in the hash table.  If it finds the string,  
		// returns the data value found at that table entry
		// in the second parameter passed by reference.
		// If the entry is not found in the table, then this
		// function has no effect on the dest parameter.                                

		method symbol.getVal( key:string; var dest:tableType  ); 
			@nodisplay; @nostackalign;
			
		begin getVal;

			pushfd();
			push( ebx );
			push( ecx );
			push( edx );
			push( edi );
			push( esi );
			
			cld();
			
			// Compute the hash value for this string and
			// put it into the EAX register:
			
			mov( key, ebx );
			this._hash();
			mov( this.HashTable, ebx );
			
			// Save a pointer to the string we're searching for in ESI.
			// Also save the string length in ECX.
			
			mov( key, esi );
			mov( (type str.strRec [esi]).length, ecx );
			
			
			// Find the last node in the current hash chain
			// (which is a list of nodeType records).
			// Sneaky trick in play here!  EBX+EAX*4 is a
			// pointer into the array of pointers to the
			// nodeType lists.  Therefore, the first stmt in the
			// while loop below does not access a nodeType
			// object, instead it accesses a field of the
			// array of pointers.  However, the "link" field
			// is at offset zero so this code correctly fetches
			// the pointer.  For this code to continue to operate
			// properly, the link field of the nodeType
			// record must be at offset zero.
			
			lea( ebx, [ebx+eax*4] );
			forever
			
				mov( (type nodeType [ebx]).link, eax );
				breakif( eax = NULL );
				mov( eax, ebx );
			
				mov( (type nodeType [ebx]).key, edi );
				
				// If the lengths are unequal, the strings cannot match!
				
				if( ecx = (type str.strRec [edi]).length ) then
				
					push( esi );
					push( ecx );
					repe.cmpsb();
					pop( ecx );
					pop( esi );
					if( @z ) then
					
						lea( eax, (type nodeType [eax]).data );
						push( esi );
						lea( esi, (type nodeType [eax]).data );
						mov( dest, edi );
						#if( @size( tableType ) = 1 )

							movsb();

						#elseif( @size( tableType ) = 2 )

							movsw();

						#elseif( @size( tableType ) = 4 )

							movsd();

						#elseif( @size( tableType ) = 8 )

							movsd();
							movsd();

						#elseif( @size( tableType ) = 16 )

							movsd();
							movsd();

						#else

							pushfd();
							cld();
							#if( (@size( tableType ) & %11) = 0 )

								mov( @size( tableType ) div 4, ecx );
								rep.movsd();

							#elseif( (@size( tableType ) & %01) = 0 )

								mov( @size( tableType ) div 2, ecx );
								rep.movsw();

							#else

								mov( @size( tableType ), ecx );
								rep.movsb();

							#endif
							popfd();

						#endif
						pop( esi );
						
						break;
						
					endif;
					
				endif;
				
			endfor;

			pop( esi );
			pop( edi );
			pop( edx );
			pop( ecx );
			pop( ebx );
			popfd();
			
		end getVal;
		
		
		   

		#if( (symbol.capabilities_c & stl.supportsForeach_c) <> 0 )

			// The following iterators will sequence through
			// all the elements of the table. On each iteration
			// of the corresponding foreach loop, this iterator
			// will return the *address* of the respective table
			// data element.
			//
			// forEachElement returns items from the start to the end of the 
			// object, rForEachElement returns items from the end to the start.

			iterator symbol.forEachElement;
				@nodisplay; @noalignstack;
			begin forEachElement;

				push( eax );
				push( edx );
				mov( this.head, edx );
				while( edx <> NULL ) do

					push( esi );
					push( edx );
					lea( eax, (type nodeType [edx]).data );
					yield();
					pop( edx );
					pop( esi );
					mov( (type nodeType [edx]).next, edx );

				endwhile;
				pop( edx );
				pop( eax );

			end forEachElement;


		#endif
		
		#if( (symbol.capabilities_c & stl.supportsrForeach_c) <> 0 )
						

			iterator symbol.rForEachElement;
				@nodisplay; @noalignstack;
			begin rForEachElement;

				push( eax );
				push( edx );
				mov( this.tail, edx );
				while( edx <> NULL ) do

					push( esi );
					push( edx );
					lea( eax, (type nodeType [edx]).data );
					yield();
					pop( edx );
					pop( esi );
					mov( (type nodeType [edx]).prev, edx );

				endwhile;
				pop( edx );
				pop( eax );

			end rForEachElement;
					
		#endif


		
				
				
		#if( (symbol.capabilities_c & stl.supportsCursor_c) <> 0 )

			// nextCursor-
			//	Adjusts the cursor to point at the next element of the
			//	table's list and returns this pointer in EAX. Note that NULL
			//	is used to mark the end of the table list, so if the cursor
			//	contains NULL upon entry, this code simply returns with
			// 	cursor still containing NULL.

			method symbol.nextCursor( var cursor:cursorType ); @noframe;
			begin nextCursor;

				push( eax );
				mov( [esp+@offset( cursor )], eax );
				assert( eax <> NULL );
				
				push( ebx );
				mov( [eax], ebx );
				if( ebx <> NULL ) then
				
					mov( (type nodeType [ebx]).next, ebx );
				
				endif;
				mov( ebx, [eax] );
				pop( ebx );
				pop( eax );
				ret( 4 );

			end nextCursor;



			// prevCursor-
			//	Adjust the cursor to point at the previous element in the table.
			//	If doing this would position the cursor before the start of the
			//	table, then this just sets the cursor position to the start of
			//	the table. If cursor is a variable containing NULL, then this
			//	code does not modify its value (even though it's technically
			//	an illegal value).

			method symbol.prevCursor( var cursor:cursorType ); @noframe;
			begin prevCursor;


				push( eax );
				mov( [esp+@offset( cursor )], eax );
				assert( eax <> NULL );
				push( ebx );
				mov( [eax], ebx );
				if( ebx <> this.head && ebx <> NULL ) then
				
					mov( (type nodeType [ebx]).prev, ebx );
				
				endif;
				mov( ebx, [eax] );
				pop( ebx );
				pop( eax );
				ret( 4 );


			end prevCursor;



			// beginCursor-
			//	Puts a pointer to the start of the table in cursor:

			method symbol.beginCursor( var cursor:cursorType ); @noframe;
			begin beginCursor;

				push( eax );
				mov( [esp+@offset( cursor )], eax );
				mov( this.head, [eax] );
				pop( eax );
				ret();

			end beginCursor;

			// endCursor-
			//	Puts a pointer to the end of the table in cursor:

			method symbol.endCursor( var cursor:cursorType ); @noframe;
			begin endCursor;

				push( eax );
				mov( [esp+@offset( cursor )], eax );
				mov( NULL, (type dword [eax]) );
				pop( eax );
				ret();

			end endCursor;

			// at-
			//	Moves the address of the data element referenced by the
			// cursor passed as the argument into the EAX register.

			method symbol.at( cursor:cursorType in eax ); @noframe;
			begin at;

				lea( eax, (type nodeType [eax]).data );
				ret();

			end at;




			// getAt-
			//	Copies the data item specified by the cursor to
			//	the variable specified by the second argument.
			//  If cursor is out of range (NULL), no action is taken.
														  
			method symbol.getAt( cursor:cursorType; var dest:tableType );
				@nodisplay; @noalignstack;
			begin getAt;

				pushfd();
				push( edi );
				cld();
				mov( cursor, edi );
				if( edi <> NULL ) then

					push( esi );
					lea( esi, (type nodeType [edi]).data );
					mov( dest, edi );
					#if( @size( tableType ) = 1 )

						movsb();

					#elseif( @size( tableType ) = 2 )

						movsw();

					#elseif( @size( tableType ) = 4 )

						movsd();

					#elseif( @size( tableType ) = 8 )

						movsd();
						movsd();

					#elseif( @size( tableType ) = 16 )

						movsd();
						movsd();
						movsd();
						movsd();

					#else

						push( ecx );
						#if( (@size( tableType ) & %11) = 0 )

							mov( @size( tableType ) div 4, ecx );
							rep.movsd();

						#elseif( (@size( tableType ) & %01) = 0 )

							mov( @size( tableType ) div 2, ecx );
							rep.movsw();

						#else

							mov( @size( tableType ), ecx );
							rep.movsb();

						#endif
						pop( ecx );

					#endif
					pop( esi );
						
				endif;
				pop( edi );
				popfd();						

			end getAt;

			// front-
			//	Returns a cursor value that points at the first element
			// of the table in EAX.

			method symbol.front; @noframe;
			begin front;

				mov( this.head, eax );
				ret();

			end front;


			// back-
			//	Returns a cursor value corresponding to the point beyond
			//	the end of the table (for tables, this is the value NULL).

			method symbol.back; @noframe;
			begin back;

				mov( NULL, eax );
				ret();

			end back;


			// atFront
			//	Compares the cursor passed as a parameter against the
			//	start of the table and sets the zero flag if they
			//	are equal (that is, the cursor points at the start
			//	of the table).

			method symbol.atFront( cursor:cursorType ); @noframe;
			begin atFront;

				push( eax );
				mov( [esp+@offset(cursor)], eax );
				cmp( eax, this.head );
				pop( eax );
				ret();

			end atFront;


			// atBack
			//	Compares the cursor passed as a parameter against the
			//	end of the table and sets the zero flag it points
			//	beyond the end of the table (denoted by a NULL pointer).

			method symbol.atBack( cursor:cursorType ); @noframe;
			begin atBack;

				push( eax );
				mov( [esp+@offset(cursor)], eax );
				cmp( eax, NULL );
				pop( eax );
				ret();

			end atBack;
			
			
			
			// atIndex-
			//	Returns a cursor (in EAX) to the node specified
			// 	by the key passed as the parameter.
			
			method symbol.atIndex( key:string ); @nodisplay; @nostackalign;
			begin atIndex;
			
				push( ebx );
				push( ecx );
				push( edx );
				push( esi );

				// Compute the hash value for this string and
				// put it into the EAX register:
				
				mov( key, ebx );
				this._hash();
				mov( this.HashTable, ebx );
				
				// Save a pointer to the string we're searching for in ESI.
				// Also save the string length in ECX.
				
				mov( key, esi );
				mov( (type str.strRec [esi]).length, ecx );
				
				
				// Find the last node in the current hash chain
				// (which is a list of nodeType records).
				// Sneaky trick in play here!  EBX+EAX*4 is a
				// pointer into the array of pointers to the
				// nodeType lists.  Therefore, the first stmt in the
				// while loop below does not access a nodeType
				// object, instead it accesses a field of the
				// array of pointers.  However, the "link" field
				// is at offset zero so this code correctly fetches
				// the pointer.  For this code to continue to operate
				// properly, the link field of the nodeType
				// record must be at offset zero.
				
				lea( ebx, [ebx+eax*4] );
				forever
				
					mov( (type nodeType [ebx]).link, eax );
					breakif( eax = NULL );
					mov( eax, ebx );
				
					mov( (type nodeType [ebx]).key, edi );
					
					// If the lengths are unequal, the strings cannot match!
					
					if( ecx = (type str.strRec [edi]).length ) then
					
						push( esi );
						push( ecx );
						repe.cmpsb();
						pop( ecx );
						pop( esi );
						breakif( @z );
						
					endif;
					
				endfor;
				pop( esi );
				pop( edx );
				pop( ecx );
				pop( ebx );
						
			end atIndex;
			

		#endif
				
	#endif
	
#endmacro			


/////////////////////////////////////////////////////////////////////////////



end stl;
