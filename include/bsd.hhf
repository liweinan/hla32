#if( ! @defined( bsd_hhf ))
?bsd_hhf := true;

#includeonce( "hla.hhf" )

#if( ! @defined( errno_hhf ))
?errno_hhf := true;

namespace errno; @fast;

  const
	eperm				:= 1;		/* Operation not permitted */
	enoent				:= 2;		/* No such file or directory */
	esrch				:= 3;		/* No such process */
	eintr				:= 4;		/* Interrupted system call */
	eio					:= 5;		/* Input/output error */
	enxio				:= 6;		/* Device not configured */
	e2big				:= 7;		/* Argument list too long */
	enoexec				:= 8;		/* Exec format error */
	ebadf				:= 9;		/* Bad file descriptor */
	echild				:= 10;		/* No child processes */
	edeadlk				:= 11;		/* Resource deadlock avoided */
	enomem				:= 12;		/* Cannot allocate memory */
	eacces				:= 13;		/* Permission denied */
	efault				:= 14;		/* Bad address */
	enotblk				:= 15;		/* Block device required */
	ebusy				:= 16;		/* Device busy */
	eexist				:= 17;		/* File exists */
	exdev				:= 18;		/* Cross-device link */
	enodev				:= 19;		/* Operation not supported by device */
	enotdir				:= 20;		/* Not a directory */
	eisdir				:= 21;		/* Is a directory */
	einval				:= 22;		/* Invalid argument */
	enfile				:= 23;		/* Too many open files in system */
	emfile				:= 24;		/* Too many open files */
	enotty				:= 25;		/* Inappropriate ioctl for device */
	etxtbsy				:= 26;		/* Text file busy */
	efbig				:= 27;		/* File too large */
	enospc				:= 28;		/* No space left on device */
	espipe				:= 29;		/* Illegal seek */
	erofs				:= 30;		/* Read-only filesystem */
	emlink				:= 31;		/* Too many links */
	epipe				:= 32;		/* Broken pipe */
	edom				:= 33;		/* Numerical argument out of domain */
	erange				:= 34;		/* Result too large */
	eagain				:= 35;		/* Resource temporarily unavailable */
	ewouldblock			:= eagain;	/* Operation would block */
	einprogress			:= 36;		/* Operation now in progress */
	enotsock			:= 38;		/* Socket operation on non-socket */
	edestaddrreq		:= 39;		/* Destination address required */
	emsgsize			:= 40;		/* Message too long */
	eprototype			:= 41;		/* Protocol wrong type for socket */
	enoprotoopt			:= 42;		/* Protocol not available */
	eprotonosupport		:= 43;		/* Protocol not supported */
	esocktnosupport		:= 44;		/* Socket type not supported */
	eopnotsupp			:= 45;		/* Operation not supported */
	enotsup				:= eopnotsupp;	/* Operation not supported */
	epfnosupport		:= 46;		/* Protocol family not supported */
	eafnosupport		:= 47;		/* Address family not supported by protocol family */
	eaddrinuse			:= 48;		/* Address already in use */
	eaddrnotavail		:= 49;		/* Can't assign requested address */
	enetdown			:= 50;		/* Network is down */
	enetunreach			:= 51;		/* Network is unreachable */
	enetreset			:= 52;		/* Network dropped connection on reset */
	econnaborted		:= 53;		/* Software caused connection abort */
	econnreset			:= 54;		/* Connection reset by peer */
	enobufs				:= 55;		/* No buffer space available */
	eisconn				:= 56;		/* Socket is already connected */
	enotconn			:= 57;		/* Socket is not connected */
	eshutdown			:= 58;		/* Can't send after socket shutdown */
	etoomanyrefs		:= 59;		/* Too many references: can't splice */
	etimedout			:= 60;		/* Operation timed out */
	econnrefused		:= 61;		/* Connection refused */
	eloop				:= 62;		/* Too many levels of symbolic links */
	enametoolong		:= 63;		/* File name too long */
	ehostdown			:= 64;		/* Host is down */
	ehostunreach		:= 65;		/* No route to host */
	enotempty			:= 66;		/* Directory not empty */
	eproclim			:= 67;		/* Too many processes */
	eusers				:= 68;		/* Too many users */
	edquot				:= 69;		/* Disc quota exceeded */
	estale				:= 70;		/* Stale NFS file handle */
	eremote				:= 71;		/* Too many levels of remote in path */
	ebadrpc				:= 72;		/* RPC struct is bad */
	erpcmismatch		:= 73;		/* RPC version wrong */
	eprogunavail		:= 74;		/* RPC prog. not avail */
	eprogmismatch		:= 75;		/* Program version wrong */
	eprocunavail		:= 76;		/* Bad procedure for program */
	enolck				:= 77;		/* No locks available */
	enosys				:= 78;		/* Function not implemented */
	eftype				:= 79;		/* Inappropriate file type or format */
	eauth				:= 80;		/* Authentication error */
	eneedauth			:= 81;		/* Need authenticator */
	eidrm				:= 82;		/* Identifier removed */
	enomsg				:= 83;		/* No message of desired type */
	eoverflow			:= 84;		/* Value too large to be stored in data type */
	ecanceled			:= 85;		/* Operation canceled */
	eilseq				:= 86;		/* Illegal byte sequence */
	enoattr				:= 87;		/* Attribute not found */
	edoofus				:= 88;		/* Programming error */
	ebadmsg				:= 89;		/* Bad message */
	emultihop			:= 90;		/* Multihop attempted */
	enolink				:= 91;		/* Link has been severed */
	eproto				:= 92;		/* Protocol error */
	elast				:= 92;		/* Must be equal largest errno */
	
		
end errno;

#endif

namespace bsd; @fast;

	
	#macro pushregs;
	
		push( ebx );
		push( ecx );
		push( edx );
		push( esi );
		push( edi );
		
	#endmacro
	
	#macro popregs;
	
		pop( edi );
		pop( esi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		
	#endmacro
		
	#macro saveregs;
	
		mov( ebx, ebxSave );
		mov( ecx, ecxSave );
		mov( edx, edxSave );
		mov( esi, esiSave );
		mov( edi, ediSave );
		
	#endmacro
	
	#macro restoreregs;
	
		mov( ebxSave, ebx );
		mov( ecxSave, ecx );
		mov( edxSave, edx );
		mov( esiSave, esi );
		mov( ediSave, edi );
		
	#endmacro
		

const
	sys_syscall				:= 0;
	sys_exit				:= 1;
	sys_fork				:= 2;
	sys_read				:= 3;
	sys_write				:= 4;
	sys_open				:= 5;
	sys_close				:= 6;
	sys_wait4				:= 7;
	sys_old_creat			:= 8;
	sys_link				:= 9;
	sys_unlink				:= 10;
	sys_obs_execv			:= 11;
	sys_chdir				:= 12;
	sys_fchdir				:= 13;
	sys_mknod				:= 14;
	sys_chmod				:= 15;
	sys_chown				:= 16;
	sys__break				:= 17;
	sys_old_getfsstat		:= 18;
	sys_old_lseek			:= 19;
	sys_getpid				:= 20;
	sys_mount				:= 21;
	sys_unmount				:= 22;
	sys_setuid				:= 23;
	sys_getuid				:= 24;
	sys_geteuid				:= 25;
	sys_ptrace				:= 26;
	sys_recvmsg				:= 27;
	sys_sendmsg				:= 28;
	sys_recvfrom			:= 29;
	sys_accept				:= 30;
	sys_getpeername			:= 31;
	sys_getsockname			:= 32;
	sys_access				:= 33;
	sys_chflags				:= 34;
	sys_fchflags			:= 35;
	sys_sync				:= 36;
	sys_kill				:= 37;
	sys_old_stat			:= 38;
	sys_getppid				:= 39;
	sys_old_lstat			:= 40;
	sys_dup					:= 41;
	sys_pipe				:= 42;
	sys_getegid				:= 43;
	sys_profil				:= 44;
	sys_ktrace				:= 45;
	sys_old_sigaction		:= 46;
	sys_getgid				:= 47;
	sys_old_sigprocmask		:= 48;
	sys_getlogin			:= 49;
	sys_setlogin			:= 50;
	sys_acct				:= 51;
	sys_old_sigpending		:= 52;
	sys_sigaltstack			:= 53;
	sys_ioctl				:= 54;
	sys_reboot				:= 55;
	sys_revoke				:= 56;
	sys_symlink				:= 57;
	sys_readlink			:= 58;
	sys_execve				:= 59;
	sys_umask				:= 60;
	sys_chroot				:= 61;
	sys_old_fstat			:= 62;
	sys_old_getkerninfo		:= 63;
	sys_old_getpagesize		:= 64;
	sys_msync				:= 65;
	sys_vfork				:= 66;
	sys_obs_vread			:= 67;
	sys_obs_vwrite			:= 68;
	sys_sbrk				:= 69;
	sys_sstk				:= 70;
	sys_old_mmap			:= 71;
	sys_vadvise				:= 72;
	sys_munmap				:= 73;
	sys_mprotect			:= 74;
	sys_madvise				:= 75;
	sys_obs_vhangup			:= 76;
	sys_obs_vlimit			:= 77;
	sys_mincore				:= 78;
	sys_getgroups			:= 79;
	sys_setgroups			:= 80;
	sys_getpgrp				:= 81;
	sys_setpgid				:= 82;
	sys_setitimer			:= 83;
	sys_old_wait			:= 84;
	sys_swapon				:= 85;
	sys_getitimer			:= 86;
	sys_old_gethostname		:= 87;
	sys_old_sethostname		:= 88;
	sys_getdtablesize		:= 89;
	sys_dup2				:= 90;
	//#91					:= 91;
	sys_fcntl				:= 92;
	sys_select				:= 93;
	//#94					:= 94;
	sys_fsync				:= 95;
	sys_setpriority			:= 96;
	sys_socket				:= 97;
	sys_connect				:= 98;
	sys_old_accept			:= 99;
	sys_getpriority			:= 100;
	sys_old_send			:= 101;
	sys_old_recv			:= 102;
	sys_old_sigreturn		:= 103;
	sys_bind				:= 104;
	sys_setsockopt			:= 105;
	sys_listen				:= 106;
	sys_obs_vtimes			:= 107;
	sys_old_sigvec			:= 108;
	sys_old_sigblock		:= 109;
	sys_old_sigsetmask		:= 110;
	sys_old_sigsuspend		:= 111;
	sys_old_sigstack		:= 112;
	sys_old_recvmsg			:= 113;
	sys_sold_sendmsg		:= 114;
	sys_obs_vtrace			:= 115;
	sys_gettimeofday		:= 116;
	sys_getrusage			:= 117;
	sys_getsockopt			:= 118;
	//#119					:= 119;
	sys_readv				:= 120;
	sys_writev				:= 121;
	sys_settimeofday		:= 122;
	sys_fchown				:= 123;
	sys_fchmod				:= 124;
	sys_old_recvfrom		:= 125;
	sys_setreuid			:= 126;
	sys_setregid			:= 127;
	sys_rename				:= 128;
	sys_old_truncate		:= 129;
	sys_old_ftruncate		:= 130;
	sys_flock				:= 131;
	sys_mkfifo				:= 132;
	sys_sendto				:= 133;
	sys_shutdown			:= 134;
	sys_socketpair			:= 135;
	sys_mkdir				:= 136;
	sys_rmdir				:= 137;
	sys_utimes				:= 138;
	sys_obs_4_2				:= 139;
	sys_adjtime				:= 140;
	sys_old_getpeername		:= 141;
	sys_old_gethostid		:= 142;
	sys_old_sethostid		:= 143;
	sys_old_getrlimit		:= 144;
	sys_old_setrlimit		:= 145;
	sys_old_killpg			:= 146;
	sys_setsid				:= 147;
	sys_quotactl			:= 148;
	sys_old_quota			:= 149;
	sys_old_getsockname		:= 150;
	//#151					:= 151;
	//#152					:= 152;
	//#153					:= 153;
	//#154					:= 154;
	sys_nfssvc				:= 155;
	sys_old_getdirentries	:= 156;
	sys_old_statfs			:= 157;
	sys_old_fstatfs			:= 158;
	//#159					:= 159;
	sys_lgetfh				:= 160;
	sys_getfh				:= 161;
	sys_getdomainname		:= 162;
	sys_setdomainname		:= 163;
	sys_uname				:= 164;
	sys_arch				:= 165;
	sys_rtprio				:= 166;
	//#167					:= 167;
	//#168					:= 168;
	sys_semsys				:= 169;
	sys_msgsys				:= 170;
	sys_shmsys				:= 171;
	//#172					:= 172;
	sys_pread				:= 173;
	sys_pwrite				:= 174;
	//#175					:= 175;
	sys_ntp_adjtime			:= 176;
	//#177					:= 177;
	//#178					:= 178;
	//#179					:= 179;
	//#180					:= 180;
	sys_setgid				:= 181;
	sys_setegid				:= 182;
	sys_seteuid				:= 183;
	//#184					:= 184;
	//#185					:= 185;
	//#186					:= 186;
	//#187					:= 187;
	sys_stat				:= 188;
	sys_fstat				:= 189;
	sys_lstat				:= 190;
	sys_pathconf			:= 191;
	sys_fpathconf			:= 192;
	//#193					:= 193;
	sys_getrlimit			:= 194;
	sys_setrlimit			:= 195;
	sys_getdirentries		:= 196;
	sys_mmap				:= 197;
	sys___syscall			:= 198;
	sys_lseek				:= 199;
	sys_truncate			:= 200;
	sys_ftruncate			:= 201;
	sys___sysctl			:= 202;
	sys_mlock				:= 203;
	sys_munlock				:= 204;
	sys_undelete			:= 205;
	sys_futimes				:= 206;
	sys_getpgid				:= 207;
	//#208					:= 208;
	sys_poll				:= 209;
	sys_lkmnosys			:= 210;
	//sys_lkmnosys			:= 211;
	//sys_lkmnosys			:= 212;
	//sys_lkmnosys			:= 213;
	//sys_lkmnosys			:= 214;
	//sys_lkmnosys			:= 215;
	//sys_lkmnosys			:= 216;
	//sys_lkmnosys			:= 217;
	//sys_lkmnosys			:= 218;
	//sys_lkmnosys			:= 219;
	sys___semctl			:= 220;
	sys_semget				:= 221;
	sys_semop				:= 222;
	//#223					:= 223;
	sys_msgctl				:= 224;
	sys_msgget				:= 225;
	sys_msgsnd				:= 226;
	sys_msgrcv				:= 227;
	sys_shmat				:= 228;
	sys_shmctl				:= 229;
	sys_shmdt				:= 230;
	sys_shmget				:= 231;
	sys_clock_gettime		:= 232;
	sys_clock_settime		:= 233;
	sys_clock_getres		:= 234;
	//#235					:= 235;
	//#236					:= 236;
	//#237					:= 237;
	//#238					:= 238;
	//#239					:= 239;
	sys_nanosleep			:= 240;
	//#241					:= 241;
	//#242					:= 242;
	//#243					:= 243;
	//#244					:= 244;
	//#245					:= 245;
	//#246					:= 246;
	//#247					:= 247;
	sys_ntp_gettime			:= 248;
	//#249					:= 249;
	sys_minherit			:= 250;
	sys_rfork				:= 251;
	sys_openbsd_poll		:= 252;
	sys_issetugid			:= 253;
	sys_lchown				:= 254;
	//#255					:= 255;
	//#256					:= 256;
	//#257					:= 257;
	//#258					:= 258;
	//#259					:= 259;
	//#260					:= 260;
	//#261					:= 261;
	//#262					:= 262;
	//#263					:= 263;
	//#264					:= 264;
	//#265					:= 265;
	//#266					:= 266;
	//#267					:= 267;
	//#268					:= 268;
	//#269					:= 269;
	//#270					:= 270;
	//#271					:= 271;
	sys_getdents			:= 272;
	//#273					:= 273;
	sys_lchmod				:= 274;
	sys_netbsd_lchown		:= 275;
	sys_lutimes				:= 276;
	sys_netbsd_msync		:= 277;
	sys_nstat				:= 278;
	sys_nfstat				:= 279;
	sys_nlstat				:= 280;
	//#281					:= 281;
	//#282					:= 282;
	//#283					:= 283;
	//#284					:= 284;
	//#285					:= 285;
	//#286					:= 286;
	//#287					:= 287;
	//#288					:= 288;
	sys_preadv				:= 289;
	sys_pwritev				:= 290;
	//#291					:= 291;
	//#292					:= 292;
	//#293					:= 293;
	//#294					:= 294;
	//#295					:= 295;
	//#296					:= 296;
	sys_old_fhstatfs		:= 297;
	sys_fhopen				:= 298;
	sys_fhstat				:= 299;
	sys_modnext				:= 300;
	sys_modstat				:= 301;
	sys_modfnext			:= 302;
	sys_modfind				:= 303;
	sys_kldload				:= 304;
	sys_kldunload			:= 305;
	sys_kldfind				:= 306;
	sys_kldnext				:= 307;
	sys_kldstat				:= 308;
	sys_kldfirstmod			:= 309;
	sys_getsid				:= 310;
	sys_setresuid			:= 311;
	sys_setresgid			:= 312;
	sys_obs_signanosleep	:= 313;
	sys_aio_return			:= 314;
	sys_aio_suspend			:= 315;
	sys_aio_cancel			:= 316;
	sys_aio_error			:= 317;
	sys_aio_read			:= 318;
	sys_aio_write			:= 319;
	sys_lio_listio			:= 320;
	sys_yield				:= 321;
	sys_obs_thr_sleep		:= 322;
	sys_obs_thr_wakeup		:= 323;
	sys_mlockall			:= 324;
	sys_munlockall			:= 325;
	sys___getcwd			:= 326;
	sys_sched_setparam		:= 327;
	sys_sched_getparam		:= 328;
	sys_sched_setscheduler	:= 329;
	sys_sched_getscheduler	:= 330;
	sys_sched_yield			:= 331;
	sys_sched_get_priority_max	:= 332;
	sys_sched_get_priority_min	:= 333;
	sys_sched_rr_get_interval	:= 334;
	sys_utrace				:= 335;
	sys_old_sendfile		:= 336;
	sys_kldsym				:= 337;
	sys_jail				:= 338;
	//#339					:= 339;
	sys_sigprocmask			:= 340;
	sys_sigsuspend			:= 341;
	//sys_old_sigaction		:= 342;
	sys_sigpending			:= 343;
	//sys_old_sigreturn		:= 344;
	sys_sigtimedwait		:= 345;
	sys_sigwaitinfo			:= 346;
	sys___acl_get_file		:= 347;
	sys___acl_set_file		:= 348;
	sys___acl_get_fd		:= 349;
	sys___acl_set_fd		:= 350;
	sys___acl_delete_file	:= 351;
	sys___acl_delete_fd		:= 352;
	sys___acl_aclcheck_file	:= 353;
	sys___acl_aclcheck_fd	:= 354;
	sys_extattrctl			:= 355;
	sys_extattr_set_file	:= 356;
	sys_extattr_get_file	:= 357;
	sys_extattr_delete_file	:= 358;
	sys_aio_waitcomplete	:= 359;
	sys_getresuid			:= 360;
	sys_getresgid			:= 361;
	sys_kqueue				:= 362;
	sys_kevent				:= 363;
	//#364					:= 364;
	//#365					:= 365;
	//#366					:= 366;
	//#367					:= 367;
	//#368					:= 368;
	//#369					:= 369;
	sys_lkmressys			:= 370;
	sys_extattr_set_fd		:= 371;
	sys_extattr_get_fd		:= 372;
	sys_extattr_delete_fd	:= 373;
	sys___setugid			:= 374;
	sys_nfsclnt				:= 375;
	sys_eaccess				:= 376;
	//#377					:= 377;
	sys_nmount				:= 378;
	sys_kse_exit			:= 379;
	sys_kse_wakeup			:= 380;
	sys_kse_create			:= 381;
	sys_kse_thr_interrupt	:= 382;
	sys_kse_release			:= 383;
	sys___mac_get_proc		:= 384;
	sys___mac_set_proc		:= 385;
	sys___mac_get_fd		:= 386;
	sys___mac_get_file		:= 387;
	sys___mac_set_fd		:= 388;
	sys___mac_set_file		:= 389;
	sys_kenv				:= 390;
	sys_lchflags			:= 391;
	sys_uuidgen				:= 392;
	sys_sendfile			:= 393;
	sys_mac_syscall			:= 394;
	sys_getfsstat			:= 395;
	sys_statfs				:= 396;
	sys_fstatfs				:= 397;
	sys_fhstatfs			:= 398;
	//#399					:= 399;
	sys_ksem_close			:= 400;
	sys_ksem_post			:= 401;
	sys_ksem_wait			:= 402;
	sys_ksem_trywait		:= 403;
	sys_ksem_init			:= 404;
	sys_ksem_open			:= 405;
	sys_ksem_unlink			:= 406;
	sys_ksem_getvalue		:= 407;
	sys_ksem_destroy		:= 408;
	sys___mac_get_pid		:= 409;
	sys___mac_get_link		:= 410;
	sys___mac_set_link		:= 411;
	sys_extattr_set_link	:= 412;
	sys_extattr_get_link	:= 413;
	sys_extattr_delete_link	:= 414;
	sys___mac_execve		:= 415;
	sys_sigaction			:= 416;
	sys_sigreturn			:= 417;
	//#418					:= 418;
	//#419					:= 419;
	//#420					:= 420;
	sys_getcontext			:= 421;
	sys_setcontext			:= 422;
	sys_swapcontext			:= 423;
	sys_swapoff				:= 424;
	sys___acl_get_link		:= 425;
	sys___acl_set_link		:= 426;
	sys___acl_delete_link	:= 427;
	sys___acl_aclcheck_link	:= 428;
	sys_sigwait				:= 429;
	sys_thr_create			:= 430;
	sys_thr_exit			:= 431;
	sys_thr_self			:= 432;
	sys_thr_kill			:= 433;
	sys__umtx_lock			:= 434;
	sys__umtx_unlock		:= 435;
	sys_jail_attach			:= 436;
	sys_extattr_list_fd		:= 437;
	sys_extattr_list_file	:= 438;
	sys_extattr_list_link	:= 439;
	sys_kse_switchin		:= 440;
	sys_ksem_timedwait		:= 441;
	sys_thr_suspend			:= 442;
	sys_thr_wake			:= 443;
	sys_kldunloadf			:= 444;
	sys_audit				:= 445;
	sys_auditon				:= 446;
	sys_getauid				:= 447;
	sys_setauid				:= 448;
	sys_getaudit			:= 449;
	sys_setaudit			:= 450;
	sys_getaudit_addr		:= 451;
	sys_setaudit_addr		:= 452;
	sys_auditctl			:= 453;
	sys__umtx_op			:= 454;
	sys_thr_new				:= 455;
	
	// From MMAN.H
	
	PROT_NONE				:= 0;
	PROT_READ				:= 1;
	PROT_WRITE				:= 2;
	PROT_EXEC				:= 4;
	 
	MAP_FILE				:=      0;
	MAP_SHARED				:=      1;
	MAP_PRIVATE				:=      2;
	MAP_RENAME				:=    $20;
	MAP_NORESERVE			:=    $40;
	MAP_RESERVED0080		:=    $80;
	MAP_RESERVED0100		:=   $100;
	MAP_HASSEMAPHORE		:=   $200;
	MAP_STACK				:=   $400;
	MAP_NOSYNC				:=   $800;
	MAP_ANON				:=  $1000;
	MAP_NOCORE				:= $20000;
	
	MCL_CURRENT				:= 1;
	MCL_FUTURE				:= 2;
	
	MAP_FAILED				:= -1;
	
	MS_SYNC					:= 0;
	MS_ASYNC				:= 1;
	MS_INVALIDATE			:= 2;
	
	_MADV_NORMAL			:= 0;
	_MADV_RANDOM			:= 1;
	_MADV_SEQUENTIAL		:= 2;
	_MADV_WILLNEED			:= 3;
	_MADV_DONTNEED			:= 4;
	
	MADV_NORMAL				:= 0;
	MADV_RANDOM				:= 1;
	MADV_SEQUENTIAL			:= 2;
	MADV_WILLNEED			:= 3;
	MADV_DONTNEED			:= 4;
	MADV_FREE				:= 5;	/* dont need these pages, and junk contents */
	MADV_NOSYNC				:= 6;	/* try to avoid flushes to physical media */
	MADV_AUTOSYNC			:= 7;	/* revert to default flushing strategy */
	MADV_NOCORE				:= 8;	/* do not include these pages in a core file */
	MADV_CORE				:= 9;	/* revert to including pages in a core file */
	MADV_PROTECT			:= 10;	/* protect process from pageout kill */
	
	MINCORE_INCORE	 	 	:= $1;	/* Page is incore */
	MINCORE_REFERENCED	 	:= $2;	/* Page has been referenced by us */
	MINCORE_MODIFIED	 	:= $4;	/* Page has been modified by us */
	MINCORE_REFERENCED_OTHER := $8;	/* Page has been referenced */
	MINCORE_MODIFIED_OTHER	:= $10;	/* Page has been modified */

	POSIX_MADV_NORMAL		:= _MADV_NORMAL;
	POSIX_MADV_RANDOM		:= _MADV_RANDOM;
	POSIX_MADV_SEQUENTIAL	:= _MADV_SEQUENTIAL;
	POSIX_MADV_WILLNEED		:= _MADV_WILLNEED;
	POSIX_MADV_DONTNEED		:= _MADV_DONTNEED;
	
	// From signal.h

	SIGHUP		:= 1;	/* hangup */
	SIGINT		:= 2;	/* interrupt */
	SIGQUIT		:= 3;	/* quit */
	SIGILL		:= 4;	/* illegal instr. (not reset when caught) */
	SIGTRAP		:= 5;	/* trace trap (not reset when caught) */
	SIGABRT		:= 6;	/* abort() */
	SIGIOT		:= SIGABRT;	/* compatibility */
	SIGEMT		:= 7;	/* EMT instruction */
	SIGFPE		:= 8;	/* floating point exception */
	SIGKILL		:= 9;	/* kill (cannot be caught or ignored) */
	SIGBUS		:= 10;	/* bus error */
	SIGSEGV		:= 11;	/* segmentation violation */
	SIGSYS		:= 12;	/* non-existent system call invoked */
	SIGPIPE		:= 13;	/* write on a pipe with no one to read it */
	SIGALRM		:= 14;	/* alarm clock */
	SIGTERM		:= 15;	/* software termination signal from kill */
	SIGURG		:= 16;	/* urgent condition on IO channel */
	SIGSTOP		:= 17;	/* sendable stop signal not from tty */
	SIGTSTP		:= 18;	/* stop signal from tty */
	SIGCONT		:= 19;	/* continue a stopped process */
	SIGCHLD		:= 20;	/* to parent on child stop or exit */
	SIGTTIN		:= 21;	/* to readers pgrp upon background tty read */
	SIGTTOU		:= 22;	/* like TTIN if (tp->t_local&LTOSTOP) */
	SIGIO		:= 23;	/* input/output possible signal */
	SIGXCPU		:= 24;	/* exceeded CPU time limit */
	SIGXFSZ		:= 25;	/* exceeded file size limit */
	SIGVTALRM	:= 26;	/* virtual time alarm */
	SIGPROF		:= 27;	/* profiling time alarm */
	SIGWINCH	:= 28;	/* window size changes */
	SIGINFO		:= 29;	/* information request */
	SIGUSR1		:= 30;	/* user defined signal 1 */
	SIGUSR2		:= 31;	/* user defined signal 2 */
	SIGTHR		:= 32;	/* reserved by thread library. */
	SIGLWP		:= SIGTHR;
	
	SIG_DFL		:= @pointer(0);
	SIG_IGN		:= @pointer(1);
	SIG_ERR		:= @pointer(-1);

	SA_ONSTACK			:= $0001;	/* take signal on signal stack */
	SA_RESTART			:= $0002;	/* restart system call on signal return */
	SA_RESETHAND		:= $0004;	/* reset to SIG_DFL when taking signal */
	SA_NODEFER			:= $0010;	/* don't mask the signal we're delivering */
	SA_NOCLDWAIT		:= $0020;	/* don't keep zombies around */
	SA_SIGINFO			:= $0040;	/* signal handler with SA_SIGINFO args */

	_MC_FPFMT_NODEV		:= $10000;	/* device not present or configured */
	_MC_FPFMT_387		:= $10001;
	_MC_FPFMT_XMM		:= $10002;
	_MC_FPOWNED_NONE	:= $20000;	/* FP state not used */
	_MC_FPOWNED_FPU		:= $20001;	/* FP state came from FPU */
	_MC_FPOWNED_PCB		:= $20002;	/* FP state came from PCB */


	/*
	 * Trap type values
	 * also known in trap.c for name strings
	 */
	
	T_PRIVINFLT	:= 1;	/* privileged instruction */
	T_BPTFLT	:= 3;	/* breakpoint instruction */
	T_ARITHTRAP	:= 6;	/* arithmetic trap */
	T_PROTFLT	:= 9;	/* protection fault */
	T_TRCTRAP	:= 10;	/* debug exception (sic) */
	T_PAGEFLT	:= 12;	/* page fault */
	T_ALIGNFLT	:= 14;	/* alignment fault */
	T_DIVIDE	:= 18;	/* integer divide fault */
	T_NMI		:= 19;	/* non-maskable trap */
	T_OFLOW		:= 20;	/* overflow trap */
	T_BOUND		:= 21;	/* bound instruction fault */
	T_DNA		:= 22;	/* device not available fault */
	T_DOUBLEFLT	:= 23;	/* double fault */
	T_FPOPFLT	:= 24;	/* fp coprocessor operand fetch fault */
	T_TSSFLT	:= 25;	/* invalid tss fault */
	T_SEGNPFLT	:= 26;	/* segment not present fault */
	T_STKFLT	:= 27;	/* stack fault */
	T_MCHK		:= 28;	/* machine check trap */
	T_XMMFLT	:= 29;	/* SIMD floating-point exception */
	T_RESERVED	:= 30;	/* reserved (unknown) */
	
	/* XXX most of the following codes aren't used, but could be. */
	
	/* definitions for <sys/signal.h> */
	
	//ILL_RESAD_FAULT		:= T_RESADFLT;
	ILL_PRIVIN_FAULT	:= T_PRIVINFLT;
	//ILL_RESOP_FAULT		:= T_RESOPFLT;
	ILL_ALIGN_FAULT		:= T_ALIGNFLT;
	ILL_FPOP_FAULT		:= T_FPOPFLT;	/* coprocessor operand fault */
	
	/* portable macros for SIGFPE/ARITHTRAP */
	
	FPE_INTOVF	:= 1;	/* integer overflow */
	FPE_INTDIV	:= 2;	/* integer divide by zero */
	FPE_FLTDIV	:= 3;	/* floating point divide by zero */
	FPE_FLTOVF	:= 4;	/* floating point overflow */
	FPE_FLTUND	:= 5;	/* floating point underflow */
	FPE_FLTRES	:= 6;	/* floating point inexact result */
	FPE_FLTINV	:= 7;	/* invalid floating point operation */
	FPE_FLTSUB	:= 8;	/* subscript out of range */
	
	
	
	/* codes for SIGBUS */
	
	BUS_PAGE_FAULT	:= T_PAGEFLT;	/* page fault protection base */
	BUS_SEGNP_FAULT	:= T_SEGNPFLT;	/* segment not present */
	BUS_STK_FAULT	:= T_STKFLT	;	/* stack segment */
	BUS_SEGM_FAULT	:= T_RESERVED;	/* segment protection base */
	
	/* Trap's coming from user mode */
	
	T_USER			:= $100;
	
	SIG_BLOCK		:= 1;	/* block specified signal set */
	SIG_UNBLOCK		:= 2;	/* unblock specified signal set */
	SIG_SETMASK		:= 3;	/* set specified signal set */

	
	// from stat.h
	
	S_ISUID		:= $800; //0004000			/* set user id on execution */
	S_ISGID		:= $400; //0002000			/* set group id on execution */
	S_ISTXT		:= $200; //0001000			/* sticky bit */
	S_IRWXU		:= $1c0; //0000700			/* RWX mask for owner */
	S_IRUSR		:= $100; //0000400			/* R for owner */
	S_IWUSR		:= $80;  //0000200			/* W for owner */
	S_IXUSR		:= $40;  //0000100			/* X for owner */
	S_IREAD		:= S_IRUSR;
	S_IWRITE	:= S_IWUSR;
	S_IEXEC		:= S_IXUSR;
	S_IRWXG		:= $38;  //0000070			/* RWX mask for group */
	S_IRGRP		:= $20;  //0000040			/* R for group */
	S_IWGRP		:= $10;  //0000020			/* W for group */
	S_IXGRP		:= $08;  //0000010			/* X for group */
	S_IRWXO		:= 7;						/* RWX mask for other */
	S_IROTH		:= 4;						/* R for other */
	S_IWOTH		:= 2;						/* W for other */
	S_IXOTH		:= 1;						/* X for other */
	S_IFMT	 	:= $F000; //0170000			/* type of file mask */
	S_IFIFO	 	:= $1000; //0010000			/* named pipe (fifo) */
	S_IFCHR	 	:= $2000; //0020000			/* character special */
	S_IFDIR	 	:= $4000; //0040000		/* directory */
	S_IFBLK	 	:= $6000; //0060000		/* block special */
	S_IFREG	 	:= $8000; //0100000		/* regular */
	S_IFLNK	 	:= $A000; //0120000		/* symbolic link */
	S_IFSOCK 	:= $C000; //0140000		/* socket */
	S_ISVTX	 	:= $200;  //0001000		/* save swapped text even after use */
	S_IFWHT  	:= $E000; //0160000		/* whiteout */


	S_BLKSIZE	:= 512;					/* block size used in the stat struct */

	/*
	 * Definitions of flags stored in file flags word.
	 *
	 * Super-user and owner changeable flags.
	 */
	 
	UF_SETTABLE		:= $0000ffff;	/* mask of owner changeable flags */
	UF_NODUMP		:= $00000001;	/* do not dump file */
	UF_IMMUTABLE	:= $00000002;	/* file may not be changed */
	UF_APPEND		:= $00000004;	/* writes to file may only append */
	UF_OPAQUE		:= $00000008;	/* directory is opaque wrt. union */
	UF_NOUNLINK		:= $00000010;	/* file may not be removed or renamed */
	/*
	 * Super-user changeable flags.
	 */
	SF_SETTABLE		:= $ffff0000;	/* mask of superuser changeable flags */
	SF_ARCHIVED		:= $00010000;	/* file is archived */
	SF_IMMUTABLE	:= $00020000;	/* file may not be changed */
	SF_APPEND		:= $00040000;	/* writes to file may only append */
	SF_NOUNLINK		:= $00100000;	/* file may not be removed or renamed */
	SF_SNAPSHOT		:= $00200000;	/* snapshot inode */
	
	STDIN_FILENO	:= 0;			/* standard input file descriptor */
	STDOUT_FILENO	:= 1;			/* standard output file descriptor */
	STDERR_FILENO	:= 2;			/* standard error file descriptor */

	F_OK			:= 0;			/* test for existence of file */
	X_OK			:= 1;			/* test for execute or search permission */
	W_OK			:= 2;			/* test for write permission */
	R_OK			:= 4;			/* test for read permission */
	SEEK_SET		:= 0;			/* set file offset to offset */
	SEEK_CUR		:= 1;			/* set file offset to current plus offset */
	SEEK_END		:= 2;			/* set file offset to EOF plus offset */

	O_RDONLY		:= $0000;		/* open for reading only */
	O_WRONLY		:= $0001;		/* open for writing only */
	O_RDWR			:= $0002;		/* open for reading and writing */
	O_ACCMODE		:= $0003;		/* mask for above modes */
	FREAD			:= $0001;
	FWRITE			:= $0002;
	O_NONBLOCK		:= $0004;		/* no delay */
	O_APPEND		:= $0008;		/* set append mode */
	O_SHLOCK		:= $0010;		/* open with shared file lock */
	O_EXLOCK		:= $0020;		/* open with exclusive file lock */
	O_ASYNC			:= $0040;		/* signal pgrp when data ready */
	O_FSYNC			:= $0080;		/* synchronous writes */
	O_SYNC			:= $0080;		/* POSIX synonym for O_FSYNC */
	O_NOFOLLOW		:= $0100;		/* don't follow symlinks */
	O_CREAT			:= $0200;		/* create if nonexistent */
	O_TRUNC			:= $0400;		/* truncate to zero length */
	O_EXCL			:= $0800;		/* error if already exists */
	O_NOCTTY		:= $8000;		/* don't assign controlling terminal */
	O_DIRECT		:= $00010000;
	FAPPEND			:= O_APPEND;	/* kernel/compat */
	FASYNC			:= O_ASYNC;		/* kernel/compat */
	FFSYNC			:= O_FSYNC;		/* kernel */
	FNONBLOCK		:= O_NONBLOCK;	/* kernel */
	FNDELAY			:= O_NONBLOCK;	/* compat */
	O_NDELAY		:= O_NONBLOCK;	/* compat */
	FPOSIXSHM		:= O_NOFOLLOW;
	F_DUPFD			:= 0;			/* duplicate file descriptor */
	F_GETFD			:= 1;			/* get file descriptor flags */
	F_SETFD			:= 2;			/* set file descriptor flags */
	F_GETFL			:= 3;			/* get file status flags */
	F_SETFL			:= 4;			/* set file status flags */
	F_GETOWN		:= 5;			/* get SIGIO/SIGURG proc/pgrp */
	F_SETOWN		:= 6;			/* set SIGIO/SIGURG proc/pgrp */
	F_GETLK			:= 7;			/* get record locking information */
	F_SETLK			:= 8;			/* set record locking information */
	F_SETLKW		:= 9;			/* F_SETLK; wait if blocked */
	FD_CLOEXEC		:= 1;			/* close-on-exec flag */
	F_RDLCK			:= 1;			/* shared or read lock */
	F_UNLCK			:= 2;			/* unlock */
	F_WRLCK			:= 3;			/* exclusive or write lock */
	LOCK_SH			:= $01;			/* shared file lock */
	LOCK_EX			:= $02;			/* exclusive file lock */
	LOCK_NB			:= $04;			/* don't block when locking */
	LOCK_UN			:= $08;			/* unlock file */


	// From dirent.h
	
	MAXNAMLEN		:= 255;

	/*
	 * File types
	 */
	 
	DT_UNKNOWN	 	:= 0;
	DT_FIFO		 	:= 1;
	DT_CHR		 	:= 2;
	DT_DIR		 	:= 4;
	DT_BLK		 	:= 6;
	DT_REG		 	:= 8;
	DT_LNK			:= 10;
	DT_SOCK			:= 12;
	DT_WHT			:= 14;




type
	blkcnt_t	:dword;
	blksize_t	:dword;
	clockid_t	:dword;
	dev_t		:dword;
	fflags_t	:dword;
	fsblkcnt_t	:dword;
	fsfilcnt_t	:dword;
	gid_t		:dword;
	id_t		:int64;
	ino_t		:dword;
	key_t		:dword;
	lwpid_t		:dword;
	mode_t		:word;
	nl_item		:dword;
	nlink_t		:word;
	rlim_t		:qword;
	off_t		:qword;
	pid_t		:int32;
	sa_family_t	:byte;
	size_t		:dword;
	socklen_t	:dword;
	suseconds_t	:dword;
	time_t		:dword;
	timer_t		:dword;
	uid_t		:int32;
	useconds_t	:dword;
	
	
	sigset_t	:union
		__bits		:dword[4];
		__lword		:lword;
		__cset		:cset;
	endunion;

	timeval: record
		tv_sec	:time_t;
		tv_usec	:suseconds_t;
	endrecord;
	
	timespec: record
		tv_sec	:time_t;
		tv_nsec	:dword;
	endrecord;
	
	timezone: record
		tz_minuteswest	:int32;
		tz_dsttime		:int32;
	endrecord;

	sigval	:union
		/* Members as suggested by Annex C of POSIX 1003.1b. */
		sigval_int	:dword;
		sigval_ptr	:pointer to byte;
	endunion;
	
	sigevent	:record
	
		sigev_notify	:dword;
		__sigev_u:union
			__sigev_signo			:dword;	/* Signal number */
			__sigev_notify_kqueue	:dword;
		endunion;
		sigev_value	:sigval;	/* Signal value */
	
	endrecord;
	
	siginfo_t	:record

		si_signo	:dword;		/* signal number */
		si_errno	:dword;		/* errno association */
	
		/*
		 * Cause of signal, one of the SI_ macros or signal-specific
		 * values, i.e. one of the FPE_... values for SIGFPE.  This
		 * value is equivalent to the second argument to an old-style
		 * FreeBSD signal handler.
		 */
		
		si_code		:dword;		/* signal code */
		si_pid		:pid_t;		/* sending process */
		si_uid		:uid_t;		/* sender's ruid */
		si_status	:int32;		/* exit value */
		si_addr		:dword;		/* faulting instruction */
		si_value	:sigval;	/* signal value */
		si_band		:dword;		/* band event for SIGPOLL */
		__spare__	:dword[7];	/* gimme some slack */
	
	endrecord;
	
	stack_t	:record
		ss_sp		:dword;			/* signal stack base */
		ss_size		:size_t;		/* signal stack length */
		ss_flags	:dword;			/* SS_DISABLE and/or SS_ONSTACK */
	endrecord;
	
	
	mcontext_t	:record
	
		/*
		 * The first 20 fields must match the definition of
		 * sigcontext. So that we can support sigcontext
		 * and ucontext_t at the same time.
		 */
		 
		mc_onstack		:dword;		/* XXX - sigcontext compat. */
		mc_gs			:dword;		/* machine state (struct trapframe) */
		mc_fs			:dword;
		mc_es			:dword;
		mc_ds			:dword;
		mc_edi			:dword;
		mc_esi			:dword;
		mc_ebp			:dword;
		mc_isp			:dword;
		mc_ebx			:dword;
		mc_edx			:dword;
		mc_ecx			:dword;
		mc_eax			:dword;
		mc_trapno		:dword;
		mc_err			:dword;
		mc_eip			:dword;
		mc_cs			:dword;
		mc_eflags		:dword;
		mc_esp			:dword;
		mc_ss			:dword;
	
		mc_len			:dword;			/* sizeof(mcontext_t) */
		mc_fpformat		:dword;
		mc_ownedfp		:dword;
		mc_spare1		:dword;		/* align next field to 16 bytes */
		
		/*
		 * See <machine/npx.h> for the internals of mc_fpstate[].
		 */
		 
		mc_fpstate		:dword[128];
		mc_spare2		:dword[8];
	
	endrecord;


	ucontext_t	:record
	
		/*
		 * Keep the order of the first two fields. Also,
		 * keep them the first two fields in the structure.
		 * This way we can have a union with struct
		 * sigcontext and ucontext_t. This allows us to
		 * support them both at the same time.
		 * note: the union is not defined, though.
		 */
		 
		uc_sigmask	:sigset_t;
		uc_mcontext	:mcontext_t;
	
		uc_link		:pointer to ucontext_t;
		uc_stack	:stack_t;
		uc_flags	:dword;
		__spare__	:dword[4];
	
	endrecord;


	
	__sa_handler_t		:procedure( sig:dword );
	__sa_sigaction_t	:procedure( sig:dword; var act:siginfo_t; var uap:ucontext_t );

	sigaction_t	:record
	
		__sa_sigaction	:__sa_sigaction_t;
		sa_flags		:dword;
		sa_mask			:sigset_t;
		
	endrecord;
	
		
	 stat_t	:record
	 
		st_dev				:dev_t;		/* inode's device */
		st_ino				:ino_t;		/* inode's number */
		st_mode				:mode_t;	/* inode protection mode */
		st_nlink			:nlink_t;	/* number of hard links */
		st_uid				:uid_t;		/* user ID of the file's owner */
		st_gid				:gid_t;		/* group ID of the file's group */
		st_rdev				:dev_t;		/* device type */
		st_atimespec		:timespec;	/* time of last access */
		st_mtimespec		:timespec;	/* time of last data modification */
		st_ctimespec		:timespec;	/* time of last file status change */
		st_size				:off_t;		/* file size, in bytes */
		st_blocks			:blkcnt_t;	/* blocks allocated for file */
		st_blksize			:blksize_t;	/* optimal blocksize for I/O */
		st_flags			:fflags_t;	/* user defined flags for file */
		st_gen				:uns32;		/* file generation number */
		st_lspare			:dword;
		st_birthtimespec	:timespec; /* time of file creation */
		align(16);
	
	endrecord;
	
	nstat	:record
	
		st_dev				:dev_t;		/* inode's device */
		st_ino				:ino_t;		/* inode's number */
		st_mode				:uns32;		/* inode protection mode */
		st_nlink			:uns32;		/* number of hard links */
		st_uid				:uid_t;		/* user ID of the file's owner */
		st_gid				:gid_t;		/* group ID of the file's group */
		st_rdev				:dev_t;		/* device type */
		st_atimespec		:timespec;	/* time of last access */
		st_mtimespec		:timespec;	/* time of last data modification */
		st_ctimespec		:timespec;	/* time of last file status change */
		st_size				:off_t;		/* file size, in bytes */
		st_blocks			:blkcnt_t;	/* blocks allocated for file */
		st_blksize			:blksize_t;	/* optimal blocksize for I/O */
		st_flags			:fflags_t;	/* user defined flags for file */
		st_gen				:uns32;		/* file generation number */
		st_birthtimespec	:timespec;  /* time of file creation */
		align(16);

	endrecord;


	/*
	 * Advisory file segment locking data type -
	 * information passed to system by user
	 */
		
 	flock	:record
 	
 		l_start	:off_t;
 		l_len	:off_t;
 		l_pid	:pid_t;
 		l_type	:word;
 		l_whence:word;
 		
 	endrecord;
 	
 	env87 	:record
 	
		en_cw		:word;		/* control word (16bits) */
		_pad0		:word;
		en_sw		:word;		/* status word (16bits) */
		_pad1		:word;
		en_tw		:word;		/* tag word (16bits) */
		_pad2		:word;
		en_fip		:dword;		/* floating point instruction pointer */
		en_fcs		:word;		/* floating code segment selector */
		en_opcode	:word;		/* opcode last executed (11 bits ) */
		en_foo		:dword;		/* floating operand offset */
		en_fos		:dword;		/* floating operand segment selector */
		
	endrecord;


	save87 	:record
	
		sv_env		:env87;		/* floating point control/status */
		sv_ac		:real80[8];	/* accumulator contents, 0-7 */
		sv_pad0		:byte[4];	/* padding for (now unused) saved status word */
		
		/*
		 * Bogus padding for emulators.  Emulators should use their own
		 * struct and arrange to store into this struct (ending here)
		 * before it is inspected for ptracing or for core dumps.  Some
		 * emulators overwrite the whole struct.  We have no good way of
		 * knowing how much padding to leave.  Leave just enough for the
		 * GPL emulator's i387_union (176 bytes total).
		 */
		 
		sv_pad		:byte[64];	/* padding; used by emulators */
	
	endrecord;

	envxmm	:record
	
		en_cw			:word;		/* control word (16bits) */
		en_sw			:word;		/* status word (16bits) */
		en_tw			:word;		/* tag word (16bits) */
		en_opcode		:word;		/* opcode last executed (11 bits ) */
		en_fip			:dword;		/* floating point instruction pointer */
		en_fcs			:word;		/* floating code segment selector */
		en_pad0			:word;		/* padding */
		en_foo			:dword;		/* floating operand offset */
		en_fos			:word;		/* floating operand segment selector */
		en_pad1			:word;		/* padding */
		en_mxcsr		:dword;		/* SSE sontorol/status register */
		en_mxcsr_mask	:dword;		/* valid bits in mxcsr */
	
	endrecord;
	
	fpitem	:record
	
		fpacc	:real80;
		align(16);
		
	endrecord;
	
	savexmm :record
	
		sv_env			:envxmm;
		sv_fp			:fpitem[8];
		sv_xmm			:lword[8];
		sv_pad			:byte[224];
	
		align(16);
		
	endrecord;
	
	savefpu 	:union
	
		sv_87	:save87;
		sv_xmm	:savexmm;
	
	endunion;

	dirent 	:record
	
		d_fileno	:dword;					/* file number of entry */
		d_reclen	:word;					/* length of this record */
		d_type		:byte; 					/* file type, see consts above */
		d_namlen	:byte;					/* length of string in d_name */
		d_name		:char[MAXNAMLEN + 1];	/* name must be no longer than this */

	endrecord;


  	fd_set: record
  		fds_bits	:dword[ 32 ];
  	endrecord;
  	fd_set_ptr	:pointer to fd_set;
	
	hostent	:record
	
		h_name		:zstring;
		h_aliases	:dword;
		h_addrtype	:dword;
		h_length	:dword;
		h_addr_list	:dword;
		
	endrecord;




proc

	chdir:
		procedure( path:string );
		external( "BSD_CHDIR" );

	close:
		procedure( fd:dword );
		external( "BSD_CLOSE" );

	execve:
		procedure( path:string; var argv:var; var envp:var  );
		external( "BSD_EXECVE" );
	
	_exit:
		procedure( exitCode:dword );
		external( "BSD_EXIT" );
	
	fork:
		procedure;
		external( "BSD_FORK" );
	
	fstat:
		procedure( fd:dword; var sb:stat_t );
		external( "BSD_FSTAT" );
	
	fsync:
		procedure( fd:dword );
		external( "BSD_FSYNC" );

	ftruncate:
		procedure( fd:dword; length:off_t );
		external( "BSD_FTRUNCATE" );

	getcwd:
		procedure( var buf:var; size:size_t );
		external( "BSD_GETCWD" );
	
	getdents:
		procedure( fd:dword; var buf:var; nbytes:dword );
		external( "BSD_GETDENTS" );
	
	getdirentries:
		procedure( fd:dword; var buf:var; nbytes:dword; var basep:dword );
		external( "BSD_GETDIRENTRIES" );
	
	gettimeofday:
		procedure( var tv:timeval; var tz:timezone );
		external( "BSD_GETTIMEOFDAY" );
	
	lseek:
		procedure( fd:dword; offset:off_t; whence:dword );
		external( "BSD_LSEEK" );

	lstat:
		procedure( path:string; var sb:stat_t );
		external( "BSD_LSTAT" );
	
	mkdir:
		procedure( path:string; mode:mode_t );
		external( "BSD_MKDIR" );
	
	mmap:
		procedure
		( 
			addr	:dword; 
			len		:size_t; 
			prot	:dword; 
			flags	:dword; 
			fd		:dword; 
			offset	:off_t 
		);
		external( "BSD_MMAP" );

	munmap:
		procedure( addr:dword; len:size_t );
		external( "BSD_MUNMAP" );

	nanosleep:
		procedure( var rgtp:timespec; var rmtp:timespec );
		external( "BSD_NANOSLEEP" );

const 
	open :text := "bsd.open3";

proc

	open2:
		procedure( path:string; flags:dword );
		external( "BSD_OPEN2" );

	open3:
		procedure( path:string; flags:dword; mode:mode_t );
		external( "BSD_OPEN3" );
	
	pread:
		procedure( fd:dword; var buf:var; len:size_t; offset:off_t );
		external( "BSD_PREAD" );

	read:
		procedure( fd:dword; var buf:var; len:dword );
		external( "BSD_READ" );

	rename:
		procedure( from:string; toName:string );
		external( "BSD_RENAME" );

	rmdir:
		procedure( path:string );
		external( "BSD_RMDIR" );

	sigaction:
		procedure
		(
				sig		:dword;
			var	act		:sigaction_t;
			var	oact	:sigaction_t
		);
		external( "BSD_SIGACTION" );

	sigprocmask:
		procedure( how:dword; var newSet:sigset_t; var oldSet:sigset_t);
		external( "BSD_SIGPROCMASK" );
		
	stat:
		procedure( path:string; var sb:stat_t );
		external( "BSD_STAT" );
	
	truncate:
		procedure( path:string; length:off_t );
		external( "BSD_TRUNCATE" );

	unlink:
		procedure( path:string );
		external( "BSD_UNLINK" );

	waitpid:
		procedure
		( 
				pid			:pid_t; 
			var stat_addr	:dword; 
				options		:dword 
		);
		external( "BSD_WAITPID" );
	
	write:
		procedure( fd:dword; var buf:var; len:dword );
		external( "BSD_WRITE" );



// Networking functions	


	accept:
		procedure
		( 
				s		:dword; 
			var	addr	:@global:hla.sockaddr; 
			var	addrlen	:@global:hla.socklen_t 
		) {@returns( "eax" )};
		external( "BSD_ACCEPT" );
	
	bind:
		procedure
		( 
				sockfd	:dword; 
			var	addr	:@global:hla.sockaddr; 
				addrlen	:@global:hla.socklen_t 
		) {@returns( "eax" )};
		external( "BSD_BIND" );
	

	connect:
		procedure
		( 
				sockfd	:dword; 
			var	addr	:@global:hla.sockaddr; 
				addrlen	:@global:hla.socklen_t 
		) {@returns( "eax" )};
		external( "BSD_CONNECT" );


	gethostbyaddr:
		procedure( addr:dword; len:dword; _type:dword ) {@returns( "eax" )};
		external( "BSD_GETHOSTBYADDR" );
	
	
	gethostbyname:
		procedure( s:string ) {@returns( "eax" )};
		external( "BSD_GETHOSTBYNAME" );

	gethostname:
		procedure( var buf:var; maxlen:dword ) {@returns( "eax" )};
		external( "BSD_GETHOSTNAME" );


	getpeername:
		procedure
		( 
				s		:dword; 
			var	_name	:@global:hla.sockaddr; 
			var	namelen	:@global:hla.socklen_t 
		) {@returns( "eax" )};
		external( "BSD_GETPEERNAME" );

	getsockname:
		procedure
		( 
				s		:dword; 
			var	_name	:@global:hla.sockaddr; 
			var	namelen	:@global:hla.socklen_t 
		) {@returns( "eax" )};
		external( "BSD_GETSOCKNAME" );


	getsockopt:
		procedure
		( 
				s		:dword; 
				level	:dword;
				optname	:dword;
			var	optval	:var;
			var	optlen	:@global:hla.socklen_t 
		) {@returns( "eax" )};
		external( "BSD_GETSOCKOPT" );


	listen:
		procedure
		( 
			s		:dword; 
			backlog	:dword
		) {@returns( "eax" )};
		external( "BSD_LISTEN" );
	
	
	recv:
		procedure
		( 
				s		:dword; 
			var	buf		:var;
				len		:dword;
				flags	:dword	// MSG_* constants 
		) {@returns( "eax" )};
		external( "BSD_RECV" );
	
	
	recvfrom:
		procedure
		( 
				s		:dword; 
			var	buf		:var;
				len		:dword;
				flags	:dword;
			var	from	:@global:hla.sockaddr;
			var	fromlen	:@global:hla.socklen_t 
		) {@returns( "eax" )};
		external( "BSD_RECVFROM" );
	
	
	select:
		procedure
		( 
				n			:dword; 
			var	readSet		:fd_set;
			var	writeSet	:fd_set;
			var	exceptSet	:fd_set;
			var	timeout		:timeval
		) {@returns( "eax" )};
		external( "BSD_SELECT" );
 
 
	send:
		procedure
		( 
				s		:dword; 
			var	buf		:var;
				len		:dword;
				flags	:dword	// MSG_* constants 
		) {@returns( "eax" )};
		external( "BSD_SEND" );
 
 
	sendto:
		procedure
		( 
				s		:dword; 
			var	buf		:var;
				len		:dword;
				flags	:dword;
			var	_to		:@global:hla.sockaddr;
				tolen	:@global:hla.socklen_t 
		) {@returns( "eax" )};
		external( "BSD_SENDTO" );
 


	setsockopt:
		procedure
		( 
				s		:dword; 
				level	:dword;
				optname	:dword;
			var	optval	:var;
				optlen	:@global:hla.socklen_t 
		) {@returns( "eax" )};
		external( "BSD_SETSOCKOPT" );
	

	shutdown:
		procedure
		( 
			s		:dword; 
			how		:dword 
		) {@returns( "eax" )};
		external( "BSD_SHUTDOWN" );


	socket:
		procedure
		( 
			domain		:dword;		// AF_* or PF_* constants
			_type		:dword;		// SOCK_* constants
			protocol	:dword		// Usually zero. 
		) {@returns( "eax" )};
		external( "BSD_SOCKET" );
	



	// PThread constants, types, and functions:
	
const	
	pThreadAttrSize 		:= 4;
	pThreadMutexSize 		:= 4;
	pThreadMutexAttrSize 	:= 4;
	pThreadCondSize			:= 4;
	pThreadCondAttrSize		:= 4;
	
		// IPC and semaphore stuff
	
	IPC_CREATE	:= $200;
	
	// commands for semctl
	 
	GETNCNT	 	:= 3;	/* Return the value of semncnt {READ} */
	GETPID	 	:= 4;	/* Return the value of sempid {READ} */
	GETVAL	 	:= 5;	/* Return the value of semval {READ} */
	GETALL	 	:= 6;	/* Return semvals into arg.array {READ} */
	GETZCNT	 	:= 7;	/* Return the value of semzcnt {READ} */
	SETVAL	 	:= 8;	/* Set the value of semval to arg.val {ALTER} */
	SETALL	 	:= 9;	/* Set semvals from arg.array {ALTER} */
	SEM_STAT 	:= 10;	/* Like IPC_STAT but treats semid as sema-index */
	SEM_INFO 	:= 11;	/* Like IPC_INFO but treats semid as sema-index */
	SEM_UNDO	:= $1000;

type

	// ipc data structure used to pass permission to IPC operations.
	
	ipc_perm: record
		cuid		:word;   // Should be uid_t;
		cgid		:word;   // Should be gid_t;
		uid			:word;   // Should be uid_t;
		gid			:word;   // Should be gid_t;
		mode		:word;
		seq			:word;
		_key		:key_t;
	endrecord;
	
	
	semid_ds	:record;
	
		sem_perm	:ipc_perm;
		sem_base	:dword;
		sem_nsems	:word;
		sem_otime	:dword;
		sem_pad1	:dword;
		sem_ctime	:dword;
		sem_pad2	:dword;
		sem_pad3	:dword[4];
	
	endrecord;


	/*
	 * semop's sops parameter structure
	 */
	 
	 sembuf	:record;
	 
	 	sem_num	:word;
		sem_op	:word;
		sem_flg	:word;
	 
	 endrecord;
	 
	semun	:union
	
		_val	:dword;
		buf		:dword;
		array	:dword;
		
	endunion;

proc
	semop:
		procedure
	( 
			semid	:dword; 
		var sops	:sembuf; 
			nsops	:dword 
	) {@returns( "eax" )};
		external( "bsd_semop" );
	
	
	semctl:
		procedure
	(
		semid:dword; 
		semnum:int32; 
		cmd:dword; 
		arg:semun 
	) {@returns( "eax" )};
		external( "bsd_semctl" );
	
	semget:
		procedure( key:key_t; nsyms:int32; semflg:dword ) {@returns( "eax" )};
		external( "bsd_semget" );
	


type

	// These are *NIX opaque types:
	
	pthread_key_t			:dword;
	pthread_t				:dword;
	pthread_attr_t			:byte[ pThreadAttrSize ];
	pthread_mutex_t			:byte[ pThreadMutexSize ];
	pthread_mutex_attr_t	:byte[ pThreadMutexAttrSize ];
	pthread_cond_t			:byte[ pThreadCondSize ];
	pthread_condattr_t		:byte[ pThreadCondAttrSize ];

	start_routine_t			:procedure( parm:dword );
	
proc
	pthread_create:
		procedure
	( 
		var thrd			:pthread_t;
		var	attr			:pthread_attr_t;
			start_routine	:start_routine_t;
			parm			:dword
	) {@returns( "eax" )};
		external( "BSD_PTHREAD_CREATE" );
		
	pthread_exit:
		procedure( value_ptr:dword );
		external( "BSD_PTHREAD_EXIT" );

	pthread_self:
		procedure;
		external( "BSD_PTHREAD_SELF" );

	pthread_attr_init:
		procedure( var pta:pthread_attr_t ) {@returns( "eax" )};
		external( "BSD_PTHREAD_ATTR_INIT" );
	
	pthread_attr_destroy:
		procedure( var pta:pthread_attr_t ) {@returns( "eax" )};
		external( "BSD_PTHREAD_ATTR_DESTROY" );
	
	pthread_attr_setstacksize:
		procedure( var pta:pthread_attr_t; size:dword ) {@returns( "eax" )};
		external( "BSD_PTHREAD_ATTR_SETSTACKSIZE" );
		
		

	pthread_key_create:
		procedure( var key:pthread_key_t; destructor:start_routine_t ) {@returns( "eax" )};
		external( "BSD_PTHREAD_KEY_CREATE" );
		
	pthread_key_delete:
		procedure( key:pthread_key_t ) {@returns( "eax" )};
		external( "BSD_PTHREAD_KEY_DELETE" );
		
	pthread_getspecific:
		procedure( key:pthread_key_t ) {@returns( "eax" )};
		external( "BSD_PTHREAD_GETSPECIFIC" );
		
	pthread_setspecific:
		procedure( key:pthread_key_t; value_ptr:dword ) {@returns( "eax" )};
		external( "BSD_PTHREAD_SETSPECIFIC" );
		

	
	
	pthread_mutex_destroy:
		procedure( var mutex:pthread_mutex_t ) {@returns( "eax" )};
		external( "BSD_PTHREAD_MUTEX_DESTROY" );

	pthread_mutex_init:
		procedure
	( 
		var mutex	:pthread_mutex_t;
		var	attr	:pthread_mutex_attr_t 
	) {@returns( "eax" )};
		external( "BSD_PTHREAD_MUTEX_INIT" );

	pthread_mutex_lock:
		procedure( var mutex:pthread_mutex_t ) {@returns( "eax" )};
		external( "BSD_PTHREAD_MUTEX_LOCK" );

	pthread_mutex_unlock:
		procedure( var mutex:pthread_mutex_t ) {@returns( "eax" )};
		external( "BSD_PTHREAD_MUTEX_UNLOCK" );


	ftok:
		procedure( path:string; id:dword ) {@returns( "eax" )};
		external( "BSD_FTOK" );
		
		
		
		
		
	pthread_cond_init:
		procedure
	( 
		var cond	:pthread_cond_t;
		var	attr	:pthread_condattr_t 
	) {@returns( "eax" )};
		external( "BSD_PTHREAD_COND_INIT" );


	pthread_cond_destroy:
		procedure
	( 
		var cond	:pthread_cond_t 
	) {@returns( "eax" )};
		external( "BSD_PTHREAD_COND_DESTROY" );


	pthread_cond_signal:
		procedure
	( 
		var cond	:pthread_cond_t 
	) {@returns( "eax" )};
		external( "BSD_PTHREAD_COND_SIGNAL" );


	pthread_cond_broadcast:
		procedure
	( 
		var cond	:pthread_cond_t 
	) {@returns( "eax" )};
		external( "BSD_PTHREAD_COND_BROADCAST" );


	pthread_cond_wait:
		procedure
	( 
		var cond	:pthread_cond_t;
		var	mutex	:pthread_mutex_t 
	) {@returns( "eax" )};
		external( "BSD_PTHREAD_COND_WAIT" );

	pthread_cond_timedwait:
		procedure
	( 
		var cond	:pthread_cond_t;
		var	mutex	:pthread_mutex_t;
		var timeout	:@global:hla.timespec 
	) {@returns( "eax" )};
		external( "BSD_PTHREAD_COND_TIMEDWAIT" );

end bsd;

#endif








	
  		
  		
  		
