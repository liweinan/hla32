#if( ! @defined( blob_hhf ))
?blob_hhf := true;

#includeOnce( "hla.hhf" )
#includeOnce( "buf.hhf" )

			
				
// blob-
//
//	Binary Large OBject functions.
//  -      -     --

namespace blob; //@fast; 


type
	blobRec	:record := -24;

				allocPtr		:dword;
				criticalSection	:dword;
				rcursor			:dword;
				wcursor			:dword;
				maxlen			:dword;
				length			:dword;
				blobData		:byte[16];

			endrecord;
			
	t		:pointer to blobRec;
	blob	:t;
	blob_t	:t;
	
const
	blobHeaderSize	:= -@int32(@offset( blobRec.allocPtr ));

	
	//  Support Routines (internal use only):
	
proc
	__catbuf:
		procedure( dest:blob; buf:dword; len:dword );
		@global:_hla._ext( "BLOB___CATBUF" );
			 
	_catbuf:
		procedure( dest:blob; var buf:var; len:dword );
		@global:_hla._ext( "BLOB__CATBUF" );
			 
	_cats:
		procedure( dest:blob );
		@global:_hla._ext( "BLOB__CATS" );
	   
	_catsub:
		procedure
		(
			src		:string; 
			start	:dword; 
			len		:dword; 
			dest	:blob 
		); 
		@global:_hla._ext( "BLOB__CATSUB" );
	   			   

	_cpy:
		procedure ( src:blob; dest:blob  ); 
		@global:_hla._ext( "BLOB__CPY" );

	_getc:
		procedure ( src:blob  ) {@returns( "al" )}; 
		@global:_hla._ext( "BLOB__GETC" );

	


	// Blob allocation and initialization functions:
	
	init:
		procedure( var b:var; numBytes:dword ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_INIT" );
		
	init16:
		procedure ( var b:var; numBytes:dword ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_INIT16" );
		
	alloc:
		procedure( size:dword ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_ALLOC" );
		
	allocAligned:
		procedure( size:dword; alignment:dword ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_ALLOCALIGNED" );
		
	realloc:
		procedure( theBlob:blob; size:dword ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_REALLOC" );
		
	free:
		procedure( theBlob:blob );
		@global:_hla._ext( "BLOB_FREE" );
		
	destroy:
		procedure( theBlob:blob );
		@global:_hla._ext( "BLOB_DESTROY" );
		
	
	// Buffer to blob functions:
	//
	// Note: blob.a_bufToStr1 and blob.a_bufToStr2 are different
	// prototypes for exactly the same function.
	
const
	a_bufToBlob	:text := "blob.a_bufToBlob2";
	bufToBlob	:text := "blob.bufToBlob3";

proc
	a_bufToBlob2:
		procedure( startBuf:dword; endBuf:dword ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_A_BUFTOBLOB2" );

	a_bufToBlob1:
		procedure( buf:@global:buf_t ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_A_BUFTOBLOB2" );		// Yes, BLOB_BUFTOBLOB2
	

	bufToBlob3:
		procedure( startBuf:dword; endBuf:dword; b:blob );
		@global:_hla._ext( "BLOB_BUFTOBLOB3" );

	bufToBlob2:
		procedure( buf:@global:buf_t; b:blob );
		@global:_hla._ext( "BLOB_BUFTOBLOB3" );		// Yes, BLOB_BUFTOBLOB3
	
		
		
	// File I/O functions
	
	a_load:
		procedure( filename:string ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_A_LOAD" );
	
	load:
		procedure( filename:string; b:blob );
		@global:_hla._ext( "BLOB_LOAD" );
	
	a_loadExtended:
		procedure( filename:string; extend:dword ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_A_LOADEXTENDED" );
		
	a_appendFile:
		procedure ( filename:string; b:blob ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_A_APPENDFILE" );
	
	a_appendFileExtended:
		procedure( filename:string; b:blob; extend:dword ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_A_APPENDFILEEXTENDED" );
	
	appendFile:
		procedure( filename:string; b:blob ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_APPENDFILE" );
	
	save:
		procedure( filename:string; b:blob ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_SAVE" );
		
		
		
	eof:
		procedure( b:blob ) {@returns( "@c" )};
		@global:_hla._ext( "BLOB_EOF" );
		
		
		
		
	// Blob accessor functions.
	
	length:
		procedure( b:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_LENGTH" );
	
	
	setLength:
		procedure( b:blob; newLen:dword ); 
		@global:_hla._ext( "BLOB_SETLENGTH" );
	
	maxlen:
		procedure( b:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_MAXLENGTH" );
	
	setMaxlen:
		procedure( b:blob; newLen:dword ); 
		@global:_hla._ext( "BLOB_SETMAXLEN" );
	
	rcursor:
		procedure( b:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_RCURSOR" );
	
	wcursor:
		procedure( b:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_WCURSOR" );
	
	setrCursor:
		procedure( b:blob; newCursor:dword );
		@global:_hla._ext( "BLOB_SETRCURSOR" );

	setwCursor:
		procedure( b:blob; newCursor:dword );
		@global:_hla._ext( "BLOB_SETWCURSOR" );
		
	reset:
		procedure( b:blob );
		@global:_hla._ext( "BLOB_RESET" );
		
	
	// Binary I/O
	
	read:
		procedure ( b:blob; var dest:var; len:dword ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_READ" );
	
	readAt:
		procedure( b:blob; var dest:var; index:dword; len:dword )  
			{@returns( "eax" )};
		@global:_hla._ext( "BLOB_READAT" );
	
	write:
		procedure( b:blob; var src:var; len:dword ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_WRITE" );
	
	writeAt:
		procedure( b:blob; var src:var; index:dword; len:dword )
			{@returns( "eax" )};
		@global:_hla._ext( "BLOB_WRITEAT" );


	putByte:
		procedure( b:blob; byteVal:byte );
		@global:_hla._ext( "BLOB_CATC" );

	putWord:
		procedure( b:blob; w:word );
		@global:_hla._ext( "BLOB_PUTWORD" );

	putDword:
		procedure( b:blob; d:dword );
		@global:_hla._ext( "BLOB_PUTDWORD" );

	putQword:
		procedure( b:blob; q:qword );
		@global:_hla._ext( "BLOB_PUTQWORD" );

	putTbyte:
		procedure( b:blob; tb:tbyte );
		@global:_hla._ext( "BLOB_PUTTBYTE" );

	putLword:
		procedure( b:blob; l:lword );
		@global:_hla._ext( "BLOB_PUTLWORD" );



	getByte:
		procedure( b:blob ) {@returns( "al" )};
		@global:_hla._ext( "BLOB_GETBYTE" );

	getWord:
		procedure( b:blob ){ @returns( "ax" )};
		@global:_hla._ext( "BLOB_GETWORD" );

	getDword:
		procedure( b:blob ) {@returns( "eax" )};
		@global:_hla._ext( "BLOB_GETDWORD" );

	getQword:
		procedure( b:blob ) {@returns( "edx:eax" )};
		@global:_hla._ext( "BLOB_GETQWORD" );

	getTbyte:
		procedure( b:blob; var tb:tbyte );
		@global:_hla._ext( "BLOB_GETTBYTE" );

	getLword:
		procedure( b:blob; var l:lword );
		@global:_hla._ext( "BLOB_GETLWORD" );


	// BLOB Assignment and copy functions.
	
	a_cpy:
		procedure( src:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_A_CPY" );

	cpy:
		procedure( src:blob; dest:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_CPY" ); 

	fillb:
		procedure( theValue:byte; numBytes:dword; dest:blob ); 
		@global:_hla._ext( "BLOB_FILLB" ); 

	fillw:
		procedure( theValue:word; numWords:dword; dest:blob ); 
		@global:_hla._ext( "BLOB_FILLW" ); 

	filld:
		procedure( theValue:dword; numDWords:dword; dest:blob ); 
		@global:_hla._ext( "BLOB_FILLD" ); 
		
		
	// Copy/concatenate a string/zstring to a blob:
		
	strToBlob:
		procedure( src:string; dest:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_STRTOBLOB" ); 


	zstrToBlob:
		procedure( zsrc:zstring; dest:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_ZSTRTOBLOB" ); 


	catzStr:
		procedure( zsrc:zstring; dest:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_CATZSTR" );
		
	#macro catStr( _s_, _b_ );
	
		@global:blob.cats( _b_, _s_ )
		
	#endmacro 

		
	// Blob concatentation functions.
	
	#macro cat( _parms_[] );
	
		hla.overload( _parms_ )
		
			hla.signature( blob.cat2(blob.blob, blob.blob) )
			hla.signature( blob.cat3(blob.blob, blob.blob, blob.blob) )
			
		hla.endoverload
		
	#endmacro


	cat2:
		procedure( src:blob; dest:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_CAT2" );

	cat3:
		procedure( src1:blob; src2:blob; dest:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_CAT3" );

	a_cat:
		procedure( src1:blob; src2:blob ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_A_CAT" );
		
		
	// Extraction functions:
	
	a_subBlob:
		procedure( src:blob; start:dword; len:dword ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_A_SUBBLOB" ); 
	
	subBlob:
		procedure( src:blob; startIndex:dword; length:dword; dest:blob ); 
		@global:_hla._ext( "BLOB_SUBBLOB" ); 
	

	// Comparison functions:
	
	eq:
		procedure( src1:blob; src2:blob ) {@returns( "@c" )}; 
		@global:_hla._ext( "BLOB_EQ" );

	ne:
		procedure( src1:blob; src2:blob ) {@returns( "@c" )}; 
		@global:_hla._ext( "BLOB_NE" );


	// Scanning functions
	
	#macro index( _parms_[] );
	
		hla.overload( _parms_ )
		
			hla.signature( blob.index2(blob.blob, blob.blob) )
			hla.signature( blob.index3(blob.blob, dword, blob.blob) )
			
		hla.endoverload
		
	#endmacro
	
	
	#macro indexStr( _parms_[] );
	
		hla.overload( _parms_ )
		
			hla.signature( blob.indexStr2(blob.blob, string) )
			hla.signature( blob.indexStr3(blob.blob, dword, string) )
			
		hla.endoverload
		
	#endmacro
	
	index2:
		procedure( src1:blob; src2:blob ) {@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_INDEX2" );

	index3:
		procedure ( src1:blob; offs:dword; src2:blob )  
			{@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_INDEX3" );
	
	// Note: the following are isomorphisms of the above,
	// they depend upon the fact that string and blob objects
	// are structure compatible. Actual functions will need to
	// be written if this ever changes (that is, a string, minus the
	// zero terminating byte, must be equal to a blob object without
	// the wcursor and rcursor fields).
	
	indexStr2:
		procedure( src1:blob; src2:string ) {@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_INDEXSTR2" );

	indexStr3:
		procedure( src1:blob; offs:dword; src2:string ) 
			{@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_INDEXSTR3" );


	#macro rindex( _parms_[] );
	
		hla.overload( _parms_ )
		
			hla.signature( blob.rindex2(blob.blob, blob.blob) )
			hla.signature( blob.rindex3(blob.blob, dword, blob.blob) )
			
		hla.endoverload
		
	#endmacro
	
	rindex2:
		procedure( src1:blob; src2:blob ) {@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_RINDEX2" );

	rindex3:
		procedure( src1:blob; offs:dword; src2:blob )	
			{@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_RINDEX3" );



	// See the comments for indexStr, earlier.
	
	#macro rindexStr( _parms_[] );
	
		hla.overload( _parms_ )
		
			hla.signature( blob.rindexStr2(blob.blob, string) )
			hla.signature( blob.rindexStr3(blob.blob, dword, string) )
			
		hla.endoverload
		
	#endmacro
	
	rindexStr2:
		procedure( src1:blob; src2:string ) {@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_RINDEXSTR2" );

	rindexStr3:
		procedure( src1:blob; offs:dword; src2:string )	
			{@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_RINDEXSTR3" );


	#macro chpos( _parms_[] );
	
		hla.overload( _parms_ )
		
			hla.signature( blob.chpos2( blob.blob, char) )
			hla.signature( blob.chpos3( blob.blob, dword, blob.blob) )
			
		hla.endoverload
		
	#endmacro
	
	chpos2:
		procedure( src1:blob; src2:char ) {@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_CHPOS2" );


	chpos3:
		procedure( src1:blob; offs:dword; src2:char ) 
			{@returns( "@c" )}; 	// and EAX 
		@global:_hla._ext( "BLOB_CHPOS3" );

	#macro rchpos( _parms_[] );
	
		hla.overload( _parms_ )
		
			hla.signature( blob.rchpos2(blob.blob, char) )
			hla.signature( blob.rchpos3(blob.blob, dword, char) )
			
		hla.endoverload
		
	#endmacro
	
	rchpos2:
		procedure( src1:blob; src2:char ) {@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_RCHPOS2" );

	rchpos3:
		procedure( src1:blob; offs:dword; src2:char )
			{@returns( "@c" )};	// and EAX 
		@global:_hla._ext( "BLOB_RCHPOS3" );



	#macro catsub( _parms_[] );
	
		hla.overload( _parms_ )
		
			hla.signature( blob.catsub4(string, dword, dword, blob) )
			hla.signature( blob.catsub5(string, dword, dword, string, blob) )
			
		hla.endoverload
		
	#endmacro


	catsub4:
		procedure( src:string; start:dword; len:dword; dest:blob );
		@global:_hla._ext( "BLOB_CATSUB4" );

	catsub5:
		procedure
		( 
			src2	:string; 
			start	:dword; 
			len		:dword; 
			src1	:string; 
			dest	:blob 
		);
		@global:_hla._ext( "BLOB_CATSUB5" );

	a_catsub:
		procedure( src2:string; start:dword; len:dword; src1:string ) 
			{@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_A_CATSUB" );



const
	catbuf		:text := "blob.catbuf3a";
	
	
proc

	catbuf2:
		procedure( src:@global:buf_t; dest:blob );
		@global:_hla._ext( "BLOB_CATBUF3A" );		// Yes, BLOB_CATBUF3A

	catbuf3a:
		procedure
		( 
			startBuf	:dword; 
			endBuf		:dword; 
			dest		:blob 
		);
		@global:_hla._ext( "BLOB_CATBUF3A" );

	catbuf3b:
		procedure
		( 
			src1		:@global:buf_t; 
			src2		:string; 
			dest		:blob 
		);
		@global:_hla._ext( "BLOB_CATBUF4" );	// Yes, BLOB_CATBUF4

	catbuf4:
		procedure
		( 
			startBuf	:dword; 
			endBuf		:dword;
			src2		:string; 
			dest		:blob 
		);
		@global:_hla._ext( "BLOB_CATBUF4" );





		


	// Value concatenation/put routines:
			 
	newln:
		procedure( dest:blob );
		@global:_hla._ext( "BLOB_NEWLN" );

			   
	catbool:
		procedure( dest:blob;  b:boolean );
		@global:_hla._ext( "BLOB_CATBOOL" );

	putbool:
		procedure( dest:blob;  b:boolean );
		@global:_hla._ext( "BLOB_CATBOOL" );

	catcSize:
		procedure( dest:blob;  c:char; width:int32; fill:char );
		@global:_hla._ext( "BLOB_CATCSIZE" );

	putcSize:
		procedure( dest:blob;  c:char; width:int32; fill:char );
		@global:_hla._ext( "BLOB_CATCSIZE" );

	catc:
		procedure( dest:blob;  c:char );
		@global:_hla._ext( "BLOB_CATC" );

	putc:
		procedure( dest:blob;  c:char );
		@global:_hla._ext( "BLOB_CATC" );


	cats:
		procedure( dest:blob;  src:string );
		@global:_hla._ext( "BLOB_CATS" );

	puts:
		procedure( dest:blob;  src:string );
		@global:_hla._ext( "BLOB_CATS" );

	catsSize:
		procedure( dest:blob; s:string; width:int32; fill:char );
		@global:_hla._ext( "BLOB_CATSSIZE" );

	putsSize:
		procedure( dest:blob; s:string; width:int32; fill:char );
		@global:_hla._ext( "BLOB_CATSSIZE" );


	catzs:
		procedure( dest:blob;  src:zstring );
		@global:_hla._ext( "BLOB_CATZS" );

	putzs:
		procedure( dest:blob;  src:zstring );
		@global:_hla._ext( "BLOB_CATZS" );

	catzsSize:
		procedure( dest:blob; s:zstring; width:int32; fill:char );
		@global:_hla._ext( "BLOB_CATZSSIZE" );

	putzsSize:
		procedure( dest:blob; s:zstring; width:int32; fill:char );
		@global:_hla._ext( "BLOB_CATZSSIZE" );


	catcset:
		procedure( dest:blob;  c:cset );
		@global:_hla._ext( "BLOB_CATCSET" );

	putcset:
		procedure( dest:blob;  c:cset );
		@global:_hla._ext( "BLOB_CATCSET" );


	catbin8:
		procedure( dest:blob;  b:byte );
		@global:_hla._ext( "BLOB_CATBIN8" );

	putbin8:
		procedure( dest:blob;  b:byte );
		@global:_hla._ext( "BLOB_CATBIN8" );


	catb:
		procedure( dest:blob;  b:byte );
		@global:_hla._ext( "BLOB_CATB" );

	catw:
		procedure( dest:blob;  w:word );
		@global:_hla._ext( "BLOB_CATW" );

	catd:
		procedure( dest:blob;  d:dword );
		@global:_hla._ext( "BLOB_CATD" );

	catq:
		procedure( dest:blob;  q:qword );
		@global:_hla._ext( "BLOB_CATQ" );

	cattb:
		procedure( dest:blob;  tb:tbyte );
		@global:_hla._ext( "BLOB_CATTB" );
		
	catl:
		procedure( dest:blob;  l:lword );
		@global:_hla._ext( "BLOB_CATL" );


	putb:
		procedure( dest:blob;  b:byte );
		@global:_hla._ext( "BLOB_CATB" );

	putw:
		procedure( dest:blob;  w:word );
		@global:_hla._ext( "BLOB_CATW" );

	putd:
		procedure( dest:blob;  d:dword );
		@global:_hla._ext( "BLOB_CATD" );

	putq:
		procedure( dest:blob;  q:qword );
		@global:_hla._ext( "BLOB_CATQ" );

	puttb:
		procedure( dest:blob;  tb:tbyte );
		@global:_hla._ext( "BLOB_CATTB" );
		
	putl:
		procedure( dest:blob;  l:lword );
		@global:_hla._ext( "BLOB_CATL" );





	cath8:
		procedure( dest:blob;  b:byte );
		@global:_hla._ext( "BLOB_CATH8" );

	cath16:
		procedure( dest:blob;  w:word );
		@global:_hla._ext( "BLOB_CATH16" );

	cath32:
		procedure( dest:blob;  d:dword );
		@global:_hla._ext( "BLOB_CATH32" );

	cath64:
		procedure( dest:blob;  q:qword );
		@global:_hla._ext( "BLOB_CATH64" );

	cath80:
		procedure( dest:blob;  tb:tbyte );
		@global:_hla._ext( "BLOB_CATH80" );

	cath128:
		procedure( dest:blob;  l:lword );
		@global:_hla._ext( "BLOB_CATH128" );

		

	puth8:
		procedure( dest:blob;  b:byte );
		@global:_hla._ext( "BLOB_CATH8" );

	puth16:
		procedure( dest:blob;  w:word );
		@global:_hla._ext( "BLOB_CATH16" );

	puth32:
		procedure( dest:blob;  d:dword );
		@global:_hla._ext( "BLOB_CATH32" );

	puth64:
		procedure( dest:blob;  q:qword );
		@global:_hla._ext( "BLOB_CATH64" );

	puth80:
		procedure( dest:blob;  tb:tbyte );
		@global:_hla._ext( "BLOB_CATH80" );

	puth128:
		procedure( dest:blob;  l:lword );
		@global:_hla._ext( "BLOB_CATH128" );

		

	cath8Size:
		procedure( dest:blob;  b:byte; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH8SIZE" );

	cath16Size:
		procedure( dest:blob;  w:word; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH16SIZE" );

	cath32Size:
		procedure( dest:blob;  d:dword; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH32SIZE" );

	cath64Size:
		procedure( dest:blob;  q:qword; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH64SIZE" );

	cath80Size:
		procedure( dest:blob;  tb:tbyte; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH80SIZE" );

	cath128Size:
		procedure( dest:blob;  l:lword; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH128SIZE" );





	puth8Size:
		procedure( dest:blob;  b:byte; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH8SIZE" );

	puth16Size:
		procedure( dest:blob;  w:word; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH16SIZE" );

	puth32Size:
		procedure( dest:blob;  d:dword; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH32SIZE" );

	puth64Size:
		procedure( dest:blob;  q:qword; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH64SIZE" );

	puth80Size:
		procedure( dest:blob;  tb:tbyte; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH80SIZE" );

	puth128Size:
		procedure( dest:blob;  l:lword; size:dword; fill:char );
		@global:_hla._ext( "BLOB_CATH128SIZE" );





	catu8:
		procedure( dest:blob;  u8:byte );
		@global:_hla._ext( "BLOB_CATU8" );

	catu8Size:
		procedure
		( 
			dest:blob; 
			u8:byte; 
			width:int32; 
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU8SIZE" );

	catu16:
		procedure( dest:blob;  u16:word );
		@global:_hla._ext( "BLOB_CATU16" );

	catu16Size:
		procedure
		( 
			dest:blob; 
			u16:word; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU16SIZE" );

	catu32:
		procedure( dest:blob;  u32:dword );
		@global:_hla._ext( "BLOB_CATU32" );

	catu32Size:
		procedure
		( 
			dest:blob;
			u32:dword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU32SIZE" );

	catu64:
		procedure( dest:blob;  u64:qword );
		@global:_hla._ext( "BLOB_CATU64" );

	catu64Size:
		procedure
		( 
			dest:blob;
			u64:qword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU64SIZE" );

	catu128:
		procedure( dest:blob;  u128:lword );
		@global:_hla._ext( "BLOB_CATU128" );

	catu128Size:
		procedure
		( 
			dest:blob;
			u128:lword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU128SIZE" );





	putu8:
		procedure( dest:blob;  u8:byte );
		@global:_hla._ext( "BLOB_CATU8" );

	putu8Size:
		procedure
		( 
			dest:blob; 
			u8:byte; 
			width:int32; 
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU8SIZE" );

	putu16:
		procedure( dest:blob;  u16:word );
		@global:_hla._ext( "BLOB_CATU16" );

	putu16Size:
		procedure
		( 
			dest:blob; 
			u16:word; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU16SIZE" );

	putu32:
		procedure( dest:blob;  u32:dword );
		@global:_hla._ext( "BLOB_CATU32" );

	putu32Size:
		procedure
		( 
			dest:blob;
			u32:dword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU32SIZE" );

	putu64:
		procedure( dest:blob;  u64:qword );
		@global:_hla._ext( "BLOB_CATU64" );

	putu64Size:
		procedure
		( 
			dest:blob;
			u64:qword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU64SIZE" );

	putu128:
		procedure( dest:blob;  u128:lword );
		@global:_hla._ext( "BLOB_CATU128" );

	putu128Size:
		procedure
		( 
			dest:blob;
			u128:lword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATU128SIZE" );







	cati8:
		procedure( dest:blob;  i8:byte );
		@global:_hla._ext( "BLOB_CATI8" );

	cati8Size:
		procedure
		( 
			dest:blob;
			i8:byte; 
			width:int32; 
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI8SIZE" );

	cati16:
		procedure( dest:blob;  i16:word );
		@global:_hla._ext( "BLOB_CATI16" );

	cati16Size:
		procedure
		( 
			dest:blob;
			i16:word; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI16SIZE" );

	cati32:
		procedure( dest:blob;  i32:dword );
		@global:_hla._ext( "BLOB_CATI32" );

	cati32Size:
		procedure
		( 
			dest:blob; 
			i32:dword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI32SIZE" );

	cati64:
		procedure( dest:blob;  i64:qword );
		@global:_hla._ext( "BLOB_CATI64" );

	cati64Size:
		procedure
		( 
			dest:blob; 
			i64:qword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI64SIZE" );

	cati128:
		procedure( dest:blob;  i128:lword );
		@global:_hla._ext( "BLOB_CATI128" );

	cati128Size:
		procedure
		( 
			dest:blob; 
			i128:lword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI128SIZE" );







	puti8:
		procedure( dest:blob;  i8:byte );
		@global:_hla._ext( "BLOB_CATI8" );

	puti8Size:
		procedure
		( 
			dest:blob;
			i8:byte; 
			width:int32; 
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI8SIZE" );

	puti16:
		procedure( dest:blob;  i16:word );
		@global:_hla._ext( "BLOB_CATI16" );

	puti16Size:
		procedure
		( 
			dest:blob;
			i16:word; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI16SIZE" );

	puti32:
		procedure( dest:blob;  i32:dword );
		@global:_hla._ext( "BLOB_CATI32" );

	puti32Size:
		procedure
		( 
			dest:blob; 
			i32:dword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI32SIZE" );

	puti64:
		procedure( dest:blob;  i64:qword );
		@global:_hla._ext( "BLOB_CATI64" );

	puti64Size:
		procedure
		( 
			dest:blob; 
			i64:qword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI64SIZE" );

	puti128:
		procedure( dest:blob;  i128:lword );
		@global:_hla._ext( "BLOB_CATI128" );

	puti128Size:
		procedure
		( 
			dest:blob; 
			i128:lword; 
			width:int32;
			fill:char 
		);
		@global:_hla._ext( "BLOB_CATI128SIZE" );








	catr80:
		procedure
		( 
			dest	:blob; 
			r		:real80; 
			width	:uns32; 
			decpts	:uns32;
			fill	:char
		);
		@global:_hla._ext( "BLOB_CATR80" );

	catr64:
		procedure
		( 
			dest	:blob; 
			r		:real64; 
			width	:uns32; 
			decpts	:uns32;
			fill	:char
		);
		@global:_hla._ext( "BLOB_CATR64" );

	catr32:
		procedure
		( 
			dest	:blob; 
			r		:real32; 
			width	:uns32; 
			decpts	:uns32;
			fill	:char
		);
		@global:_hla._ext( "BLOB_CATR32" );








	putr80:
		procedure
		( 
			dest	:blob; 
			r		:real80; 
			width	:uns32; 
			decpts	:uns32;
			fill	:char
		);
		@global:_hla._ext( "BLOB_CATR80" );

	putr64:
		procedure
		( 
			dest	:blob; 
			r		:real64; 
			width	:uns32; 
			decpts	:uns32;
			fill	:char
		);
		@global:_hla._ext( "BLOB_CATR64" );

	putr32:
		procedure
		( 
			dest	:blob; 
			r		:real32; 
			width	:uns32; 
			decpts	:uns32;
			fill	:char
		);
		@global:_hla._ext( "BLOB_CATR32" );






	cate80:
		procedure
		( 
			dest	:blob; 
			r		:real80; 
			width	:uns32 
		);
		@global:_hla._ext( "BLOB_CATE80" );


	cate64:
		procedure
		( 
			dest	:blob; 
			r		:real64; 
			width	:uns32 
		);
		@global:_hla._ext( "BLOB_CATE64" );


	cate32:
		procedure
		( 
			dest	:blob; 
			r		:real32; 
			width	:uns32 
		);
		@global:_hla._ext( "BLOB_CATE32" );






	pute80:
		procedure
		( 
			dest	:blob; 
			r		:real80; 
			width	:uns32 
		);
		@global:_hla._ext( "BLOB_CATE80" );


	pute64:
		procedure
		( 
			dest	:blob; 
			r		:real64; 
			width	:uns32 
		);
		@global:_hla._ext( "BLOB_CATE64" );


	pute32:
		procedure
		( 
			dest	:blob; 
			r		:real32; 
			width	:uns32 
		);
		@global:_hla._ext( "BLOB_CATE32" );






	// The following macros provide the same interface to cate32, cate64,
	// and cate80 as the plain (without size/fill char) integer output
	// routines:
		
	
	#macro _cate80( _cate80_s_, _cate80_r_ );
	
		@global:blob.cate80( _cate80_s_, _cate80_r_, 28 )
		
	#endmacro

	#macro _cate64( _cate64_s_, _cate64_r_ );
	
		@global:blob.cate64( _cate64_s_, _cate64_r_, 22 )
		
	#endmacro

	#macro _cate32( _cate32_s_, _cate32_r_ );
	
		@global:blob.cate32( _cate32_s_, _cate32_r_, 15 )
		
	#endmacro


	// The following macros provide the same interface (for the cat macro)
	// as the integerSize functions:
	
	#macro cate80_( _cate80_s_, _cate80_r_, _cate80_w_, _cate80_f_ );
	
		@global:blob.cate80( _cate80_s_, _cate80_r_, _cate80_w_ )
		
	#endmacro


	#macro cate64_( _cate64_s_, _cate64_r_, _cate64_w_, _cate64_f_ );
	
		@global:blob.cate64( _cate64_s_, _cate64_r_, _cate64_w_ )
		
	#endmacro


	#macro cate32_( _cate32_s_, _cate32_r_, _cate32_w_, _cate32_f_ );
	
		@global:blob.cate32( _cate32_s_, _cate32_r_, _cate32_w_ )
		
	#endmacro





	// Blob stream input functions:
	

proc
	readLn:
		procedure( src:blob );
		@global:_hla._ext( "BLOB_READLN" );

	eoln:
		procedure( src:blob ) {@returns( "al" )}; 
		@global:_hla._ext( "BLOB_EOLN" );


	getc:
		procedure( src:blob  ) {@returns( "al" )}; 
		@global:_hla._ext( "BLOB_GETC" );

	gets:
		procedure( src:blob; s:string );
		@global:_hla._ext( "BLOB_GETS" );

	a_gets:
		procedure( src:blob  );
		@global:_hla._ext( "BLOB_A_GETS" );


	geti8:
		procedure( src:blob  ) {@returns( "al" )}; 
		@global:_hla._ext( "BLOB_GETI8" );

	geti16:
		procedure( src:blob  ){ @returns( "ax" )}; 
		@global:_hla._ext( "BLOB_GETI16" );

	geti32:
		procedure( src:blob  ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_GETI32" );

	geti64:
		procedure( src:blob  ) {@returns( "edx:eax" )}; 
		@global:_hla._ext( "BLOB_GETI64" );

	geti128:
		procedure( src:blob; var dest:lword );
		@global:_hla._ext( "BLOB_GETI128" );


	getu8:
		procedure( src:blob  ) {@returns( "al" )}; 
			@global:_hla._ext( "BLOB_GETU8" );

	getu16:
		procedure( src:blob  ){ @returns( "ax" )}; 
		@global:_hla._ext( "BLOB_GETU16" );

	getu32:
		procedure( src:blob  ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_GETU32" );

	getu64:
		procedure( src:blob ) {@returns( "edx:eax" )}; 
		@global:_hla._ext( "BLOB_GETU64" );

	getu128:
		procedure( src:blob; var dest:lword );
		@global:_hla._ext( "BLOB_GETU128" );


	geth8:
		procedure( src:blob  ) {@returns( "al" )}; 
		@global:_hla._ext( "BLOB_GETH8" );

	geth16:
		procedure( src:blob  ){ @returns( "ax" )}; 
		@global:_hla._ext( "BLOB_GETH16" );

	geth32:
		procedure( src:blob  ) {@returns( "eax" )}; 
		@global:_hla._ext( "BLOB_GETH32" );

	geth64:
		procedure( src:blob  ) {@returns( "edx:eax" )}; 
		@global:_hla._ext( "BLOB_GETH64" );

	geth128:
		procedure( src:blob; var dest:lword );
		@global:_hla._ext( "BLOB_GETH128" );


	getf:
		procedure( src:blob ) {@returns( "st0" )}; 
		@global:_hla._ext( "BLOB_GETF" );



	




const
	validPutType :boolean[ @global:hla.sizePTypes ] :=
		[
			@global:false,		// Undefined
			@global:true,		// tBoolean 	//1
			@global:false,		// enum			//2
			@global:true,		// tUns8,		//3
			@global:true,		// tUns16,		//4
			@global:true,		// tUns32,		//5
			@global:true,		// tUns64,		//6
			@global:true,		// tUns128,		//7
			@global:true,		// tByte,		//8
			@global:true,		// tWord,		//9
			@global:true,		// tDWord,		//10
			@global:true,		// tQWord,		//11
			@global:true,		// tTByte,		//12
			@global:true,		// tLWord,		//13
			@global:true,		// tInt8,		//14
			@global:true,		// tInt16,		//15
			@global:true,		// tInt32,		//16
			@global:true,		// tInt64,		//17
			@global:true,		// tInt128,		//18
			@global:true,		// tChar, 		//19
			@global:false,		// tWChar,		//20
			@global:true,		// tReal32,		//21
			@global:true,		// tReal64, 	//22
			@global:true,		// tReal80,		//23
			@global:false,		// tReal128,	//24
			@global:true,		// tblob,		//25
			@global:true,		// tzstring,	//26
			@global:false,		// tWString,	//27
			@global:true,		// tCset,		//28
			@global:false,		// tArray,		//29
			@global:false,		// tRecord,		//30
			@global:false,		// tUnion,		//31
			@global:false,		// tRegEx		//32
			@global:true,		// tClass,		//33
			@global:false,		// tProcptr,	//34
			@global:false,		// tThunk,		//35
			@global:true,		// tPointer		//36
			@global:false,		// tLabel		//37
			@global:false,		// tProc		//38
			@global:false,		// tMethod		//39
			@global:false,		// tClassProc	//40
			@global:false,		// tClassIter	//41
			@global:false,		// tIterator	//42
			@global:false,		// tProgram		//43
			@global:false,		// tMacro		//44
			@global:false,		// tOverload	//45
			@global:false,		// tText		//46
			@global:false,		// tRegExMac	//47
			@global:false,		// tNamespace	//48
			@global:false,		// tSegment		//49
			@global:false,		// tAnonRec		//50
			@global:false,		// tAnonUnion	//51
			@global:false,		// tVariant		//52
			@global:false		// tError		//53
		];

	validPutSizeType :boolean[ @global:hla.sizePTypes ] :=
		[
			@global:false,		// Undefined
			@global:false,		// tBoolean 	//1
			@global:false,		// enum			//2
			@global:true,		// tUns8,		//3
			@global:true,		// tUns16,		//4
			@global:true,		// tUns32,		//5
			@global:true,		// tUns64,		//6
			@global:true,		// tUns128,		//7
			@global:true,		// tByte,		//8
			@global:true,		// tWord,		//9
			@global:true,		// tDWord,		//10
			@global:true,		// tQWord,		//11
			@global:true,		// tTByte,		//12
			@global:true,		// tLWord,		//13
			@global:true,		// tInt8,		//14
			@global:true,		// tInt16,		//15
			@global:true,		// tInt32,		//16
			@global:true,		// tInt64,		//17
			@global:true,		// tInt128,		//18
			@global:true,		// tChar, 		//19
			@global:false,		// tWChar,		//20
			@global:true,		// tReal32,		//21
			@global:true,		// tReal64, 	//22
			@global:true,		// tReal80,		//23
			@global:false,		// tReal128,	//24
			@global:true,		// tstring,		//25
			@global:true,		// tZstring,	//26
			@global:false,		// tWblob,	//27
			@global:false,		// tCset,		//28
			@global:false,		// tArray,		//29
			@global:false,		// tRecord,		//30
			@global:false,		// tUnion,		//31
			@global:false,		// tRegEx		//32
			@global:false,		// tClass,		//33
			@global:false,		// tProcptr,	//34
			@global:false,		// tThunk,		//35
			@global:true,		// tPointer		//36
			@global:false,		// tLabel		//37
			@global:false,		// tProc		//38
			@global:false,		// tMethod		//39
			@global:false,		// tClassProc	//40
			@global:false,		// tClassIter	//41
			@global:false,		// tIterator	//42
			@global:false,		// tProgram		//43
			@global:false,		// tMacro		//44
			@global:false,		// tOverloads	//45
			@global:false,		// tText		//46
			@global:false,		// tRegExMac	//47
			@global:false,		// tNamespace	//48
			@global:false,		// tSegment		//49
			@global:false,		// tAnonRec		//50
			@global:false,		// tAnonUnion	//51
			@global:false,		// tVariant		//52
			@global:false		// tError		//53
		];										  




	validPutSize2Type :boolean[ @global:hla.sizePTypes ] :=
		[
			@global:false,		// Undefined
			@global:false,		// tBoolean 	//1
			@global:false,		// enum			//2
			@global:false,		// tUns8,		//3
			@global:false,		// tUns16,		//4
			@global:false,		// tUns32,		//5
			@global:false,		// tUns64,		//6
			@global:false,		// tUns128,		//7
			@global:false,		// tByte,		//8
			@global:false,		// tWord,		//9
			@global:false,		// tDWord,		//10
			@global:false,		// tQWord,		//11
			@global:false,		// tTByte,		//12
			@global:false,		// tLWord,		//13
			@global:false,		// tInt8,		//14
			@global:false,		// tInt16,		//15
			@global:false,		// tInt32,		//16
			@global:false,		// tInt64,		//17
			@global:false,		// tInt128,		//18
			@global:false,		// tChar, 		//19
			@global:false,		// tWChar,		//20
			@global:true,		// tReal32,		//21
			@global:true,		// tReal64, 	//22
			@global:true,		// tReal80,		//23
			@global:false,		// tReal128,	//24
			@global:false,		// tstring,		//25
			@global:false,		// tZstring,	//26
			@global:false,		// tWstring,	//27
			@global:false,		// tCset,		//28
			@global:false,		// tArray,		//29
			@global:false,		// tRecord,		//30
			@global:false,		// tUnion,		//31
			@global:false,		// tRegEx		//32
			@global:false,		// tClass,		//33
			@global:false,		// tProcptr,	//34
			@global:false,		// tThunk,		//35
			@global:false,		// tPointer		//36
			@global:false,		// tLabel		//37
			@global:false,		// tProc		//38
			@global:false,		// tMethod		//39
			@global:false,		// tClassProc	//40
			@global:false,		// tClassIter	//41
			@global:false,		// tIterator	//42
			@global:false,		// tProgram		//43
			@global:false,		// tMacro		//44
			@global:false,		// tOverloads	//45
			@global:false,		// tText		//46
			@global:false,		// tRegExMac	//47
			@global:false,		// tNamespace	//48
			@global:false,		// tSegment		//49
			@global:false,		// tAnonRec		//50
			@global:false,		// tAnonUnion	//51
			@global:false,		// tVariant		//52
			@global:false		// tError		//53
		];										  



	putFunc :string[ @global:hla.sizePTypes ] :=
		[
			"",				// Undefined
			"catbool",		// tBoolean 	//1
			"",				// enum			//2
			"catu8",		// tUns8,		//3
			"catu16",		// tUns16,		//4
			"catu32",		// tUns32,		//5
			"catu64",		// tUns64,		//6
			"catu128",		// tUns128,		//7
			"catb",			// tByte,		//8
			"catw",			// tWord,		//9
			"catd",			// tDWord,		//10
			"catq",			// tQWord,		//11
			"cattb",		// tTByte,		//12
			"catl",			// tLWord,		//13
			"cati8",		// tInt8,		//14
			"cati16",		// tInt16,		//15
			"cati32",		// tInt32,		//16
			"cati64",		// tInt64,		//17
			"cati128",		// tInt128,		//18
			"catc",			// tChar, 		//19
			"",				// tWChar,		//20
			"_cate32",		// tReal32,		//21
			"_cate64",		// tReal64, 	//22
			"_cate80",		// tReal80,		//23
			"",				// tReal128,	//24
			"cats",			// tstring,		//25
			"catzs",		// tZstring,	//26
			"",				// tWstring,	//27
			"catcset",		// tCset,		//28
			"",				// tArray,		//29
			"",				// tRecord,		//30
			"",				// tUnion,		//31
			"",				// tRegEx		//32
			"",				// tClass,		//33
			"",				// tProcptr,	//34
			"",				// tThunk,		//35
			"catd",			// tPointer		//36
			"",				// tLabel		//37
			"",				// tProc		//38
			"",				// tMethod		//39
			"",				// tClassProc	//40
			"",				// tClassIter	//41
			"",				// tIterator	//42
			"",				// tProgram		//43
			"",				// tMacro		//44
			"",				// tOverloads	//45
			"",				// tText		//46
			"",				// tRegExMac	//47
			"",				// tNamespace	//48
			"",				// tSegment		//49
			"",				// tAnonRec		//50
			"",				// tAnonUnion	//51
			"",				// tVariant		//52
			""				// tError		//53
		];


	putSizeFunc :string[ @global:hla.sizePTypes ] :=
		[
			"",					// Undefined
			"",					// tBoolean 	//1
			"",					// enum			//2
			"catu8Size",		// tUns8,		//3
			"catu16Size",		// tUns16,		//4
			"catu32Size",		// tUns32,		//5
			"catu64Size",		// tUns64,		//6
			"catu128Size",		// tUns128,		//7
			"cath8Size",		// tByte,		//8
			"cath16Size",		// tWord,		//9
			"cath32Size",		// tDWord,		//10
			"cath64Size",		// tQWord,		//11
			"cath80Size",		// tTByte,		//12
			"cath128Size",		// tLWord,		//13
			"cati8Size",		// tInt8,		//14
			"cati16Size",		// tInt16,		//15
			"cati32Size",		// tInt32,		//16
			"cati64Size",		// tInt64,		//17
			"cati128Size",		// tInt128,		//18
			"catcSize",			// tChar, 		//19
			"",					// tWChar,		//20
			"cate32_",			// tReal32,		//21
			"cate64_",			// tReal64, 	//22
			"cate80_",			// tReal80,		//23
			"",					// tReal128,	//24
			"catsSize",			// tstring,		//25
			"catzsSize",		// tZstring,	//26
			"",					// tWstring,	//27
			"",					// tCset,		//28
			"",					// tArray,		//29
			"",					// tRecord,		//30
			"",					// tUnion,		//31
			"",					// tRegEx		//32
			"",					// tClass,		//33
			"",					// tProcptr,	//34
			"",					// tThunk,		//35
			"catdSize",			// tPointer		//36
			"",					// tLabel		//37
			"",					// tProc		//38
			"",					// tMethod		//39
			"",					// tClassProc	//40
			"",					// tClassIter	//41
			"",					// tIterator	//42
			"",					// tProgram		//43
			"",					// tMacro		//44
			"",					// tOverloads	//45
			"",					// tText		//46
			"",					// tRegExMac	//47
			"",					// tNamespace	//48
			"",					// tSegment		//49
			"",					// tAnonRec		//50
			"",					// tAnonUnion	//51
			"",					// tVariant		//52
			""					// tError		//53
		];										  


	putSize2Func :string[ @global:hla.sizePTypes ] :=
		[
			"",					// Undefined
			"",					// tBoolean 	//1
			"",					// enum			//2
			"",					// tUns8,		//3
			"",					// tUns16,		//4
			"",					// tUns32,		//5
			"",					// tUns64,		//6
			"",					// tUns128,		//7
			"",					// tByte,		//8
			"",					// tWord,		//9
			"",					// tDWord,		//10
			"",					// tQWord,		//11
			"",					// tLWord,		//12
			"",					// tLWord,		//13
			"",					// tInt8,		//14
			"",					// tInt16,		//15
			"",					// tInt32,		//16
			"",					// tInt64,		//17
			"",					// tInt128,		//18
			"",					// tChar, 		//19
			"",					// tWChar,		//20
			"catr32pad",		// tReal32,		//21
			"catr64pad",		// tReal64, 	//22
			"catr80pad",		// tReal80,		//23
			"",					// tReal128,	//24
			"",					// tstring,		//25
			"",					// tZstring,	//26
			"",					// tWstring,	//27
			"",					// tCset,		//28
			"",					// tArray,		//29
			"",					// tRecord,		//30
			"",					// tUnion,		//31
			"",					// tRegEx		//32
			"",					// tClass,		//33
			"",					// tProcptr,	//34
			"",					// tThunk,		//35
			"",					// tPointer		//36
			"",					// tLabel		//37
			"",					// tProc		//38
			"",					// tMethod		//39
			"",					// tClassProc	//40
			"",					// tClassIter	//41
			"",					// tIterator	//42
			"",					// tProgram		//43
			"",					// tMacro		//44
			"",					// tOverloads	//45
			"",					// tText		//46
			"",					// tRegExMac	//47
			"",					// tNamespace	//48
			"",					// tSegment		//49
			"",					// tAnonRec		//50
			"",					// tAnonUnion	//51
			"",					// tVariant		//52
			""					// tError		//53
		];										  


	// blob.put macros:
	// (note: use global VAL objects to speed up processing:
	
val
	_theParm_:string;
	_theDest_:string;
	
	#macro resetPut( _destBLOB_, _parameters_[] ); 

		?@global:blob._theDest_ := @string:_destBLOB_;
		push( eax );
		mov( _destBLOB_, eax );
		mov( 0, (type blob.blobRec [eax]).length );
		mov( 0, (type blob.blobRec [eax]).wcursor );
		mov( 0, (type blob.blobRec [eax]).rcursor );
		mov( 0, (type byte [eax]) );
		pop( eax );
		?@global:blob._theParm_ :string := @string:_destBLOB_;
		#for( @global:blob._theParm_ in _parameters_ )

			@global:hla.put
			( 
				str, 
				@global:blob._theDest_, 
				@eval(@global:blob._theParm_) 
			)

		#endfor

	#endmacro



	// blob.put macro:
	
val
	_theParm2_:string;
	_theDest2_:string;

	#macro put( _destBLOB_, _parameters_[] );_sv_; 

		?@global:blob._theDest2_ := @string:_destBLOB_;
			
		#for( @global:blob._theParm2_ in _parameters_ )

			@global:hla.put
			( 
				str, 
				@global:blob._theDest2_, 
				@eval(@global:blob._theParm2_) 
			)

		#endfor

	#endmacro








	/*
	** GET macro for blob input.
	*/



	#macro get( _get_blobVar_, _parms_[] ); 
		_curparm_, _pType_, _arg_, _id_, _tempid_;

		?_curparm_:uns32 := 0;
		
		// Save important registers that the "GET" macro uses.

		push( eax );

		// The following loop repeats once for each GET parameter
		// we process.

		#while( _curparm_ < @elements( _parms_ ))

			// If this parameter begins with an identifier,
			// there are some problems to deal with.
			// The symbol table functions (e.g., @ptype) don't
			// allow address expression components after the
			// symbol name.  Named constants, however, do allow
			// such entities.  The following code determines
			// (1) is this a symbol?  (2) if it is a symbol, is
			// it a constant?
			//
			//	For non-constant symbols, we need to strip any
			// trailing non-symbol characters from the string
			// (e.g., "[0]" ).

			?_arg_ := @trim( _parms_[ _curparm_ ], 0 );
			#if( char( _arg_ ) in stdio._idchars_ )

				// If this parameter begins with an id character,
				// then strip away any non-ID symbols from the
				// end of the string.  Then determine if we've
				// got a constant or some other class (e.g.,
				// variable or procedure).  If not a constant,
				// keep only the name.  If a constant, we need
				// to keep all trailing characters as well.

				?_id_ := stdio._GetID_( _arg_ );
				#if
				( 
						@class( @text( _id_ )) = hla.cConstant 
					|	@class( @text( _id_ )) = hla.cValue 
				)

					?_id_ := _arg_;

				#endif

			#else

				// If it's not an ID, we need to keep everything.

				?_id_ := _arg_;

			#endif



			// Determine the type of this parameter so we can
			// call the appropriate routine to input it.

			?_pType_ := @pType( @text( _id_ ));
			?_tempid_ := _id_;
			#while( _pType_ = hla.ptArray )

				?_tempid_ := @typename( @text( _tempid_ ));
				?_pType_ := @pType( @text( _tempid_ ));

			#endwhile

			// Based on the type, call the appropriate library
			// routine to print this value.

			#if( _pType_ = hla.ptBoolean )

				#error( "Boolean input is not supported" );

			#elseif( _pType_ = hla.ptUns8 ) 
				
				blob.getu8( _get_blobVar_ );
				#if( _arg_ = "al" )

					mov( al, [esp] );

				#elseif( _arg_ = "ah" )

					mov( al, [esp+1] );

				#else

					mov( al, @text( _arg_ ));

				#endif

			#elseif( _pType_ = hla.ptUns16 ) 
				
				blob.getu16( _get_blobVar_ );
				#if( _arg_ = "ax" )

					mov( ax, [esp] );

				#else

					mov( ax, @text( _arg_ ));

				#endif

			#elseif( _pType_ = hla.ptUns32 ) 
				
				blob.getu32( _get_blobVar_ );
				#if( _arg_ = "eax" )

					mov( eax, [esp] );

				#else

					mov( eax, @text( _arg_ ));

				#endif

			#elseif( _pType_ = hla.ptUns64 ) 
				
				push( edx );
				blob.getu64( _get_blobVar_ );
				mov( eax, @text( "(type dword " + _arg_ + ")" ));
				mov( edx, @text( "(type dword " + _arg_ + "[4])" ));
				pop( edx );

			#elseif( _pType_ = hla.ptUns128 ) 
				
				blob.getu128( _get_blobVar_, @text( _arg_ ) );

			#elseif( _pType_ = hla.ptByte ) 
				
				blob.geth8( _get_blobVar_ );
				#if( _arg_ = "al" )

					mov( al, [esp] );

				#elseif( _arg_ = "ah" )

					mov( al, [esp+1] );

				#else

					mov( al, @text( _arg_ ));

				#endif

			#elseif( _pType_ = hla.ptWord ) 
				
				blob.geth16( _get_blobVar_ );
				#if( _arg_ = "ax" )

					mov( ax, [esp] );

				#else

					mov( ax, @text( _arg_ ));

				#endif

			#elseif( _pType_ = hla.ptDWord ) 
				
				blob.geth32( _get_blobVar_ );
				#if( _arg_ = "eax" )

					mov( eax, [esp] );

				#else

					mov( eax, @text( _arg_ ));

				#endif


			#elseif( _pType_ = hla.ptQWord ) 
				
				push( edx );
				blob.geth64( _get_blobVar_ );
				mov( eax, @text( "(type dword " + _arg_ + ")" ));
				mov( edx, @text( "(type dword " + _arg_ + "[4])" ));
				pop( edx );
				
			#elseif( _pType_ = hla.ptLWord ) 
				
				blob.geth128( _get_blobVar_, @text( _arg_ ) );

			#elseif( _pType_ = hla.ptInt8 ) 
				
				blob.geti8( _get_blobVar_ );
				#if( _arg_ = "al" )

					mov( al, [esp] );

				#elseif( _arg_ = "ah" )

					mov( al, [esp+1] );

				#else

					mov( al, @text( _arg_ ));

				#endif

			#elseif( _pType_ = hla.ptInt16 ) 
				
				blob.geti16( _get_blobVar_ );
				#if( _arg_ = "ax" )

					mov( ax, [esp] );

				#else

					mov( ax, @text( _arg_ ));

				#endif

			#elseif( _pType_ = hla.ptInt32 ) 
				
				blob.geti32( _get_blobVar_ );
				#if( _arg_ = "eax" )

					mov( eax, [esp] );

				#else

					mov( eax, @text( _arg_ ));

				#endif


			#elseif( _pType_ = hla.ptInt64 ) 
				
				push( edx );
				blob.geti64( _get_blobVar_ );
				mov( eax, @text( "(type dword " + _arg_ + ")" ));
				mov( edx, @text( "(type dword " + _arg_ + "[4])" ));
				pop( edx );

			#elseif( _pType_ = hla.ptInt128 ) 
				
				blob.geti128( _get_blobVar_, @text( _arg_ ) );

			#elseif( _pType_ = hla.ptChar ) 
				
				blob.getc( _get_blobVar_ );
				#if( _arg_ = "al" )

					mov( al, [esp] );

				#elseif( _arg_ = "ah" )

					mov( al, [esp+1] );

				#else

					mov( al, @text( _arg_ ));

				#endif

			#elseif( _pType_ = hla.ptCset ) 

				#error( "Cset input is not supported" );

			#elseif
			( 
					_pType_ = hla.ptReal32 
				|	_pType_ = hla.ptReal64 
				|	_pType_ = hla.ptReal80 
			) 
				
				blob.getf( _get_blobVar_ );
				fstp( @text( _arg_ ));

			#elseif( _pType_ = hla.ptString ) 

				#if( _arg_ = "eax" )

					blob.gets(  _get_blobVar_, [esp] );

				#else

					blob.gets(  _get_blobVar_, @text( _arg_ ));

				#endif

			#else

				#error
				( 
					"blob.get: Unknown data type (" +
					_parms_[ _curparm_ ] +
					":" +
					@typename( @text( _id_ )) +
					")"
				);

			#endif
			?_curparm_ := _curparm_ + 1;

		#endwhile

		// Restore the registers pushed earlier for this call to
		// the GET macro.  Note that this statement does not end
		// with a semicolon.  This is to force the programmer to
		// put a semicolon after the blob.get(--) invocation.

		pop( eax )

	#endmacro


end blob;

type
	blob_t	:blob.t;


#endif
