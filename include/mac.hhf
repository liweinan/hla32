#if( ! @defined( mac_hhf ))
?mac_hhf := true;

#if( ! @defined( errno_hhf ))
?errno_hhf := true;

#includeOnce( "hla.hhf" )

namespace errno; @fast;

  const
	eperm				:= 1;		/* Operation not permitted */
	enoent				:= 2;		/* No such file or directory */
	esrch				:= 3;		/* No such process */
	eintr				:= 4;		/* Interrupted system call */
	eio					:= 5;		/* Input/output error */
	enxio				:= 6;		/* Device not configured */
	e2big				:= 7;		/* Argument list too long */
	enoexec				:= 8;		/* Exec format error */
	ebadf				:= 9;		/* Bad file descriptor */
	echild				:= 10;		/* No child processes */
	edeadlk				:= 11;		/* Resource deadlock avoided */
	enomem				:= 12;		/* Cannot allocate memory */
	eacces				:= 13;		/* Permission denied */
	efault				:= 14;		/* Bad address */
	enotblk				:= 15;		/* Block device required */
	ebusy				:= 16;		/* Device busy */
	eexist				:= 17;		/* File exists */
	exdev				:= 18;		/* Cross-device link */
	enodev				:= 19;		/* Operation not supported by device */
	enotdir				:= 20;		/* Not a directory */
	eisdir				:= 21;		/* Is a directory */
	einval				:= 22;		/* Invalid argument */
	enfile				:= 23;		/* Too many open files in system */
	emfile				:= 24;		/* Too many open files */
	enotty				:= 25;		/* Inappropriate ioctl for device */
	etxtbsy				:= 26;		/* Text file busy */
	efbig				:= 27;		/* File too large */
	enospc				:= 28;		/* No space left on device */
	espipe				:= 29;		/* Illegal seek */
	erofs				:= 30;		/* Read-only filesystem */
	emlink				:= 31;		/* Too many links */
	epipe				:= 32;		/* Broken pipe */
	edom				:= 33;		/* Numerical argument out of domain */
	erange				:= 34;		/* Result too large */
	eagain				:= 35;		/* Resource temporarily unavailable */
	ewouldblock			:= eagain;	/* Operation would block */
	einprogress			:= 36;		/* Operation now in progress */
	enotsock			:= 38;		/* Socket operation on non-socket */
	edestaddrreq		:= 39;		/* Destination address required */
	emsgsize			:= 40;		/* Message too long */
	eprototype			:= 41;		/* Protocol wrong type for socket */
	enoprotoopt			:= 42;		/* Protocol not available */
	eprotonosupport		:= 43;		/* Protocol not supported */
	esocktnosupport		:= 44;		/* Socket type not supported */
	eopnotsupp			:= 45;		/* Operation not supported */
	enotsup				:= eopnotsupp;	/* Operation not supported */
	epfnosupport		:= 46;		/* Protocol family not supported */
	eafnosupport		:= 47;		/* Address family not supported by protocol family */
	eaddrinuse			:= 48;		/* Address already in use */
	eaddrnotavail		:= 49;		/* Can't assign requested address */
	enetdown			:= 50;		/* Network is down */
	enetunreach			:= 51;		/* Network is unreachable */
	enetreset			:= 52;		/* Network dropped connection on reset */
	econnaborted		:= 53;		/* Software caused connection abort */
	econnreset			:= 54;		/* Connection reset by peer */
	enobufs				:= 55;		/* No buffer space available */
	eisconn				:= 56;		/* Socket is already connected */
	enotconn			:= 57;		/* Socket is not connected */
	eshutdown			:= 58;		/* Can't send after socket shutdown */
	etoomanyrefs		:= 59;		/* Too many references: can't splice */
	etimedout			:= 60;		/* Operation timed out */
	econnrefused		:= 61;		/* Connection refused */
	eloop				:= 62;		/* Too many levels of symbolic links */
	enametoolong		:= 63;		/* File name too long */
	ehostdown			:= 64;		/* Host is down */
	ehostunreach		:= 65;		/* No route to host */
	enotempty			:= 66;		/* Directory not empty */
	eproclim			:= 67;		/* Too many processes */
	eusers				:= 68;		/* Too many users */
	edquot				:= 69;		/* Disc quota exceeded */
	estale				:= 70;		/* Stale NFS file handle */
	eremote				:= 71;		/* Too many levels of remote in path */
	ebadrpc				:= 72;		/* RPC struct is bad */
	erpcmismatch		:= 73;		/* RPC version wrong */
	eprogunavail		:= 74;		/* RPC prog. not avail */
	eprogmismatch		:= 75;		/* Program version wrong */
	eprocunavail		:= 76;		/* Bad procedure for program */
	enolck				:= 77;		/* No locks available */
	enosys				:= 78;		/* Function not implemented */
	eftype				:= 79;		/* Inappropriate file type or format */
	eauth				:= 80;		/* Authentication error */
	eneedauth			:= 81;		/* Need authenticator */
	eidrm				:= 82;		/* Identifier removed */
	enomsg				:= 83;		/* No message of desired type */
	eoverflow			:= 84;		/* Value too large to be stored in data type */
	ecanceled			:= 85;		/* Operation canceled */
	eilseq				:= 86;		/* Illegal byte sequence */
	enoattr				:= 87;		/* Attribute not found */
	edoofus				:= 88;		/* Programming error */
	ebadmsg				:= 89;		/* Bad message */
	emultihop			:= 90;		/* Multihop attempted */
	enolink				:= 91;		/* Link has been severed */
	eproto				:= 92;		/* Protocol error */
	elast				:= 92;		/* Must be equal largest errno */
	
		
end errno;

#endif

namespace mac; @fast;

	
	const
	
		ETIMEDOUT	:= @global:errno.etimedout;
		
	#macro pushregs;
	
		push( ebx );
		push( ecx );
		push( edx );
		push( esi );
		push( edi );
		
	#endmacro
	
	#macro popregs;
	
		pop( edi );
		pop( esi );
		pop( edx );
		pop( ecx );
		pop( ebx );
		
	#endmacro
	
	#macro saveregs;
	
		mov( ebx, ebxSave );
		mov( ecx, ecxSave );
		mov( edx, edxSave );
		mov( esi, esiSave );
		mov( edi, ediSave );
		
	#endmacro
	
	#macro restoreregs;
	
		mov( ebxSave, ebx );
		mov( ecxSave, ecx );
		mov( edxSave, edx );
		mov( esiSave, esi );
		mov( ediSave, edi );
		
	#endmacro
		

const

	sys_syscall                              := 0;
	sys_exit                                 := 1;
	sys_fork                                 := 2;
	sys_read                                 := 3;
	sys_write                                := 4;
	sys_open                                 := 5;
	sys_close                                := 6;
	sys_wait4                                := 7;
	// 8  old creat 
	sys_link                                 := 9;
	sys_unlink                               := 10;
	// 11  old execv 
	sys_chdir                                := 12;
	sys_fchdir                               := 13;
	sys_mknod                                := 14;
	sys_chmod                                := 15;
	sys_chown                                := 16;
	sys_obreak                               := 17;
	sys_ogetfsstat                           := 18;
	sys_getfsstat                            := 18;
	// 19  old lseek 
	sys_getpid                               := 20;
	// 21  old mount 
	// 22  old umount 
	sys_setuid                               := 23;
	sys_getuid                               := 24;
	sys_geteuid                              := 25;
	sys_ptrace                               := 26;
	sys_recvmsg                              := 27;
	sys_sendmsg                              := 28;
	sys_recvfrom                             := 29;
	sys_accept                               := 30;
	sys_getpeername                          := 31;
	sys_getsockname                          := 32;
	sys_access                               := 33;
	sys_chflags                              := 34;
	sys_fchflags                             := 35;
	sys_sync                                 := 36;
	sys_kill                                 := 37;
	// 38  old stat 
	sys_getppid                              := 39;
	// 40  old lstat 
	sys_dup                                  := 41;
	sys_pipe                                 := 42;
	sys_getegid                              := 43;
	sys_profil                               := 44;
	// 45  old ktrace 
	sys_sigaction                            := 46;
	sys_getgid                               := 47;
	sys_sigprocmask                          := 48;
	sys_getlogin                             := 49;
	sys_setlogin                             := 50;
	sys_acct                                 := 51;
	sys_sigpending                           := 52;
	sys_sigaltstack                          := 53;
	sys_ioctl                                := 54;
	sys_reboot                               := 55;
	sys_revoke                               := 56;
	sys_symlink                              := 57;
	sys_readlink                             := 58;
	sys_execve                               := 59;
	sys_umask                                := 60;
	sys_chroot                               := 61;
	// 62  old fstat 
	// 63  used internally , reserved 
	// 64  old getpagesize 
	sys_msync                                := 65;
	sys_vfork                                := 66;
	// 67  old vread 
	// 68  old vwrite 
	sys_sbrk                                 := 69;
	sys_sstk                                 := 70;
	// 71  old mmap 
	sys_ovadvise                             := 72;
	sys_munmap                               := 73;
	sys_mprotect                             := 74;
	sys_madvise                              := 75;
	// 76  old vhangup 
	// 77  old vlimit 
	sys_mincore                              := 78;
	sys_getgroups                            := 79;
	sys_setgroups                            := 80;
	sys_getpgrp                              := 81;
	sys_setpgid                              := 82;
	sys_setitimer                            := 83;
	// 84  old wait 
	sys_swapon                               := 85;
	sys_getitimer                            := 86;
	// 87  old gethostname 
	// 88  old sethostname 
	sys_getdtablesize                        := 89;
	sys_dup2                                 := 90;
	// 91  old getdopt 
	sys_fcntl                                := 92;
	sys_select                               := 93;
	// 94  old setdopt 
	sys_fsync                                := 95;
	sys_setpriority                          := 96;
	sys_socket                               := 97;
	sys_connect                              := 98;
	// 99  old accept 
	sys_getpriority                          := 100;
	// 101  old send 
	// 102  old recv 
	// 103  old sigreturn 
	sys_bind                                 := 104;
	sys_setsockopt                           := 105;
	sys_listen                               := 106;
	// 107  old vtimes 
	// 108  old sigvec 
	// 109  old sigblock 
	// 110  old sigsetmask 
	sys_sigsuspend                           := 111;
	// 112  old sigstack 
	// 113  old recvmsg 
	// 114  old sendmsg 
	// 115  old vtrace 
	sys_gettimeofday                         := 116;
	sys_getrusage                            := 117;
	sys_getsockopt                           := 118;
	// 119  old resuba 
	sys_readv                                := 120;
	sys_writev                               := 121;
	sys_settimeofday                         := 122;
	sys_fchown                               := 123;
	sys_fchmod                               := 124;
	// 125  old recvfrom 
	sys_setreuid                             := 126;
	sys_setregid                             := 127;
	sys_rename                               := 128;
	// 129  old truncate 
	// 130  old ftruncate 
	sys_flock                                := 131;
	sys_mkfifo                               := 132;
	sys_sendto                               := 133;
	sys_shutdown                             := 134;
	sys_socketpair                           := 135;
	sys_mkdir                                := 136;
	sys_rmdir                                := 137;
	sys_utimes                               := 138;
	sys_futimes                              := 139;
	sys_adjtime                              := 140;
	// 141  old getpeername 
	sys_gethostuuid                          := 142;
	// 143  old sethostid 
	// 144  old getrlimit 
	// 145  old setrlimit 
	// 146  old killpg 
	sys_setsid                               := 147;
	// 148  old setquota 
	// 149  old qquota 
	// 150  old getsockname 
	sys_getpgid                              := 151;
	sys_setprivexec                          := 152;
	sys_pread                                := 153;
	sys_pwrite                               := 154;
	sys_nfssvc                               := 155;
	// 156  old getdirentries 
	sys_statfs                               := 157;
	sys_fstatfs                              := 158;
	sys_unmount                              := 159;
	// 160  old async_daemon 
	sys_getfh                                := 161;
	// 162  old getdomainname 
	// 163  old setdomainname 
	// 164  
	sys_quotactl                             := 165;
	// 166  old exportfs 
	sys_mount                                := 167;
	// 168  old ustat 
	sys_csops                                := 169;
	sys_table                                := 170;
	// 171  old wait3 
	// 172  old rpause 
	sys_waitid                               := 173;
	// 174  old getdents 
	// 175  old gc_control 
	sys_add_profil                           := 176;
	// 177  
	// 178  
	// 179  
	sys_kdebug_trace                         := 180;
	sys_setgid                               := 181;
	sys_setegid                              := 182;
	sys_seteuid                              := 183;
	sys_sigreturn                            := 184;
	sys_chud                                 := 185;
	// 186  
	// 187  
	sys_stat                                 := 188;
	sys_fstat                                := 189;
	sys_lstat                                := 190;
	sys_pathconf                             := 191;
	sys_fpathconf                            := 192;
	// 193  
	sys_getrlimit                            := 194;
	sys_setrlimit                            := 195;
	sys_getdirentries                        := 196;
	sys_mmap                                 := 197;
	// 198  __syscall 
	sys_lseek                                := 199;
	sys_truncate                             := 200;
	sys_ftruncate                            := 201;
	sys___sysctl                             := 202;
	sys_mlock                                := 203;
	sys_munlock                              := 204;
	sys_undelete                             := 205;
	sys_atsocket                             := 206;
	sys_atgetmsg                             := 207;
	sys_atputmsg                             := 208;
	sys_atpsndreq                            := 209;
	sys_atpsndrsp                            := 210;
	sys_atpgetreq                            := 211;
	sys_atpgetrsp                            := 212;
	// 213  reserved for appletalk 
	sys_kqueue_from_portset_np               := 214;
	sys_kqueue_portset_np                    := 215;
	sys_mkcomplex                            := 216;
	sys_statv                                := 217;
	sys_lstatv                               := 218;
	sys_fstatv                               := 219;
	sys_getattrlist                          := 220;
	sys_setattrlist                          := 221;
	sys_getdirentriesattr                    := 222;
	sys_exchangedata                         := 223;
	// 224  was checkuseraccess 
	sys_searchfs                             := 225;
	sys_delete                               := 226;
	sys_copyfile                             := 227;
	// 228  
	// 229  
	sys_poll                                 := 230;
	sys_watchevent                           := 231;
	sys_waitevent                            := 232;
	sys_modwatch                             := 233;
	sys_getxattr                             := 234;
	sys_fgetxattr                            := 235;
	sys_setxattr                             := 236;
	sys_fsetxattr                            := 237;
	sys_removexattr                          := 238;
	sys_fremovexattr                         := 239;
	sys_listxattr                            := 240;
	sys_flistxattr                           := 241;
	sys_fsctl                                := 242;
	sys_initgroups                           := 243;
	sys_posix_spawn                          := 244;
	// 245  
	// 246  
	sys_nfsclnt                              := 247;
	sys_fhopen                               := 248;
	// 249  
	sys_minherit                             := 250;
	sys_semsys                               := 251;
	sys_msgsys                               := 252;
	sys_shmsys                               := 253;
	sys_semctl                               := 254;
	sys_semget                               := 255;
	sys_semop                                := 256;
	// 257  
	sys_msgctl                               := 258;
	sys_msgget                               := 259;
	sys_msgsnd                               := 260;
	sys_msgrcv                               := 261;
	sys_shmat                                := 262;
	sys_shmctl                               := 263;
	sys_shmdt                                := 264;
	sys_shmget                               := 265;
	sys_shm_open                             := 266;
	sys_shm_unlink                           := 267;
	sys_sem_open                             := 268;
	sys_sem_close                            := 269;
	sys_sem_unlink                           := 270;
	sys_sem_wait                             := 271;
	sys_sem_trywait                          := 272;
	sys_sem_post                             := 273;
	sys_sem_getvalue                         := 274;
	sys_sem_init                             := 275;
	sys_sem_destroy                          := 276;
	sys_open_extended                        := 277;
	sys_umask_extended                       := 278;
	sys_stat_extended                        := 279;
	sys_lstat_extended                       := 280;
	sys_fstat_extended                       := 281;
	sys_chmod_extended                       := 282;
	sys_fchmod_extended                      := 283;
	sys_access_extended                      := 284;
	sys_settid                               := 285;
	sys_gettid                               := 286;
	sys_setsgroups                           := 287;
	sys_getsgroups                           := 288;
	sys_setwgroups                           := 289;
	sys_getwgroups                           := 290;
	sys_mkfifo_extended                      := 291;
	sys_mkdir_extended                       := 292;
	sys_identitysvc                          := 293;
	sys_shared_region_check_np               := 294;
	sys_shared_region_map_np                 := 295;
	// 296  old load_shared_file 
	// 297  old reset_shared_file 
	// 298  old new_system_shared_regions 
	// 299  old shared_region_map_file_np 
	// 300  old shared_region_make_private_np 
	sys___pthread_mutex_destroy              := 301;
	sys___pthread_mutex_init                 := 302;
	sys___pthread_mutex_lock                 := 303;
	sys___pthread_mutex_trylock              := 304;
	sys___pthread_mutex_unlock               := 305;
	sys___pthread_cond_init                  := 306;
	sys___pthread_cond_destroy               := 307;
	sys___pthread_cond_broadcast             := 308;
	sys___pthread_cond_signal                := 309;
	sys_getsid                               := 310;
	sys_settid_with_pid                      := 311;
	sys___pthread_cond_timedwait             := 312;
	sys_aio_fsync                            := 313;
	sys_aio_return                           := 314;
	sys_aio_suspend                          := 315;
	sys_aio_cancel                           := 316;
	sys_aio_error                            := 317;
	sys_aio_read                             := 318;
	sys_aio_write                            := 319;
	sys_lio_listio                           := 320;
	sys___pthread_cond_wait                  := 321;
	sys_iopolicysys                          := 322;
	// 323  
	sys_mlockall                             := 324;
	sys_munlockall                           := 325;
	// 326  
	sys_issetugid                            := 327;
	sys___pthread_kill                       := 328;
	sys___pthread_sigmask                    := 329;
	sys___sigwait                            := 330;
	sys___disable_threadsignal               := 331;
	sys___pthread_markcancel                 := 332;
	sys___pthread_canceled                   := 333;
	sys___semwait_signal                     := 334;
	// 335  old utrace 
	sys_proc_info                            := 336;
	sys_sendfile                             := 337;
	sys_stat64                               := 338;
	sys_fstat64                              := 339;
	sys_lstat64                              := 340;
	sys_stat64_extended                      := 341;
	sys_lstat64_extended                     := 342;
	sys_fstat64_extended                     := 343;
	sys_getdirentries64                      := 344;
	sys_statfs64                             := 345;
	sys_fstatfs64                            := 346;
	sys_getfsstat64                          := 347;
	sys___pthread_chdir                      := 348;
	sys___pthread_fchdir                     := 349;
	sys_audit                                := 350;
	sys_auditon                              := 351;
	// 352  
	sys_getauid                              := 353;
	sys_setauid                              := 354;
	sys_getaudit                             := 355;
	sys_setaudit                             := 356;
	sys_getaudit_addr                        := 357;
	sys_setaudit_addr                        := 358;
	sys_auditctl                             := 359;
	sys_bsdthread_create                     := 360;
	sys_bsdthread_terminate                  := 361;
	sys_kqueue                               := 362;
	sys_kevent                               := 363;
	sys_lchown                               := 364;
	sys_stack_snapshot                       := 365;
	sys_bsdthread_register                   := 366;
	sys_workq_open                           := 367;
	sys_workq_ops                            := 368;
	// 369  
	// 370  
	// 371  
	// 372  
	// 373  
	// 374  
	// 375  
	// 376  
	// 377  
	// 378  
	// 379  
	sys___mac_execve                         := 380;
	sys___mac_syscall                        := 381;
	sys___mac_get_file                       := 382;
	sys___mac_set_file                       := 383;
	sys___mac_get_link                       := 384;
	sys___mac_set_link                       := 385;
	sys___mac_get_proc                       := 386;
	sys___mac_set_proc                       := 387;
	sys___mac_get_fd                         := 388;
	sys___mac_set_fd                         := 389;
	sys___mac_get_pid                        := 390;
	sys___mac_get_lcid                       := 391;
	sys___mac_get_lctx                       := 392;
	sys___mac_set_lctx                       := 393;
	sys_setlcid                              := 394;
	sys_getlcid                              := 395;
	sys_read_nocancel                        := 396;
	sys_write_nocancel                       := 397;
	sys_open_nocancel                        := 398;
	sys_close_nocancel                       := 399;
	sys_wait4_nocancel                       := 400;
	sys_recvmsg_nocancel                     := 401;
	sys_sendmsg_nocancel                     := 402;
	sys_recvfrom_nocancel                    := 403;
	sys_accept_nocancel                      := 404;
	sys_msync_nocancel                       := 405;
	sys_fcntl_nocancel                       := 406;
	sys_select_nocancel                      := 407;
	sys_fsync_nocancel                       := 408;
	sys_connect_nocancel                     := 409;
	sys_sigsuspend_nocancel                  := 410;
	sys_readv_nocancel                       := 411;
	sys_writev_nocancel                      := 412;
	sys_sendto_nocancel                      := 413;
	sys_pread_nocancel                       := 414;
	sys_pwrite_nocancel                      := 415;
	sys_waitid_nocancel                      := 416;
	sys_poll_nocancel                        := 417;
	sys_msgsnd_nocancel                      := 418;
	sys_msgrcv_nocancel                      := 419;
	sys_sem_wait_nocancel                    := 420;
	sys_aio_suspend_nocancel                 := 421;
	sys___sigwait_nocancel                   := 422;
	sys___semwait_signal_nocancel            := 423;
	sys___mac_mount                          := 424;
	sys___mac_get_mount                      := 425;
	sys___mac_getfsstat                      := 426;
	sys_maxsyscall                           := 427;
	
	// From MMAN.H
	
	PROT_NONE				:= 0;
	PROT_READ				:= 1;
	PROT_WRITE				:= 2;
	PROT_EXEC				:= 4;
	 
	MAP_FILE				:=      0;
	MAP_SHARED				:=      1;
	MAP_PRIVATE				:=      2;
	MAP_RENAME				:=    $20;
	MAP_NORESERVE			:=    $40;
	MAP_RESERVED0080		:=    $80;
	MAP_RESERVED0100		:=   $100;
	MAP_HASSEMAPHORE		:=   $200;
	MAP_STACK				:=   $400;
	MAP_NOSYNC				:=   $800;
	MAP_ANON				:=  $1000;
	MAP_NOCORE				:= $20000;
	
	MCL_CURRENT				:= 1;
	MCL_FUTURE				:= 2;
	
	MAP_FAILED				:= -1;
	
	MS_SYNC					:= 0;
	MS_ASYNC				:= 1;
	MS_INVALIDATE			:= 2;
	
	_MADV_NORMAL			:= 0;
	_MADV_RANDOM			:= 1;
	_MADV_SEQUENTIAL		:= 2;
	_MADV_WILLNEED			:= 3;
	_MADV_DONTNEED			:= 4;
	
	MADV_NORMAL				:= 0;
	MADV_RANDOM				:= 1;
	MADV_SEQUENTIAL			:= 2;
	MADV_WILLNEED			:= 3;
	MADV_DONTNEED			:= 4;
	MADV_FREE				:= 5;	/* dont need these pages, and junk contents */
	MADV_NOSYNC				:= 6;	/* try to avoid flushes to physical media */
	MADV_AUTOSYNC			:= 7;	/* revert to default flushing strategy */
	MADV_NOCORE				:= 8;	/* do not include these pages in a core file */
	MADV_CORE				:= 9;	/* revert to including pages in a core file */
	MADV_PROTECT			:= 10;	/* protect process from pageout kill */
	
	MINCORE_INCORE	 	 	:= $1;	/* Page is incore */
	MINCORE_REFERENCED	 	:= $2;	/* Page has been referenced by us */
	MINCORE_MODIFIED	 	:= $4;	/* Page has been modified by us */
	MINCORE_REFERENCED_OTHER := $8;	/* Page has been referenced */
	MINCORE_MODIFIED_OTHER	:= $10;	/* Page has been modified */

	POSIX_MADV_NORMAL		:= _MADV_NORMAL;
	POSIX_MADV_RANDOM		:= _MADV_RANDOM;
	POSIX_MADV_SEQUENTIAL	:= _MADV_SEQUENTIAL;
	POSIX_MADV_WILLNEED		:= _MADV_WILLNEED;
	POSIX_MADV_DONTNEED		:= _MADV_DONTNEED;
	
	// From signal.h

	SIGHUP		:= 1;	/* hangup */
	SIGINT		:= 2;	/* interrupt */
	SIGQUIT		:= 3;	/* quit */
	SIGILL		:= 4;	/* illegal instr. (not reset when caught) */
	SIGTRAP		:= 5;	/* trace trap (not reset when caught) */
	SIGABRT		:= 6;	/* abort() */
	SIGIOT		:= SIGABRT;	/* compatibility */
	SIGEMT		:= 7;	/* EMT instruction */
	SIGFPE		:= 8;	/* floating point exception */
	SIGKILL		:= 9;	/* kill (cannot be caught or ignored) */
	SIGBUS		:= 10;	/* bus error */
	SIGSEGV		:= 11;	/* segmentation violation */
	SIGSYS		:= 12;	/* non-existent system call invoked */
	SIGPIPE		:= 13;	/* write on a pipe with no one to read it */
	SIGALRM		:= 14;	/* alarm clock */
	SIGTERM		:= 15;	/* software termination signal from kill */
	SIGURG		:= 16;	/* urgent condition on IO channel */
	SIGSTOP		:= 17;	/* sendable stop signal not from tty */
	SIGTSTP		:= 18;	/* stop signal from tty */
	SIGCONT		:= 19;	/* continue a stopped process */
	SIGCHLD		:= 20;	/* to parent on child stop or exit */
	SIGTTIN		:= 21;	/* to readers pgrp upon background tty read */
	SIGTTOU		:= 22;	/* like TTIN if (tp->t_local&LTOSTOP) */
	SIGIO		:= 23;	/* input/output possible signal */
	SIGXCPU		:= 24;	/* exceeded CPU time limit */
	SIGXFSZ		:= 25;	/* exceeded file size limit */
	SIGVTALRM	:= 26;	/* virtual time alarm */
	SIGPROF		:= 27;	/* profiling time alarm */
	SIGWINCH	:= 28;	/* window size changes */
	SIGINFO		:= 29;	/* information request */
	SIGUSR1		:= 30;	/* user defined signal 1 */
	SIGUSR2		:= 31;	/* user defined signal 2 */
	SIGTHR		:= 32;	/* reserved by thread library. */
	SIGLWP		:= SIGTHR;
	
	SIG_DFL		:= @pointer(0);
	SIG_IGN		:= @pointer(1);
	SIG_ERR		:= @pointer(-1);
	
	SIGEV_NONE			:= 0;
	SIGEV_SIGNAL		:= 1;
	SIGEV_THEAD			:= 2;

	SA_ONSTACK			:= $0001;	/* take signal on signal stack */
	SA_RESTART			:= $0002;	/* restart system call on signal return */
	SA_RESETHAND		:= $0004;	/* reset to SIG_DFL when taking signal */
	SA_NOCLDSTOP		:= $0008;
	SA_NODEFER			:= $0010;	/* don't mask the signal we're delivering */
	SA_NOCLDWAIT		:= $0020;	/* don't keep zombies around */
	SA_SIGINFO			:= $0040;	/* signal handler with SA_SIGINFO args */

	
	/* definitions for <sys/signal.h> */
	
	ILL_NOOP	:= 0;		// ???
	ILL_ILLOPC	:= 1;		// Illegal opcode
	ILL_ILLTRP	:= 2;		// Illegal trap
	ILL_PRVOPC	:= 3;		// Priviledged opcode
	ILL_ILLOPN	:= 4;		// Illegal operand
	ILL_ILLADR	:= 5;		// illegal addressing mode
	ILL_PRVREG	:= 6;		// Priviledged register
	ILL_COPROC	:= 7;		// Coprocessor error
	ILL_BADSTK	:= 8;		// Internal stack error
	
	
	/* portable macros for SIGFPE/ARITHTRAP */
	
	FPE_NOOP	:= 0;
	FPE_FLTDIV	:= 1;	/* floating point divide by zero */
	FPE_FLTOVF	:= 2;	/* floating point overflow */
	FPE_FLTUND	:= 3;	/* floating point underflow */
	FPE_FLTRES	:= 4;	/* floating point inexact result */
	FPE_FLTINV	:= 5;	/* invalid floating point operation */
	FPE_FLTSUB	:= 6;	/* subscript out of range */
	FPE_INTDIV	:= 7;	/* integer divide by zero */
	FPE_INTOVF	:= 8;	/* integer overflow */

	// Errors for sigsegv:
	
	SEGV_NOOP	:= 0;	// ???
	SEGV_MAPERR	:= 1;	// [xsi] address not mapped to object
	SEGV_ACCERR	:= 2;	// [XSI] invalid permission for mapped object.
	
	// Errors for SIGBUS:
	
	BUS_NOOP		:= 0;
	BUS_ADRALN		:= 1;		// Address alignment
	BUS_ADRERR		:= 2;		// Nonexistent physical address
	BUS_OBJERROR	:= 3;		// Object-specific HW error.
	
	// Codes for SIGTRAP
	
	TRAP_BRKPT		:= 1;
	TRAP_TRACE		:= 2;
	
	// Codes for SIGCHLD
	
	CLD_EXITED		:= 1;
	CLD_KILLED		:= 2;
	CLD_DUMPED		:= 3;
	CLD_TRAPPED		:= 4;
	CLD_STOPPED		:= 5;
	CLD_CONTINUED	:= 6;
	
	// Codes for SIGPOLL
	
	POLL_IN			:= 1;
	POLL_OUT		:= 2;
	POLL_MSG		:= 3;
	POLL_ERR		:= 4;
	POLL_PRI		:= 5;
	POLL_HUP		:= 6;
	
	
	/* Trap's coming from user mode */
	
	T_USER			:= $100;
	
	SIG_BLOCK		:= 1;	/* block specified signal set */
	SIG_UNBLOCK		:= 2;	/* unblock specified signal set */
	SIG_SETMASK		:= 3;	/* set specified signal set */

	// Exception definitions:
	
	EXC_BAD_ACCESS		:= 1;
	EXC_BAD_INSTRUCTION	:= 2;
	EXC_ARITHMETIC		:= 3;
	EXC_EMULATION		:= 4;
	EXC_SOFTWARE		:= 5;
	EXC_BREAKPOINT		:= 6;
	EXC_SYSCALL			:= 7;
	EXC_MACH_SYSCALL	:= 8;
	EXC_RPC_ALERT		:= 9;
	EXC_CRASH			:= 10;
	
	EXCEPTION_DEFAULT 			:= 1;
	EXCEPTION_STATE				:= 2;
	EXCEPTION_STATE_IDENTITY	:= 3;
	MACH_EXCEPTION_CODES		:= $80000000;
	

	// No machine dependent types for the 80386


	EXC_TYPES_COUNT			:= 11;	/* incl. illegal exception 0 */


	// Codes and subcodes for 80386 exceptions.


	EXCEPTION_CODE_MAX		:= 2;	/* currently code and subcode */


	// EXC_BAD_INSTRUCTION


	EXC_I386_INVOP			:= 1;


	// EXC_ARITHMETIC


	EXC_I386_DIV			:= 1;
	EXC_I386_INTO			:= 2;
	EXC_I386_NOEXT			:= 3;
	EXC_I386_EXTOVR			:= 4;
	EXC_I386_EXTERR			:= 5;
	EXC_I386_EMERR			:= 6;
	EXC_I386_BOUND			:= 7;
	EXC_I386_SSEEXTERR      := 8;


	// EXC_SOFTWARE
	// Note: 0x10000-0x10003 in use for unix signal
	
	
	
	// EXC_BAD_ACCESS
	
	
	
	// EXC_BREAKPOINT


	EXC_I386_SGL			:= 1;
	EXC_I386_BPT			:= 2;
	
	EXC_I386_DIVERR			:= 0;	/* divide by 0 eprror		*/
	EXC_I386_SGLSTP			:= 1;	/* single step			*/
	EXC_I386_NMIFLT			:= 2;	/* NMI				*/
	EXC_I386_BPTFLT			:= 3;	/* breakpoint fault		*/
	EXC_I386_INTOFLT		:= 4;	/* INTO overflow fault		*/
	EXC_I386_BOUNDFLT		:= 5;	/* BOUND instruction fault	*/
	EXC_I386_INVOPFLT		:= 6;	/* invalid opcode fault		*/
	EXC_I386_NOEXTFLT		:= 7;	/* extension not available fault*/
	EXC_I386_DBLFLT			:= 8;	/* double fault			*/
	EXC_I386_EXTOVRFLT		:= 9;	/* extension overrun fault	*/
	EXC_I386_INVTSSFLT		:= 10;	/* invalid TSS fault		*/
	EXC_I386_SEGNPFLT		:= 11;	/* segment not present fault	*/
	EXC_I386_STKFLT			:= 12;	/* stack fault			*/
	EXC_I386_GPFLT			:= 13;	/* general protection fault	*/
	EXC_I386_PGFLT			:= 14;	/* page fault			*/
	EXC_I386_EXTERRFLT		:= 16;	/* extension error fault	*/
	EXC_I386_ALIGNFLT		:= 17;	/* Alignment fault */
	EXC_I386_ENDPERR		:= 33;	/* emulated extension error flt	*/
	EXC_I386_ENOEXTFLT		:= 32;	/* emulated ext not present	*/



	// machine dependent exception masks

	EXC_MASK_MACHINE		:= 0;


	// Control register

	FPC_IE		:= $0001;		/* enable invalid operation exception */
	FPC_IM		:= FPC_IE;
	FPC_DE		:= $0002;		/* enable denormalized operation exception */
	FPC_DM		:= FPC_DE;
	FPC_ZE		:= $0004;		/* enable zero-divide exception */
	FPC_ZM		:= FPC_ZE;
	FPC_OE		:= $0008;		/* enable overflow exception */
	FPC_OM		:= FPC_OE;
	FPC_UE		:= $0010;		/* enable underflow exception */
	FPC_PE		:= $0020;		/* enable precision exception */
	FPC_PC		:= $0300;		/* precision control: */
	FPC_PC_24	:= $0000;		/* 24 bits */
	FPC_PC_53	:= $0200;		/* 53 bits */
	FPC_PC_64	:= $0300;		/* 64 bits */
	FPC_RC		:= $0c00;		/* rounding control: */
	FPC_RC_RN	:= $0000;		/* round to nearest or even */
	FPC_RC_RD	:= $0400;		/* round down */
	FPC_RC_RU	:= $0800;		/* round up */
	FPC_RC_CHOP	:= $0c00;		/* chop */
	FPC_IC		:= $1000;		/* infinity control (obsolete) */
	FPC_IC_PROJ	:= $0000;		/* projective infinity */
	FPC_IC_AFF	:= $1000;		/* affine infinity (std) */


	// Status register
	
	FPS_IE		:= $0001;		/* invalid operation */
	FPS_DE		:= $0002;		/* denormalized operand */
	FPS_ZE		:= $0004;		/* divide by zero */
	FPS_OE		:= $0008;		/* overflow */
	FPS_UE		:= $0010;		/* underflow */
	FPS_PE		:= $0020;		/* precision */
	FPS_SF		:= $0040;		/* stack flag */
	FPS_ES		:= $0080;		/* error summary */
	FPS_C0		:= $0100;		/* condition code bit 0 */
	FPS_C1		:= $0200;		/* condition code bit 1 */
	FPS_C2		:= $0400;		/* condition code bit 2 */
	FPS_TOS		:= $3800;		/* top-of-stack pointer */
	FPS_TOS_SHIFT	:= 11;
	FPS_C3		:= $4000;		/* condition code bit 3 */
	FPS_BUSY	:= $8000;		/* FPU busy */

	
	// Kind of floating-point support provided by kernel.
	
	FP_NO		:= 0;		/* no floating point */
	FP_SOFT		:= 1;		/* software FP emulator */
	FP_287		:= 2;		/* 80287 */
	FP_387		:= 3;		/* 80387 or 80486 */
	FP_FXSR		:= 4;		/* Fast save/restore SIMD Extension */

	
	
	// from stat.h
	
	S_ISUID		:= $800; //0004000			/* set user id on execution */
	S_ISGID		:= $400; //0002000			/* set group id on execution */
	S_ISTXT		:= $200; //0001000			/* sticky bit */
	S_IRWXU		:= $1c0; //0000700			/* RWX mask for owner */
	S_IRUSR		:= $100; //0000400			/* R for owner */
	S_IWUSR		:= $80;  //0000200			/* W for owner */
	S_IXUSR		:= $40;  //0000100			/* X for owner */
	S_IREAD		:= S_IRUSR;
	S_IWRITE	:= S_IWUSR;
	S_IEXEC		:= S_IXUSR;
	S_IRWXG		:= $38;  //0000070			/* RWX mask for group */
	S_IRGRP		:= $20;  //0000040			/* R for group */
	S_IWGRP		:= $10;  //0000020			/* W for group */
	S_IXGRP		:= $08;  //0000010			/* X for group */
	S_IRWXO		:= 7;						/* RWX mask for other */
	S_IROTH		:= 4;						/* R for other */
	S_IWOTH		:= 2;						/* W for other */
	S_IXOTH		:= 1;						/* X for other */
	S_IFMT	 	:= $F000; //0170000			/* type of file mask */
	S_IFIFO	 	:= $1000; //0010000			/* named pipe (fifo) */
	S_IFCHR	 	:= $2000; //0020000			/* character special */
	S_IFDIR	 	:= $4000; //0040000		/* directory */
	S_IFBLK	 	:= $6000; //0060000		/* block special */
	S_IFREG	 	:= $8000; //0100000		/* regular */
	S_IFLNK	 	:= $A000; //0120000		/* symbolic link */
	S_IFSOCK 	:= $C000; //0140000		/* socket */
	S_ISVTX	 	:= $200;  //0001000		/* save swapped text even after use */
	S_IFWHT  	:= $E000; //0160000		/* whiteout */


	S_BLKSIZE	:= 512;					/* block size used in the stat struct */

	/*
	 * Definitions of flags stored in file flags word.
	 *
	 * Super-user and owner changeable flags.
	 */
	 
	UF_SETTABLE		:= $0000ffff;	/* mask of owner changeable flags */
	UF_NODUMP		:= $00000001;	/* do not dump file */
	UF_IMMUTABLE	:= $00000002;	/* file may not be changed */
	UF_APPEND		:= $00000004;	/* writes to file may only append */
	UF_OPAQUE		:= $00000008;	/* directory is opaque wrt. union */
	UF_NOUNLINK		:= $00000010;	/* file may not be removed or renamed */
	/*
	 * Super-user changeable flags.
	 */
	SF_SETTABLE		:= $ffff0000;	/* mask of superuser changeable flags */
	SF_ARCHIVED		:= $00010000;	/* file is archived */
	SF_IMMUTABLE	:= $00020000;	/* file may not be changed */
	SF_APPEND		:= $00040000;	/* writes to file may only append */
	SF_NOUNLINK		:= $00100000;	/* file may not be removed or renamed */
	SF_SNAPSHOT		:= $00200000;	/* snapshot inode */
	
	STDIN_FILENO	:= 0;			/* standard input file descriptor */
	STDOUT_FILENO	:= 1;			/* standard output file descriptor */
	STDERR_FILENO	:= 2;			/* standard error file descriptor */

	F_OK			:= 0;			/* test for existence of file */
	X_OK			:= 1;			/* test for execute or search permission */
	W_OK			:= 2;			/* test for write permission */
	R_OK			:= 4;			/* test for read permission */
	SEEK_SET		:= 0;			/* set file offset to offset */
	SEEK_CUR		:= 1;			/* set file offset to current plus offset */
	SEEK_END		:= 2;			/* set file offset to EOF plus offset */

	O_RDONLY		:= $0000;		/* open for reading only */
	O_WRONLY		:= $0001;		/* open for writing only */
	O_RDWR			:= $0002;		/* open for reading and writing */
	O_ACCMODE		:= $0003;		/* mask for above modes */
	FREAD			:= $0001;
	FWRITE			:= $0002;
	O_NONBLOCK		:= $0004;		/* no delay */
	O_APPEND		:= $0008;		/* set append mode */
	O_SHLOCK		:= $0010;		/* open with shared file lock */
	O_EXLOCK		:= $0020;		/* open with exclusive file lock */
	O_ASYNC			:= $0040;		/* signal pgrp when data ready */
	O_FSYNC			:= $0080;		/* synchronous writes */
	O_SYNC			:= $0080;		/* POSIX synonym for O_FSYNC */
	O_NOFOLLOW		:= $0100;		/* don't follow symlinks */
	O_CREAT			:= $0200;		/* create if nonexistent */
	O_TRUNC			:= $0400;		/* truncate to zero length */
	O_EXCL			:= $0800;		/* error if already exists */
	O_NOCTTY		:= $8000;		/* don't assign controlling terminal */
	O_DIRECT		:= $00010000;
	FAPPEND			:= O_APPEND;	/* kernel/compat */
	FASYNC			:= O_ASYNC;		/* kernel/compat */
	FFSYNC			:= O_FSYNC;		/* kernel */
	FNONBLOCK		:= O_NONBLOCK;	/* kernel */
	FNDELAY			:= O_NONBLOCK;	/* compat */
	O_NDELAY		:= O_NONBLOCK;	/* compat */
	FPOSIXSHM		:= O_NOFOLLOW;
	F_DUPFD			:= 0;			/* duplicate file descriptor */
	F_GETFD			:= 1;			/* get file descriptor flags */
	F_SETFD			:= 2;			/* set file descriptor flags */
	F_GETFL			:= 3;			/* get file status flags */
	F_SETFL			:= 4;			/* set file status flags */
	F_GETOWN		:= 5;			/* get SIGIO/SIGURG proc/pgrp */
	F_SETOWN		:= 6;			/* set SIGIO/SIGURG proc/pgrp */
	F_GETLK			:= 7;			/* get record locking information */
	F_SETLK			:= 8;			/* set record locking information */
	F_SETLKW		:= 9;			/* F_SETLK; wait if blocked */
	FD_CLOEXEC		:= 1;			/* close-on-exec flag */
	F_RDLCK			:= 1;			/* shared or read lock */
	F_UNLCK			:= 2;			/* unlock */
	F_WRLCK			:= 3;			/* exclusive or write lock */
	LOCK_SH			:= $01;			/* shared file lock */
	LOCK_EX			:= $02;			/* exclusive file lock */
	LOCK_NB			:= $04;			/* don't block when locking */
	LOCK_UN			:= $08;			/* unlock file */



	EFL_CF			:= $1;			/* carry */
	EFL_PF			:= $4;			/* parity of low 8 bits */
	EFL_AF			:= $10;			/* carry out of bit 3 */
	EFL_ZF			:= $40;			/* zero */
	EFL_SF			:= $80;			/* sign */
	EFL_TF			:= $100;		/* trace trap */
	EFL_IF			:= $200;		/* interrupt enable */
	EFL_DF			:= $400;		/* direction */
	EFL_OF			:= $800;		/* overflow */
	EFL_IOPL		:= $3000;		/* IO privilege level: */
	EFL_IOPL_KERNEL	:= 0;			/* kernel */
	EFL_IOPL_USER	:= $3000;		/* user */
	EFL_NT			:= $4000;		/* nested task */
	EFL_RF			:= $10000;		/* resume without tracing */
	EFL_VM			:= $20000;		/* virtual 8086 mode */
	EFL_AC			:= $40000;		/* alignment check */
	EFL_VIF			:= $80000;		/* virtual interrupt flag */
	EFL_VIP			:= $100000;		/* virtual interrupt pending */
	EFL_ID			:= $200000;		/* cpuID instruction */
	EFL_CLR			:= $fff88028;
	EFL_SET			:= $2;

	EFL_USER_SET	:= (EFL_IF);
	EFL_USER_CLEAR	:= (EFL_IOPL|EFL_NT|EFL_RF);


	// From dirent.h
	
	MAXNAMLEN		:= 255;

	/*
	 * File types
	 */
	 
	DT_UNKNOWN	 	:= 0;
	DT_FIFO		 	:= 1;
	DT_CHR		 	:= 2;
	DT_DIR		 	:= 4;
	DT_BLK		 	:= 6;
	DT_REG		 	:= 8;
	DT_LNK			:= 10;
	DT_SOCK			:= 12;
	DT_WHT			:= 14;

	// Sigaction call types:

	UC_TRAD			:= 1;
	UC_FLAVOR		:= 30;
	
	
	// IPC and semaphore stuff
	
	IPC_CREATE	:= $200;
	SETVAL		:= 8;
		
	



type
	blkcnt_t		:dword;
	blksize_t		:dword;
	clockid_t		:dword;
	dev_t			:dword;
	fflags_t		:dword;
	fsblkcnt_t		:dword;
	fsfilcnt_t		:dword;
	gid_t			:dword;
	id_t			:int64;
	ino_t			:dword;
	key_t			:dword;
	lwpid_t			:dword;
	mode_t			:word;
	nl_item			:dword;
	nlink_t			:word;
	rlim_t			:qword;
	off_t			:qword;
	pid_t			:int32;
	sa_family_t		:byte;
	size_t			:dword;
	socklen_t		:dword;
	suseconds_t		:dword;
	time_t			:dword;
	timer_t			:dword;
	uid_t			:int32;
	useconds_t		:dword;
	sig_atomic_t	:dword;
	sigset_t		:dword;

	timeval: record
		tv_sec	:time_t;
		tv_usec	:suseconds_t;
	endrecord;
	
	timespec: record
		tv_sec	:time_t;
		tv_nsec	:dword;
	endrecord;
	
	timezone: record
		tz_minuteswest	:int32;
		tz_dsttime		:int32;
	endrecord;
	
	dirent 	:record
	
		d_fileno	:dword;					/* file number of entry */
		d_reclen	:word;					/* length of this record */
		d_type		:byte; 					/* file type, see consts above */
		d_namlen	:byte;					/* length of string in d_name */
		d_name		:char[MAXNAMLEN + 1];	/* name must be no longer than this */

	endrecord;

	
	
	
	i386_thread_state	:record

    	__eax:dword;
		__ebx:dword;
		__ecx:dword;
		__edx:dword;
		__edi:dword;
		__esi:dword;
		__ebp:dword;
		__esp:dword;
		__ss:dword;
		__eflags:dword;
		__eip:dword;
		__cs:dword;
		__ds:dword;
		__es:dword;
		__fs:dword;
		__gs:dword;
		
	endrecord;
	
	mmst_reg	:record
	
		union
			mmst		:tbyte;
			mmst_reg	:byte[10];
		endunion;
		mmst_rsrv		:byte[6];
		
	endrecord;
	
	xmm_reg	:union
	
		xmm_reg	:byte[16];
		xmm		:lword;
		
	endunion;
		
	
	i386_float_state	:record

		__fpu_reserved		:dword[2];
		__fpu_fcw			:word;			/* x87 FPU control word */
		__fpu_fsw			:word;			/* x87 FPU status word */
		__fpu_ftw			:byte;			/* x87 FPU tag word */
		__fpu_rsrv1			:byte;			/* reserved */ 
		__fpu_fop			:word;			/* x87 FPU Opcode */
		__fpu_ip			:dword;			/* x87 FPU Instruction Pointer offset */
		__fpu_cs			:word;			/* x87 FPU Instruction Pointer Selector */
		__fpu_rsrv2			:word;			/* reserved */
		
		__fpu_dp			:dword;			/* x87 FPU Instruction Operand(Data) Pointer offset */
		__fpu_ds			:word;			/* x87 FPU Instruction Operand(Data) Pointer Selector */
		__fpu_rsrv3			:word;			/* reserved */
		__fpu_mxcsr			:dword;			/* MXCSR Register state */
		__fpu_mxcsrmask		:dword;			/* MXCSR mask */
		__fpu_stmm0			:mmst_reg;		/* ST0/MM0   */
		__fpu_stmm1			:mmst_reg;		/* ST1/MM1  */
		__fpu_stmm2			:mmst_reg;		/* ST2/MM2  */
		__fpu_stmm3			:mmst_reg;		/* ST3/MM3  */
		__fpu_stmm4			:mmst_reg;		/* ST4/MM4  */
		__fpu_stmm5			:mmst_reg;		/* ST5/MM5  */
		__fpu_stmm6			:mmst_reg;		/* ST6/MM6  */
		__fpu_stmm7			:mmst_reg;		/* ST7/MM7  */
		__fpu_xmm0			:xmm_reg;		/* XMM 0  */
		__fpu_xmm1			:xmm_reg;		/* XMM 1  */
		__fpu_xmm2			:xmm_reg;		/* XMM 2  */
		__fpu_xmm3			:xmm_reg;		/* XMM 3  */
		__fpu_xmm4			:xmm_reg;		/* XMM 4  */
		__fpu_xmm5			:xmm_reg;		/* XMM 5  */
		__fpu_xmm6			:xmm_reg;		/* XMM 6  */
		__fpu_xmm7			:xmm_reg;		/* XMM 7  */
		__fpu_rsrv4			:byte[14*16];	/* reserved */
		__fpu_reserved1		:dword;

	endrecord;
	
	i386_exception_state	:record

		trapno		:dword;
		err			:dword;
		faultvaddr	:dword;

	endrecord;
	
	x86_debug_state32	:record

		_dr0		:dword;
		_dr1		:dword;
		_dr2		:dword;
		_dr3		:dword;
		_dr4		:dword;
		_dr5		:dword;
		_dr6		:dword;
		_dr7		:dword;
	
	endrecord;
	
	
	// note when allocating this data structure, it must be 16 byte aligned.

	x86_fx_save :record
	
        fx_control		:word;			/* control */
        fx_status		:word;      	/* status */
        fx_tag			:byte;      	/* register tags */
        fx_bbz1			:byte;			/* better be zero when calling fxrtstor */
        fx_opcode		:word;
        fx_eip			:dword;     	/* eip  instruction */
        fx_cs			:word;	   		/* cs instruction */
        fx_bbz2			:word;			/* better be zero when calling fxrtstor */ 
        fx_dp			:dword;    		/* data address */
        fx_ds			:word;     		/* data segment */
        fx_bbz3			:word;			/* better be zero when calling fxrtstor */
        fx_MXCSR		:dword;
        fx_MXCSR_MASK	:dword;
        fx_reg_word		:word[8,8]; 	/* STx/MMx registers */
        fx_XMM_reg		:word[8,16];	/* XMM0-XMM15 on 64 bit processors */
                                 		/* XMM0-XMM7  on 32 bit processors... unused storage reserved */
        fx_reserved		:byte[16*6];	/* reserved by intel for future expansion */

	endrecord;



	sigval	:union
		/* Members as suggested by Annex C of POSIX 1003.1b. */
		sigval_int	:dword;
		sigval_ptr	:pointer to byte;
	endunion;
	
	sigevent	:record
	
		sigev_notify	:dword;
		__sigev_signo	:dword;				/* Signal number */
		sigev_value		:sigval;			/* Signal value  */
		sigev_notify_attributes	:dword;		/* pointer to pthread_attr_t	*/
	
	endrecord;
	
	siginfo_t	:record

		si_signo	:dword;		/* signal number */
		si_errno	:dword;		/* errno association */
	
		/*
		 * Cause of signal, one of the SI_ macros or signal-specific
		 * values, i.e. one of the FPE_... values for SIGFPE.  This
		 * value is equivalent to the second argument to an old-style
		 * FreeBSD signal handler.
		 */
		
		si_code		:dword;		/* signal code */
		si_pid		:pid_t;		/* sending process */
		si_uid		:uid_t;		/* sender's ruid */
		si_status	:int32;		/* exit value */
		si_addr		:dword;		/* faulting instruction */
		si_value	:sigval;	/* signal value */
		si_band		:dword;		/* band event for SIGPOLL */
		__spare__	:dword[7];	/* gimme some slack */
	
	endrecord;
	
	pSiginfo_t	:pointer to siginfo_t;
	
	sigaltstack	:record
	
		ss_sp		:dword;		/* signal stack base */
		ss_size		:dword;		/* signal stack length */
		ss_flags	:dword;		/* SA_DISABLE and/or SA_ONSTACK */
		
	endrecord;
	
	mcontext_t	:record

		__es	:i386_exception_state;
		__ss	:i386_thread_state;
		__fs	:i386_float_state;
		
	endrecord;


	ucontext_t	:record
	
		uc_onstack		:dword;
		uc_sigmask		:sigset_t;
		uc_stack		:sigaltstack;
		uc_link			:pointer to ucontext_t;
		uc_mcsize		:size_t;
		uc_mcontext		:pointer to mcontext_t;
		
	endrecord;
	
	pUcontext_t	:pointer to ucontext_t;

	
	__sa_handler_t		:procedure( sig:dword );	@cdecl;
	__sa_sigaction_t	:procedure( sig:dword; var act:siginfo_t; var uap:ucontext_t );
							@cdecl;
	
	__sigaction_u	:union
	
		__sa_handler_t		:procedure( sig:dword );	@cdecl;
		__sa_sigaction_t	:procedure( sig:dword; var act:siginfo_t; var uap:ucontext_t );
								@cdecl;
		
	endunion;


	sigaction_t	:record
	
		__sa_sigaction	:__sigaction_u;
		sa_mask			:sigset_t;
		sa_flags		:dword;
		
	endrecord;
	
	__sigaction 	:record
	
		__sigaction	:__sigaction_u;  /* signal handler */
		sa_tramp	:procedure 
					 (
					 	action		:__sigaction_u;
					 	sigstyle	:dword;
					 	sig			:dword;
					 	sinfo		:dword; 	// pointer to siginfo_t;
					 	uctx		:dword 		// pointer to ucontext_t
					 );	@cdecl;
					 
		sa_mask		:sigset_t;		/* signal mask to apply */
		sa_flags	:dword;
	
	endrecord;



	
		
	stat_t	:record
	 
		st_dev				:dev_t;		/* inode's device */
		st_ino				:ino_t;		/* inode's number */
		st_mode				:mode_t;	/* inode protection mode */
		st_nlink			:nlink_t;	/* number of hard links */
		st_uid				:uid_t;		/* user ID of the file's owner */
		st_gid				:gid_t;		/* group ID of the file's group */
		st_rdev				:dev_t;		/* device type */
		st_atimespec		:timespec;	/* time of last access */
		st_mtimespec		:timespec;	/* time of last data modification */
		st_ctimespec		:timespec;	/* time of last file status change */
		st_size				:off_t;		/* file size, in bytes */
		st_blocks			:blkcnt_t;	/* blocks allocated for file */
		st_blksize			:blksize_t;	/* optimal blocksize for I/O */
		st_flags			:fflags_t;	/* user defined flags for file */
		st_gen				:uns32;		/* file generation number */
		st_lspare			:dword;
		st_birthtimespec	:timespec; /* time of file creation */
		align(16);
	
	endrecord;
	
	nstat	:record
	
		st_dev				:dev_t;		/* inode's device */
		st_ino				:ino_t;		/* inode's number */
		st_mode				:uns32;		/* inode protection mode */
		st_nlink			:uns32;		/* number of hard links */
		st_uid				:uid_t;		/* user ID of the file's owner */
		st_gid				:gid_t;		/* group ID of the file's group */
		st_rdev				:dev_t;		/* device type */
		st_atimespec		:timespec;	/* time of last access */
		st_mtimespec		:timespec;	/* time of last data modification */
		st_ctimespec		:timespec;	/* time of last file status change */
		st_size				:off_t;		/* file size, in bytes */
		st_blocks			:blkcnt_t;	/* blocks allocated for file */
		st_blksize			:blksize_t;	/* optimal blocksize for I/O */
		st_flags			:fflags_t;	/* user defined flags for file */
		st_gen				:uns32;		/* file generation number */
		st_birthtimespec	:timespec;  /* time of file creation */
		align(16);
	
	endrecord;


	/*
	 * Advisory file segment locking data type -
	 * information passed to system by user
	 */
		
 	flock	:record
 	
 		l_start	:off_t;
 		l_len	:off_t;
 		l_pid	:pid_t;
 		l_type	:word;
 		l_whence:word;
 		
 	endrecord;
 	
#if( @global:false )	// BSD stuff???
env87 	:record
 	
		en_cw		:word;		/* control word (16bits) */
		_pad0		:word;
		en_sw		:word;		/* status word (16bits) */
		_pad1		:word;
		en_tw		:word;		/* tag word (16bits) */
		_pad2		:word;
		en_fip		:dword;		/* floating point instruction pointer */
		en_fcs		:word;		/* floating code segment selector */
		en_opcode	:word;		/* opcode last executed (11 bits ) */
		en_foo		:dword;		/* floating operand offset */
		en_fos		:dword;		/* floating operand segment selector */
		
	endrecord;


	save87 	:record
	
		sv_env		:env87;		/* floating point control/status */
		sv_ac		:real80[8];	/* accumulator contents, 0-7 */
		sv_pad0		:byte[4];	/* padding for (now unused) saved status word */
		
		/*
		 * Bogus padding for emulators.  Emulators should use their own
		 * struct and arrange to store into this struct (ending here)
		 * before it is inspected for ptracing or for core dumps.  Some
		 * emulators overwrite the whole struct.  We have no good way of
		 * knowing how much padding to leave.  Leave just enough for the
		 * GPL emulator's i387_union (176 bytes total).
		 */
		 
		sv_pad		:byte[64];	/* padding; used by emulators */
	
	endrecord;

	envxmm	:record
	
		en_cw			:word;		/* control word (16bits) */
		en_sw			:word;		/* status word (16bits) */
		en_tw			:word;		/* tag word (16bits) */
		en_opcode		:word;		/* opcode last executed (11 bits ) */
		en_fip			:dword;		/* floating point instruction pointer */
		en_fcs			:word;		/* floating code segment selector */
		en_pad0			:word;		/* padding */
		en_foo			:dword;		/* floating operand offset */
		en_fos			:word;		/* floating operand segment selector */
		en_pad1			:word;		/* padding */
		en_mxcsr		:dword;		/* SSE sontorol/status register */
		en_mxcsr_mask	:dword;		/* valid bits in mxcsr */
	
	endrecord;
	
	fpitem	:record
	
		fpacc	:real80;
		align(16);
		
	endrecord;
	
	savexmm :record
	
		sv_env			:envxmm;
		sv_fp			:fpitem[8];
		sv_xmm			:lword[8];
		sv_pad			:byte[224];
	
		align(16);
		
	endrecord;
	
	savefpu 	:union
	
		sv_87	:save87;
		sv_xmm	:savexmm;
	
	endunion;
	
#endif


type
  	fd_set: record
  		fds_bits	:dword[ 32 ];
  	endrecord;
  	fd_set_ptr	:pointer to fd_set;
	fd_set_t: fd_set;
	
	hostent	:record
	
		h_name		:zstring;
		h_aliases	:dword;
		h_addrtype	:dword;
		h_length	:dword;
		h_addr_list	:dword;
		
	endrecord;




// Types and constants associated with threads.
//
// The following constants are OS- and OS-version-specific and
// must be kept in sync with /usr/include/sys/_types.h
// These sizes correspond to the 64-bit versions, as long as
// they are larger than Apple's, we're okay.

const	
	pThreadAttrSize 		:= 56;
	pThreadMutexSize 		:= 56;
	pThreadMutexAttrSize 	:= 8;
	pThreadCondSize			:= 28;
	pThreadCondAttrSize		:= 8;

type

	// These are *NIX opaque types:
	
	pthread_key_t			:dword;
	pthread_t				:dword;
	pthread_attr_t			:byte[ pThreadAttrSize ];
	pthread_mutex_t			:byte[ pThreadMutexSize ];
	pthread_mutex_attr_t	:byte[ pThreadMutexAttrSize ];
	pthread_cond_t			:byte[ pThreadCondSize ];
	pthread_condattr_t		:byte[ pThreadCondAttrSize ];
	
	start_routine_t			:procedure( parm:dword );
	
	sembuf:
		record
			sem_num	:word;		// semaphore #
			sem_op	:word;		// semaphore operation
			sem_flg	:word;      // operation flags
		endrecord;







	procedure chdir( path:string );
		external( "MAC_CHDIR" );

	procedure close( fd:dword );
		external( "MAC_CLOSE" );

	procedure execve( path:string; var argv:var; var envp:var  );
		external( "MAC_EXECVE" );
		
	procedure _exit( exitCode:dword );
		external( "MAC_EXIT" );
		
	procedure fork;
		external( "MAC_FORK" );
		
	procedure fstat( fd:dword; var sb:stat_t );
		external( "MAC_FSTAT" );
		
	procedure fsync( fd:dword );
		external( "MAC_FSYNC" );

	procedure ftruncate( fd:dword; length:off_t );
		external( "MAC_FTRUNCATE" );

	procedure getcwd( var buf:var; size:size_t );
		external( "MAC_GETCWD" );
		
	procedure getdents( fd:dword; var buf:var; nbytes:dword );
		external( "MAC_GETDENTS" );
		
	procedure getdirentries( fd:dword; var buf:var; nbytes:dword; var basep:dword );
		external( "MAC_GETDIRENTRIES" );
		
	procedure gettimeofday( var tv:timeval; var tz:timezone );
		external( "MAC_GETTIMEOFDAY" );
		
	procedure lseek( fd:dword; offset:off_t; whence:dword );
		external( "MAC_LSEEK" );

	procedure lstat( path:string; var sb:stat_t );
		external( "MAC_LSTAT" );
		
	procedure mkdir( path:string; mode:mode_t );
		external( "MAC_MKDIR" );
		
	procedure mmap
	( 
		addr	:dword; 
		len		:size_t; 
		prot	:dword; 
		flags	:dword; 
		fd		:dword; 
		offset	:off_t 
	);	external( "MAC_MMAP" );

	procedure munmap( addr:dword; len:size_t );
		external( "MAC_MUNMAP" );

	procedure nanosleep( var rgtp:timespec; var rmtp:timespec );
		external( "MAC_NANOSLEEP" );

	const open :text := "mac.open3";

	procedure open2( path:string; flags:dword );
		external( "MAC_OPEN2" );

	procedure open3( path:string; flags:dword; mode:mode_t );
		external( "MAC_OPEN3" );
		
	procedure pread( fd:dword; var buf:var; len:size_t; offset:off_t );
		external( "MAC_PREAD" );

	procedure read( fd:dword; var buf:var; len:dword );
		external( "MAC_READ" );

	procedure rename( from:string; toName:string );
		external( "MAC_RENAME" );

	procedure rmdir( path:string );
		external( "MAC_RMDIR" );

	procedure sigaction
	(
			sig		:dword;
		var	act		:sigaction_t;
		var	oact	:sigaction_t
	);
		external( "MAC_SIGACTION" );

	procedure sigprocmask( how:dword; var newSet:sigset_t; var oldSet:sigset_t);
		external( "MAC_SIGPROCMASK" );
	procedure stat( path:string; var sb:stat_t );
		external( "MAC_STAT" );
		
	procedure truncate( path:string; length:off_t );
		external( "MAC_TRUNCATE" );

	procedure unlink( path:string );
		external( "MAC_UNLINK" );

	procedure waitpid
	( 
			pid			:pid_t; 
		var stat_addr	:dword; 
			options		:dword 
	); 
		external( "MAC_WAITPID" );
		
	procedure write( fd:dword; var buf:var; len:dword );
		external( "MAC_WRITE" );




	// Networking functions	


	procedure accept
	( 
			s		:dword; 
		var	addr	:@global:hla.sockaddr; 
		var	addrlen	:@global:hla.socklen_t 
	);
		@returns( "eax" );
		external( "MAC_ACCEPT" );
		
	procedure bind
	( 
			sockfd	:dword; 
		var	addr	:@global:hla.sockaddr; 
			addrlen	:@global:hla.socklen_t 
	);
		@returns( "eax" );
		external( "MAC_BIND" );
		

	procedure connect
	( 
			sockfd	:dword; 
		var	addr	:@global:hla.sockaddr; 
			addrlen	:@global:hla.socklen_t 
	);
		@returns( "eax" );
		external( "MAC_CONNECT" );


	procedure gethostbyaddr( addr:dword; len:dword; _type:dword );
		@returns( "eax" );
		external( "MAC_GETHOSTBYADDR" );
		
		
	procedure gethostbyname( s:string );
		@returns( "eax" );
		external( "MAC_GETHOSTBYNAME" );

	procedure gethostname( var buf:var; maxlen:dword );
		@returns( "eax" );
		external( "MAC_GETHOSTNAME" );


	procedure getpeername
	( 
			s		:dword; 
		var	_name	:@global:hla.sockaddr; 
		var	namelen	:@global:hla.socklen_t 
	);
		@returns( "eax" );
		external( "MAC_GETPEERNAME" );

	procedure getsockname
	( 
			s		:dword; 
		var	_name	:@global:hla.sockaddr; 
		var	namelen	:@global:hla.socklen_t 
	);
		@returns( "eax" );
		external( "MAC_GETSOCKNAME" );


	procedure getsockopt
	( 
			s		:dword; 
			level	:dword;
			optname	:dword;
		var	optval	:var;
		var	optlen	:@global:hla.socklen_t 
	);
		@returns( "eax" );
		external( "MAC_GETSOCKOPT" );


	procedure listen
	( 
		s		:dword; 
		backlog	:dword
	);
		@returns( "eax" );
		external( "MAC_LISTEN" );
		
		
	procedure recv
	( 
			s		:dword; 
		var	buf		:var;
			len		:dword;
			flags	:dword	// MSG_* constants 
	);
		@returns( "eax" );
		external( "MAC_RECV" );
		
		
	procedure recvfrom
	( 
			s		:dword; 
		var	buf		:var;
			len		:dword;
			flags	:dword;
		var	from	:@global:hla.sockaddr;
		var	fromlen	:@global:hla.socklen_t 
	);
		@returns( "eax" );
		external( "MAC_RECVFROM" );
		
		
	procedure select
	( 
			n			:dword; 
		var	readSet		:fd_set_t;
		var	writeSet	:fd_set_t;
		var	exceptSet	:fd_set_t;
		var	timeout		:timeval
	);
		@returns( "eax" );
		external( "MAC_SELECT" );
	 
	 
	procedure send
	( 
			s		:dword; 
		var	buf		:var;
			len		:dword;
			flags	:dword	// MSG_* constants 
	);
		@returns( "eax" );
		external( "MAC_SEND" );
	 
	 
	procedure sendto
	( 
			s		:dword; 
		var	buf		:var;
			len		:dword;
			flags	:dword;
		var	_to		:@global:hla.sockaddr;
			tolen	:@global:hla.socklen_t 
	);
		@returns( "eax" );
		external( "MAC_SENDTO" );
	 


	procedure setsockopt
	( 
			s		:dword; 
			level	:dword;
			optname	:dword;
		var	optval	:var;
			optlen	:@global:hla.socklen_t 
	);
		@returns( "eax" );
		external( "MAC_SETSOCKOPT" );
		

	procedure shutdown
	( 
		s		:dword; 
		how		:dword 
	);
		@returns( "eax" );
		external( "MAC_SHUTDOWN" );


	procedure socket
	( 
		domain		:dword;		// AF_* or PF_* constants
		_type		:dword;		// SOCK_* constants
		protocol	:dword		// Usually zero. 
	);
		@returns( "eax" );
		external( "MAC_SOCKET" );

	
	procedure errno;
		@returns( "eax" );
		external( "MAC_ERRNO" );
	
	procedure h_errno;
		@returns( "eax" );
		external( "MAC_H_ERRNO" );
		
		
	// PThread functions:
	
	procedure pthread_create
	( 
		var thrd			:pthread_t;
		var	attr			:pthread_attr_t;
			start_routine	:start_routine_t;
			parm			:dword
	);
		@returns( "eax" );
		external( "MAC_PTHREAD_CREATE" );
		
	procedure pthread_exit( value_ptr:dword );	
		external( "MAC_PTHREAD_EXIT" );

	procedure pthread_self;	
		external( "MAC_PTHREAD_SELF" );

	procedure pthread_attr_init( var pta:pthread_attr_t );
		@returns( "eax" );
		external( "MAC_PTHREAD_ATTR_INIT" );
	
	procedure pthread_attr_destroy( var pta:pthread_attr_t );
		@returns( "eax" );
		external( "MAC_PTHREAD_ATTR_DESTROY" );
	
	procedure pthread_attr_setstacksize( var pta:pthread_attr_t; size:dword );
		@returns( "eax" );
		external( "MAC_PTHREAD_ATTR_SETSTACKSIZE" );
		
		
		
		

	procedure pthread_key_create( var key:pthread_key_t; destructor:start_routine_t );
		@returns( "eax" );
		external( "MAC_PTHREAD_KEY_CREATE" );
		
	procedure pthread_key_delete( key:pthread_key_t );
		@returns( "eax" );
		external( "MAC_PTHREAD_KEY_DELETE" );
		
	procedure pthread_getspecific( key:pthread_key_t );
		@returns( "eax" );
		external( "MAC_PTHREAD_GETSPECIFIC" );
		
	procedure pthread_setspecific( key:pthread_key_t; value_ptr:dword );
		@returns( "eax" );
		external( "MAC_PTHREAD_SETSPECIFIC" );
		

	
	
	procedure pthread_mutex_destroy( var mutex:pthread_mutex_t );
		@returns( "eax" );
		external( "MAC_PTHREAD_MUTEX_DESTROY" );

	procedure pthread_mutex_init
	( 
		var mutex	:pthread_mutex_t;
		var	attr	:pthread_mutex_attr_t 
	);
		@returns( "eax" );
		external( "MAC_PTHREAD_MUTEX_INIT" );

	procedure pthread_mutex_lock( var mutex:pthread_mutex_t );
		@returns( "eax" );
		external( "MAC_PTHREAD_MUTEX_LOCK" );

	procedure pthread_mutex_unlock( var mutex:pthread_mutex_t );
		@returns( "eax" );
		external( "MAC_PTHREAD_MUTEX_UNLOCK" );
		
		
	procedure ftok( path:string; id:dword );
		@returns( "eax" );
		external( "MAC_FTOK" );
		
		
	procedure semctl( semid:dword; semnum:dword; cmd:dword; arg:dword );
		@returns( "eax" );
		external( "MAC_SEMCTL" );
	
	
	procedure semget( key:dword; semCnt:dword; flags:dword );
		@returns( "eax" );
		external( "MAC_SEMGET" );
	
	procedure semop( semid:dword; var array:sembuf;  nops:dword );
		@returns( "eax" );
		external( "MAC_SEMOP" );
		
		
		
		
		
		
		
		
	procedure pthread_cond_init
	( 
		var cond	:pthread_cond_t;
		var	attr	:pthread_condattr_t 
	);
		@returns( "eax" );
		external( "MAC_PTHREAD_COND_INIT" );


	procedure pthread_cond_destroy
	( 
		var cond	:pthread_cond_t 
	);
		@returns( "eax" );
		external( "MAC_PTHREAD_COND_DESTROY" );


	procedure pthread_cond_signal
	( 
		var cond	:pthread_cond_t 
	);
		@returns( "eax" );
		external( "MAC_PTHREAD_COND_SIGNAL" );


	procedure pthread_cond_broadcast
	( 
		var cond	:pthread_cond_t 
	);
		@returns( "eax" );
		external( "MAC_PTHREAD_COND_BROADCAST" );


	procedure pthread_cond_wait
	( 
		var cond	:pthread_cond_t;
		var	mutex	:pthread_mutex_t 
	);
		@returns( "eax" );
		external( "MAC_PTHREAD_COND_WAIT" );


	procedure pthread_cond_timedwait
	( 
		var cond	:pthread_cond_t;
		var	mutex	:pthread_mutex_t;
		var timeout	:@global:hla.timespec 
	);
		@returns( "eax" );
		external( "MAC_PTHREAD_COND_TIMEDWAIT" );
		
		
	

end mac;

#endif








	
  		
  		
  		
