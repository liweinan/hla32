#if( ! @defined( sockets_hhf ))
?sockets_hhf := true;

#includeOnce( "hla.hhf" )
#includeOnce( "fileio.hhf" )
#includeOnce( "os.hhf" )
#if( os.win32 )
	#linker( "wsock32.lib" )
#else
	#includeOnce( "cstdlib.hhf" )
#endif


#if( @thread )

	namespace _hla;		// private stuff for the sockets library

		proc
		
			sockCSenter:
				procedure;
				@global:_hla._ext( "HLA_SOCKCSENTER" );
				
			sockCSleave:
				procedure;
				@global:_hla._ext( "HLA_SOCKCSLEAVE" );

	end _hla;

#endif

namespace sock; @fast;	

	const
	SOCK_STREAM 	:= 1;	// Sequenced, reliable, connection-based byte streams.  
	SOCK_DGRAM 		:= 2;	// Connectionless, unreliable datagrams of fixed maximum length.  
	SOCK_RAW 		:= 3;	// Raw protocol interface.  
	SOCK_RDM 		:= 4;	// Reliably-delivered messages.  
	SOCK_SEQPACKET 	:= 5;	// Sequenced, reliable, connection-based, datagrams of fixed maximum length.  
	SOCK_PACKET 	:= 10;	// Linux specific way of getting packets at the dev level.  For writing rarp and other similar things on the user level. 

	INADDR_ANY		:= 0;	// Arbitrary internet address.

	PF_UNSPEC		:= 0;			// Unspecified.  
	PF_LOCAL		:= 1;			// Local to host (pipes and file-domain).  
	PF_UNIX			:= PF_LOCAL;	// Old BSD name for PF_LOCAL.  
	PF_FILE			:= PF_LOCAL;	// Another non-standard name for PF_LOCAL.  
	PF_INET			:= 2;			// IP protocol family.  
	PF_AX25			:= 3;			// Amateur Radio AX.25.  
	PF_IPX			:= 4;			// Novell Internet Protocol.  
	PF_APPLETALK	:= 5;			// Appletalk DDP.  
	PF_NETROM		:= 6;			// Amateur radio NetROM.  
	PF_BRIDGE		:= 7;			// Multiprotocol bridge.  
	PF_ATMPVC		:= 8;			// ATM PVCs.  
	PF_X25			:= 9;			// Reserved for X.25 project.  
	PF_INET6		:= 10;			// IP version 6.  
	PF_ROSE			:= 11;			// Amateur Radio X.25 PLP.  
	PF_DECnet		:= 12;			// Reserved for DECnet project.  
	PF_NETBEUI		:= 13;			// Reserved for 802.2LLC project.  
	PF_SECURITY		:= 14;			// Security callback pseudo AF.  
	PF_KEY			:= 15;			// PF_KEY key management API.  
	PF_NETLINK		:= 16;
	PF_ROUTE		:= PF_NETLINK;	// Alias to emulate 4.4BSD.  
	PF_PACKET		:= 17;			// Packet family.  
	PF_ASH			:= 18;			// Ash.  
	PF_ECONET		:= 19;			// Acorn Econet.  
	PF_ATMSVC		:= 20;			// ATM SVCs.  
	PF_SNA			:= 22;			// Linux SNA Project 
	PF_IRDA			:= 23;			// IRDA sockets.  
	PF_PPPOX		:= 24;			// PPPoX sockets.  
	PF_WANPIPE		:= 25;			// Wanpipe API sockets.  
	PF_BLUETOOTH	:= 31;			// Bluetooth sockets.  
	PF_MAX			:= 32;			// For now..  
	
	
	
	AF_UNSPEC		:= PF_UNSPEC;
	AF_LOCAL		:= PF_LOCAL;
	AF_UNIX			:= PF_UNIX;
	AF_FILE			:= PF_FILE;
	AF_INET			:= PF_INET;
	AF_AX25			:= PF_AX25;
	AF_IPX			:= PF_IPX;
	AF_APPLETALK	:= PF_APPLETALK;
	AF_NETROM		:= PF_NETROM;
	AF_BRIDGE		:= PF_BRIDGE;
	AF_ATMPVC		:= PF_ATMPVC;
	AF_X25			:= PF_X25;
	AF_INET6		:= PF_INET6;
	AF_ROSE			:= PF_ROSE;
	AF_DECnet		:= PF_DECnet;
	AF_NETBEUI		:= PF_NETBEUI;
	AF_SECURITY		:= PF_SECURITY;
	AF_KEY			:= PF_KEY;
	AF_NETLINK		:= PF_NETLINK;
	AF_ROUTE		:= PF_ROUTE;
	AF_PACKET		:= PF_PACKET;
	AF_ASH			:= PF_ASH;
	AF_ECONET		:= PF_ECONET;
	AF_ATMSVC		:= PF_ATMSVC;
	AF_SNA			:= PF_SNA;
	AF_IRDA			:= PF_IRDA;
	AF_PPPOX		:= PF_PPPOX;
	AF_WANPIPE		:= PF_WANPIPE;
	AF_BLUETOOTH	:= PF_BLUETOOTH;
	AF_MAX			:= PF_MAX;
	
	
    MSG_OOB			:= $01;				// Process out-of-band data.  
    MSG_PEEK		:= $02;				// Peek at incoming messages.  
    MSG_DONTROUTE	:= $04;				// Don't use local routing.  
    MSG_TRYHARD		:= MSG_DONTROUTE;
    MSG_CTRUNC		:= $08;				// Control data lost before delivery.  
    MSG_PROXY		:= $10;				// Supply or ask second address.  
    MSG_TRUNC		:= $20;
    MSG_DONTWAIT	:= $40; 			// Nonblocking IO.  
    MSG_EOR			:= $80; 			// End of record.  
    MSG_WAITALL		:= $100; 			// Wait for a full request.  
    MSG_FIN			:= $200;
    MSG_SYN			:= $400;
    MSG_CONFIRM		:= $800; 			// Confirm path validity.  
    MSG_RST			:= $1000;
    MSG_ERRQUEUE	:= $2000; 			// Fetch message from error queue.  
    MSG_NOSIGNAL	:= $4000; 			// Do not generate SIGPIPE.  
    MSG_MORE		:= $8000;  			// Sender will send more.
	
	
	#if( @global:os.win32 )
		SOL_SOCKET		:= $FFFF;
		SO_SNDTIMEO     := $01005;
		SO_RCVTIMEO     := $01006;
	#elseif( @global:os.macOS )
		SOL_SOCKET		:= $FFFF;
		SO_SNDTIMEO     := $01005;
		SO_RCVTIMEO     := $01006;
	#elseif( @global:os.freeBSD )
		SOL_SOCKET		:= $FFFF;
		SO_SNDTIMEO     := $01005;
		SO_RCVTIMEO     := $01006;
	#elseif( @global:os.linux )
		SOL_SOCKET		:= 1;
		SO_SNDTIMEO     := 21;
		SO_RCVTIMEO     := 20;
	#endif
	  
	
	const
		max_fd_elements			:= @global:hla.max_fd_elements;

	type
		timeval		:@global:hla.timeval;
		bigEndianDW	:@global:hla.bigEndianDW;
		bigEndianW	:@global:hla.bigEndianW;
		socktype_t	:@global:hla.socktype_t;
		sa_family_t	:@global:hla.sa_family_t;
		socklen_t	:@global:hla.socklen_t;
		fd_set_t	:@global:hla.fd_set_t;
		hostent		:@global:hla.hostent;
		sockaddr_in	:@global:hla.sockaddr_in;
		sockaddr	:@global:hla.sockaddr;		


	
		
	static
		socketCnt			:uns32; @global:_hla._ext( "SOCK_SOCKETCNT" );
		updatingSocketCnt	:dword; @global:_hla._ext( "SOCK_UPDATINGSOCKETCNT" );

		
	#macro zeroSockAddr( _sa_ ):_i_;
	
		?_i_ := 0;
		#while( _i_ < @size( @global:hla.sockaddr ))
		
			mov( 0, (type dword _sa_[_i_]) );
			?_i_ += 4;
			
		#endwhile
		
	#endmacro
		
	
	
	
	///////////////////////////////////////////////////////////////////////
	//
	//  High-level socket functions that expect values in little endian
	//  form
	
	
	proc
	
		a_ipToStr:
			procedure ( a:dword )  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_A_IPTOSTR" );

		ipToStr:
			procedure ( ip:dword; s:string );
			@global:_hla._ext( "SOCK_IPTOSTR" );

		strToIP:
			procedure ( s:string )  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_STRTOIP" );
			
		peerAdrs:
			procedure( s:dword )  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_PEERADRS" );
			
		sockAdrs:
			procedure( s:dword )  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_SOCKADRS" );
			
		hostAdrs:
			procedure {@returns( "eax" )};
			@global:_hla._ext( "SOCK_HOSTADRS" );
			

		
		
		///////////////////////////////////////////////////////////////////////
		//
		// Functions and macros that convert between little and big endian form:
			
				
		htonl:
			procedure( adrs:dword in eax );
			@global:_hla._ext( "_SOCK_HTONL" );
				
		ntohl:
			procedure( adrs:dword in eax );
			@global:_hla._ext( "_SOCK_HTONL" );		// Same func as sock.htonl
				
				
		htons:
			procedure( adrs:word in ax );
			@global:_hla._ext( "_SOCK_HTONS" );
				
		ntohs:
			procedure( adrs:word in ax );
			@global:_hla._ext( "_SOCK_HTONS" );		// Same func as sock.htonl
		
		
		#macro dw_m( a, b, c, d );
		
			(
					(((a) & $FF) << 24 ) 
				|	(((b) & $FF) << 16 )
				|	(((c) & $FF) <<  8 )
				|	(((d) & $FF)       ) 
			)
				
		#endmacro	
				
				
		#macro htonl_m( adrs[] );a;
		
			#if( @elements( adrs ) = 1 )
		
				?a := @text(adrs[0]);
				(
						(((a)&$ff) << 24) 
					|	(((a)&$ff00) << 8 )
					|	(((a)&$FF_0000) >> 8 )
					|	((a) >> 24 )
				)
				
			#elseif( @elements( adrs ) = 4 )
			
				(
						(@text( adrs[0] )       )
					|	(@text( adrs[1] ) << 8  )
					|	(@text( adrs[2] ) << 16 )
					|	(@text( adrs[3] ) << 24 )
				)
				
			#else
			
				#error( "Bad number of arguments" )
				
			#endif
			
		#endmacro	
				
		#macro htons_m( adrs[] );a;
		
			#if( @elements( adrs ) = 1 )
		
				?a := @text(adrs[0]);
				(
						(((a)&$ff) << 8) 
					|	(((a)&$ff00) >> 8 )
				)
				
			#elseif( @elements( adrs ) = 2 )
			
				(
						(@text( adrs[0] )      )
					|	(@text( adrs[1] ) << 8 )
				)
				
			#else
			
				#error( "Bad number of arguments" )
				
			#endif
			
		#endmacro
		
		
		
		
		
		
		//////////////////////////////////////////////////////////////////////
		//
		// Low-level socket functions that assume all addresses and port values
		// are in big endian form.
				
		
		a_adrsToStr:
			procedure ( a:@global:hla.bigEndianDW )  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_A_ADRSTOSTR" );

				
		// Note: the following is a low-level function that assumes the
		// address is already in netword byte order (big endian);
		
		adrsToStr:
			procedure( a:@global:hla.bigEndianDW; s:string );
			@global:_hla._ext( "SOCK_ADRSTOSTR" );

		// Note: this is a low-level function that returns the address
		// in network byte order (Big Endian);
		
		strToAdrs:
			procedure( s:string )  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_STRTOADRS" );
			
			
		// Low-level socket calls

		accept:
			procedure
			( 
					s		:dword; 
				var	addr	:@global:hla.sockaddr; 
				var	addrlen	:@global:hla.socklen_t 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_ACCEPT" );
			
		bind:
			procedure
			( 
					sockfd	:dword; 
				var	addr	:@global:hla.sockaddr; 
					addrlen	:@global:hla.socklen_t 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_BIND" );
		
		connect:
			procedure
			( 
					sockfd		:dword; 
				var	serv_addr	:@global:hla.sockaddr; 
					addrlen		:@global:hla.socklen_t 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_CONNECT" );
			
		getpeername:
			procedure
			( 
					s		:dword; 
				var	_name	:@global:hla.sockaddr; 
				var	namelen	:@global:hla.socklen_t 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_GETPEERNAME" );
			
		getsockname:
			procedure
			( 
					s		:dword; 
				var	_name	:@global:hla.sockaddr; 
				var	namelen	:@global:hla.socklen_t 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_GETSOCKNAME" );

		getsockopt:
			procedure
			( 
					s		:dword; 
					level	:dword;
					optname	:dword;
				var	optval	:var;
				var	optlen	:@global:hla.socklen_t 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_GETSOCKOPT" );

		
		listen:
			procedure
			( 
				s		:dword; 
				backlog	:dword
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_LISTEN" );

		recv:
			procedure
			( 
					s		:dword; 
				var	buf		:var;
					len		:dword;
					flags	:dword	// MSG_* constants 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_RECV" );
			
		recvfrom:
			procedure
			( 
					s		:dword; 
				var	buf		:var;
					len		:dword;
					flags	:dword;
				var	from	:@global:hla.sockaddr;
				var	fromlen	:@global:hla.socklen_t 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_RECVFROM" );
			
		select:
			procedure
			( 
					n			:dword; 
				var	readSet		:@global:hla.fd_set_t;
				var	writeSet	:@global:hla.fd_set_t;
				var	exceptSet	:@global:hla.fd_set_t;
				var	timeout		:@global:hla.timeval
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_SELECT" );
			
		send:
			procedure
			( 
					s		:dword; 
				var	buf		:var;
					len		:dword;
					flags	:dword	// MSG_* constants 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_SEND" );

		sendto:
			procedure
			( 
					s		:dword; 
				var	buf		:var;
					len		:dword;
					flags	:dword;
				var	_to		:@global:hla.sockaddr;
					tolen	:@global:hla.socklen_t 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_SENDTO" );

		setsockopt:
			procedure
			( 
					s		:dword; 
					level	:dword;
					optname	:dword;
				var	optval	:var;
					optlen	:@global:hla.socklen_t 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_SETSOCKOPT" );

		setTimeout:
			procedure( handle:dword; timeout:@global:hla.timeval );
			@global:_hla._ext( "SOCK_SETTIMEOUT" );

		shutdown:
			procedure
			( 
				s		:dword; 
				how		:dword 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_SHUTDOWN" );
			
		close:
			procedure( sockfd:dword );
			@global:_hla._ext( "SOCK_CLOSE" );
			
		socket:
			procedure
			( 
				domain		:dword;		// AF_* or PF_* constants
				_type		:dword;		// SOCK_* constants
				protocol	:dword		// Usually zero. 
			)  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_SOCKET" );
			

		socketInit:
			procedure;
			@global:_hla._ext( "SOCK_SOCKETINIT" );
			
		socketCleanup:
			procedure;
			@global:_hla._ext( "SOCK_SOCKETCLEANUP" );
			
			
		gethostbyaddr:
			procedure
			( 
				var addr	:var; 
					len		:dword; 
					_type	:dword;
				var	hstent	:@global:hla.hostent 
			);
			@global:_hla._ext( "SOCK_GETHOSTBYADDR" );
			
		gethostbyname:
			procedure( s:string; var hstent:@global:hla.hostent );
			@global:_hla._ext( "SOCK_GETHOSTBYNAME" );
			
			
		gethostname:
			procedure( s:string )  {@returns( "eax" )};
			@global:_hla._ext( "SOCK_GETHOSTNAME" );
			
			
			
		fd_set:
			procedure( fd:dword; var fdset:@global:hla.fd_set_t );
			@global:_hla._ext( "SOCK_FD_SET" );
			
		fd_clr:
			procedure( fd:dword; var fdset:@global:hla.fd_set_t );
			@global:_hla._ext( "SOCK_FD_CLR" );
			
		fd_zero:
			procedure( var fdset:@global:hla.fd_set_t );
			@global:_hla._ext( "SOCK_FD_ZERO" );
			
		fd_copy:
			procedure
			( 
				var	fdSrc	:@global:hla.fd_set_t; 
				var fdDest	:@global:hla.fd_set_t 
			);
			@global:_hla._ext( "SOCK_FD_COPY" );
			
		fd_isset:
			procedure( fd:dword; var fdset:@global:hla.fd_set_t ) {@returns( "al" )};
			@global:_hla._ext( "SOCK_FD_ISSET" );
		
		
			
end sock;
	


type
	baseSocketClass_t: 
		class
			var
				handle		:dword;
				timeout		:@global:hla.timeval;
				mode		:@global:hla.socktype_t;
				IPadrs		:@global:hla.sockaddr;

				// Make sure this class is an even multiple
				// of four bytes long.  This must be the
				// last field in this data structure.
				// Note: Doesn't align work in classes now? (3/06/2001)
				
				
				#if( @CurOffset mod 4 <> 0 )

					Padding: byte[ 4 - (@CurOffset mod 4) ];

				#endif
				
				
			
		proc
		
			create:
				procedure {@returns( "esi" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_T_CREATE" );
				
			destroy:
				procedure;
				@global:_hla._ext( "BASESOCKETCLASS_DESTROY" );
				
			assign:
				procedure( var src:baseSocketClass_t );
				@global:_hla._ext( "BASESOCKETCLASS_ASSIGN" );
				
			poll:
				procedure  {@returns( "eax" )};
				@global:_hla._ext( "BASESOCKETCLASS_POLL" );
				
			read:
				procedure( var buf:var; len:dword )  {@returns( "eax" )};
				@global:_hla._ext( "BASESOCKETCLASS_READ" );
				
			readTimeout:
				procedure( var buf:var; len:dword; msTimeout:dword )  
				{@returns( "eax" )};
				@global:_hla._ext( "BASESOCKETCLASS_READTIMEOUT" );
				
			write:
				procedure( var buf:var; len:dword )  {@returns( "eax" )};
				@global:_hla._ext( "BASESOCKETCLASS_WRITE" );
				
			setTimeout2:
				procedure( tv_sec:dword; tv_usec:dword );
				@global:_hla._ext( "BASESOCKETCLASS_SETTIMEOUT2" );
		
			setTimeout:
				procedure( timeout:hla.timeval );
				@global:_hla._ext( "BASESOCKETCLASS_SETTIMEOUT" );
		
			getTimeout:
				procedure( var timeout:hla.timeval );
				@global:_hla._ext( "BASESOCKETCLASS_GETTIMEOUT" );

			getAdrs:
				procedure {@returns( "eax" )};
				@global:_hla._ext( "BASESOCKETCLASS_GETADRS" );
		
			setAdrs:
				procedure( adrs:dword );
				@global:_hla._ext( "BASESOCKETCLASS_SETADRS" );
				
			getPort:
				procedure {@returns( "ax" )};
				@global:_hla._ext( "BASESOCKETCLASS_GETPORT" );
		
			setPort:
				procedure( port:word );
				@global:_hla._ext( "BASESOCKETCLASS_SETPORT" );
				
			adrsToStr:
				procedure( s:string );
				@global:_hla._ext( "BASESOCKETCLASS_ADRSTOSTR" );
		
			a_adrsToStr:
				procedure;
				@global:_hla._ext( "BASESOCKETCLASS_A_ADRSTOSTR" );
				
				
				
				
				
			readLn:
				procedure;
				@global:_hla._ext( "BASESOCKETCLASS_READLN" );
				
			getc:
				procedure {@returns( "al" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETC" );
				
			gets:
				procedure( s:string );
				@global:_hla._ext( "BASESOCKETCLASS_GETS" );
				
			a_gets:
				procedure {@returns( "eax" )};
				@global:_hla._ext( "BASESOCKETCLASS_A_GETS" );

			geti8:
				procedure {@returns( "al" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETI8" );
				
			geti16:
				procedure {@returns( "ax" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETI16" );
				
			geti32:
				procedure {@returns( "eax" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETI32" );
				
			geti64:
				procedure {@returns( "edx:eax" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETI64" );

			geti128:
				procedure( var l:lword );
				@global:_hla._ext( "BASESOCKETCLASS_GETI128" );

			getu8:
				procedure {@returns( "al" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETU8" );
				
			getu16:
				procedure {@returns( "ax" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETU16" );
				
			getu32:
				procedure {@returns( "eax" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETU32" );
				
			getu64:
				procedure {@returns( "edx:eax" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETU64" );

			getu128:
				procedure( var l:lword );
				@global:_hla._ext( "BASESOCKETCLASS_GETU128" );

			geth8:
				procedure {@returns( "al" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETH8" );
				
			geth16:
				procedure {@returns( "ax" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETH16" );
				
			geth32:
				procedure {@returns( "eax" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETH32" );
				
			geth64:
				procedure {@returns( "edx:eax" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETH64" );
				
			geth128:
				procedure( var l:lword );
				@global:_hla._ext( "BASESOCKETCLASS_GETH128" );

			getf:
				procedure {@returns( "st0" )}; 
				@global:_hla._ext( "BASESOCKETCLASS_GETF" );



			putbool:
				procedure( b:boolean );
				@global:_hla._ext( "BASESOCKETCLASS_PUTBOOL" );
				
			putcset:
				procedure( cs:cset   );
				@global:_hla._ext( "BASESOCKETCLASS_PUTCSET" );

			putc:
				procedure( c:char    );
				@global:_hla._ext( "BASESOCKETCLASS_PUTC" );
				
			putcSize:
				procedure( c:char; width:int32; fill:char );
				@global:_hla._ext( "BASESOCKETCLASS_PUTCSIZE" );

			newln:
				procedure;
				@global:_hla._ext( "BASESOCKETCLASS_NEWLN" );

			puts:
				procedure( s:string  );
				@global:_hla._ext( "BASESOCKETCLASS_PUTS" );
				
			putsSize:
				procedure
				( 
					s:string; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTSSIZE" );

			putz:
				procedure( s:zstring  );
				@global:_hla._ext( "BASESOCKETCLASS_PUTZ" );
				
			putzSize:
				procedure
				( 
					s:zstring; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTZSIZE" );

			putb:
				procedure( h:byte    );
				@global:_hla._ext( "BASESOCKETCLASS_PUTB" );
				
			putw:
				procedure( w:word 	  );
				@global:_hla._ext( "BASESOCKETCLASS_PUTW" );
				
			putd:
				procedure( dw:dword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTD" );
				
			putq:
				procedure( qw:qword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTQ" );
				
			puttb:
				procedure( tb:tbyte );
				@global:_hla._ext( "BASESOCKETCLASS_PUTTB" );
				
			putl:
				procedure( l:lword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTL" );

			puth8:
				procedure( h:byte    );
				@global:_hla._ext( "BASESOCKETCLASS_PUTH8" );
				
			puth16:
				procedure( w:word 	  );
				@global:_hla._ext( "BASESOCKETCLASS_PUTH16" );
				
			puth32:
				procedure( dw:dword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTH32" );
				
			puth64:
				procedure( qw:qword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTH64" );
				
			puth80:
				procedure( tb:tbyte );
				@global:_hla._ext( "BASESOCKETCLASS_PUTH80" );
				
			puth128:
				procedure( l:lword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTH128" );

			puti8:
				procedure ( b:byte  );
				@global:_hla._ext( "BASESOCKETCLASS_PUTI8" );
				
			puti16:
				procedure( w:word  );
				@global:_hla._ext( "BASESOCKETCLASS_PUTI16" );
				
			puti32:
				procedure( d:dword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTI32" );
		
			puti64:
				procedure( q:qword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTI64" );
				
			puti128:
				procedure( l:lword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTI128" );
				

			puth8Size:
				procedure
				( 
					b:byte; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTH8SIZE" );

			puth16Size:
				procedure
				( 
					w:word; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTH16SIZE" );

			puth32Size:
				procedure
				( 
					d:dword; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTH32SIZE" );
			
			puth64Size:
				procedure
				( 
					q:qword; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTH64SIZE" );

			puth80Size:
				procedure
				( 
					tb:tbyte; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTH80SIZE" );

			puth128Size:
				procedure
				( 
					l:lword; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTH128SIZE" );


			puti8Size:
				procedure 
				( 
					b:byte;  
					width:int32;	
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTI8SIZE" );

			puti16Size:
				procedure
				( 
					w:word;  
					width:int32;	
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTI16SIZE" );

			puti32Size:
				procedure
				( 
					d:dword; 
					width:int32;	
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTI32SIZE" );

			puti64Size:
				procedure
				( 
					q:qword; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTI64SIZE" );

			puti128Size:
				procedure
				( 
					l:lword; 
					width:int32; 
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTI128SIZE" );

			putu8:
				procedure( b:byte  );
				@global:_hla._ext( "BASESOCKETCLASS_PUTU8" );
				
			putu16:
				procedure( w:word  );
				@global:_hla._ext( "BASESOCKETCLASS_PUTU16" );
				
			putu32:
				procedure( d:dword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTU32" );
				
			putu64:
				procedure( q:qword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTU64" );
				
			putu128:
				procedure( l:lword );
				@global:_hla._ext( "BASESOCKETCLASS_PUTU128" );

			putu8Size:
				procedure 
				( 
					b:byte;  
					width:int32;	
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTU8SIZE" );

			putu16Size:
				procedure
				( 
					w:word;  
					width:int32;	
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTU16SIZE" );

			putu32Size:
				procedure
				( 
					d:dword; 
					width:int32;	
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTU32SIZE" );

			putu64Size:
				procedure
				( 
					q:qword; 
					width:int32;	
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTU64SIZE" );

			putu128Size:
				procedure
				( 
					l:lword; 
					width:int32;	
					fill:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTU128SIZE" );


			putr32:
				procedure
				( 
					r:real32; 
					width:uns32; 
					decpts:uns32;
					fill	:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTR32" );

			putr64:
				procedure
				( 
					r:real64; 
					width:uns32; 
					decpts:uns32;
					fill	:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTR64" );

			putr80:
				procedure
				( 
					r		:real80; 
					width	:uns32; 
					decpts	:uns32;
					fill	:char 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTR80" );



			pute32:
				procedure
				( 
					r:real32; 
					width:uns32 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTE32" );

			pute64:
				procedure
				( 
					r:real64; 
					width:uns32 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTE64" );

			pute80:
				procedure
				( 
					r:real80; 
					width:uns32 
				);
				@global:_hla._ext( "BASESOCKETCLASS_PUTE80" );



			sPutPad:
				procedure( fill:char; size:uns32 );
				@global:_hla._ext( "BASESOCKETCLASS_SPUTPAD" );



			// _put_ is used by the put macro to emit the correct
			// call depending upon the presence of width and decpts
			// parameters in addition to the value to output.

			#macro _put_( _obj_, _routine_, _typename_ );
						_invoke_, _func_, _parms_, _realsize_, _typ_;

				?_func_:string := @string:_routine_;
				?_parms_:string := "";
				?_typ_:string := @string:_typename_;

				// Real values allow two size parameters 
				// (width & decpts).

				#if( @substr( _typ_, 0, 4 ) = "real" )

					#if( _width_ <> "-1" )

						?_realsize_:string := @substr( _typ_, 4, 2 );

						// If decpts is <> -1, print in dec notation,
						// else print in sci notation.

						#if( _decpts_ <> "-1" )

							?_parms_:string := 
								"," + _width_ + "," + _decpts_ + ", ' '";
							
						#else
						 
							?_func_:string := "pute" + _realsize_;
							?_parms_:string := "," + _width_;

						#endif

					#else

						// If the user did not specify a format size,
						// then use the puteXX routines with default
						// sizes of: real32=15, real64=22, real80=28.

						?_func_:string := "pute" + _realsize_;
						#if( _realsize_ = "32" )

							?_parms_:string := ",15";

						#elseif( _realsize_ = "64" )

							?_parms_:string := ",22";

						#else

							?_parms_:string := ",28";

						#endif

					#endif

				#else //It's not a real type.

					#if( _decpts_ <> "-1" )

						#error
						( 
							"Fractional width specification "
							"is not supported here" 
						)

					#elseif( _width_ <> "-1" )

						// Width specifications are only supported for
						// certain types.  Check for that here.

						#if
						(
								_typ_ <> "uns8"
							&	_typ_ <> "uns16"
							&	_typ_ <> "uns32"
							&	_typ_ <> "int8"
							&	_typ_ <> "int16"
							&	_typ_ <> "int32"
							&	_typ_ <> "char"
							&	_typ_ <> "string"
							&	_typ_ <> "byte"
							&	_typ_ <> "word"
							&	_typ_ <> "dword"
							&	_typ_ <> "qword"
						)

							#error
							( 
								"Type " + 
								_typ_ + 
								" does not support width format "
								"option" 
							)

						#else

							?_func_:string := _func_ + "Size";
							?_parms_:string := "," + _width_ + ", ' '";

						#endif

					#endif

				#endif
							
				#if(
						@isconst( @text( _arg_ ))
					&	_typ_ = "string"
					&	_arg_ = "#13 #10"
				)

					_obj_.newln();

				#elseif( @isconst( @text( _arg_ )))

					?_invoke_:text := @string( _obj_ ) + "." +_func_;
					_invoke_( @text( _arg_ ) @text( _parms_ ));

				#else

					?_invoke_:text := @string( _obj_ ) + "." + _func_;
					_invoke_
					( 
						(type _typename_ @text( _arg_ )) @text( _parms_ )
					);

				#endif

			#endmacro



			#macro put( _parms_[] ); 
				_curparm_, _pType_, _arg_, _width_, _decpts_, 
				_sVar_, _parmArray_, _id_, _fieldCnt_;

				// Preserved ESI and EDI across all the
				// calls in this macro.

				push( esi );
				push( edi );

				?_sVar_:text := @LastObject;

				?_curparm_:uns32 := 0;
				#while( _curparm_ < @elements( _parms_ ))

					// The following stmt frees up any storage
					// currently in use by parmArray.

					?_parmArray_:uns32 := 0;

					// Get the current parameter into parmArray.

					?_parmArray_ :=	@tokenize
									(
										_parms_[ _curparm_ ],
										0,
										{':'},
										{
											'"',
											'''',
											'[',
											']',
											'(',
											')',
											'{',
											'}'
										}
									);

					?_arg_ := @trim( _parmArray_[ 0 ], 0 );
					#if( char( _arg_ ) in stdio._idchars_ )

						?_id_ := stdio._GetID_( _arg_ );
						#if
						(
								@class( _id_ ) =@global:hla.cConstant
							|	@class( _id_ ) =@global:hla.cValue
						)

							?_id_ := _arg_;

						#endif

					#else

						?_id_ := _arg_;

					#endif

					?_fieldCnt_ := @elements( _parmArray_ );
					#if( _fieldCnt_ > 1 )

						?_width_ := @trim( _parmArray_[ 1 ], 0 );

					#else

						?_width_ := "-1";

					#endif
					#if( _fieldCnt_ > 2 )

						?_decpts_ := @trim( _parmArray_[ 2 ], 0 );

					#else

						?_decpts_ := "-1";

					#endif
					#if( _fieldCnt_ > 3 )

						#error
						(
							"<<" + _parms_[ _curparm_ ] + ">>" +
							" has too many width fields"
						)

					#endif
					
					?_pType_ := @pType(  @text( _id_ ));
					#if( _pType_ =@global:hla.ptArray )

						?_pType_ := 
							@pType( @text( @typename( @text( _id_))));

					#endif

					#if( _pType_ = @global:hla.ptBoolean )
					 
						_sVar_._put_( putbool, boolean )

					#elseif( _pType_ = @global:hla.ptUns8 )
					 
						_sVar_._put_( putu8, uns8 )

					#elseif( _pType_ = @global:hla.ptUns16 ) 
					
						_sVar_._put_( putu16, uns16 )

					#elseif( _pType_ = @global:hla.ptUns32 ) 
					
						_sVar_._put_( putu32, uns32 )

					#elseif( _pType_ = @global:hla.ptByte ) 
					
						_sVar_._put_( putb, byte )

					#elseif( _pType_ = @global:hla.ptWord ) 
					
						_sVar_._put_( putw, word )

					#elseif( _pType_ = @global:hla.ptDWord ) 
					
						_sVar_._put_( putd, dword )

					#elseif( _pType_ = @global:hla.ptInt8 ) 
					
						_sVar_._put_( puti8, int8 )

					#elseif( _pType_ = @global:hla.ptInt16 ) 
					
						_sVar_._put_( puti16, int16 )

					#elseif( _pType_ = @global:hla.ptInt32 ) 
					
						_sVar_._put_( puti32, int32 )

					#elseif( _pType_ = @global:hla.ptChar ) 
					
						_sVar_._put_( putc, char )

					#elseif( _pType_ = @global:hla.ptCset ) 
					
						_sVar_._put_( putcset, cset )

					#elseif( _pType_ = @global:hla.ptReal32 ) 
					
						_sVar_._put_( putr32, real32 )

					#elseif( _pType_ = @global:hla.ptReal64 ) 
					
						_sVar_._put_( putr64, real64 )

					#elseif( _pType_ = @global:hla.ptReal80 ) 
					
						_sVar_._put_( putr80, real80 )

					#elseif( _pType_ = @global:hla.ptString )

						_sVar_._put_( puts, string )

					#elseif( _pType_ = @global:hla.ptZString )

						_sVar_._put_( putz, zstring )


					#elseif( @isclass( @text( _parms_[ _curparm_ ] )))

						#if
						( 
							@defined
							( 
								@text
								(
									 _parms_[ _curparm_ ] + 
									".toString" 
								)
							)
						)

							push( eax );
							push( esi );
							push( edi );
							@text
							( 
								_parms_[ _curparm_ ] + 
								".toString()"
							);
							_sVar_.puts( eax );
							strfree( eax );
							pop( edi );
							pop( esi );
							pop( eax );

						#else

							#error
							(
								"sock.put: Class does not provide a "
								"toString method or procedure"
							);

						#endif

					#else

						#error
						( 
							"sock.put: Unknown data type (" +
							_parms_[ _curparm_ ] +
							":" +
							@typename( @text( _parms_[_curparm_] )) +
							")"
						);

					#endif
					?_curparm_ := _curparm_ + 1;

				#endwhile

				pop( edi );
				pop( esi );

			#endmacro





			#macro get( _parms_[] ); 
				_curparm_, _pType_, _arg_, _id_, _sVar_;

				?_curparm_:uns32 := 0;
				?_sVar_:text := @LastObject;
				
				// Save important registers that the "GET" macro uses.

				push( eax );
				push( esi );
				push( edi );

				// The following loop repeats once for each GET parameter
				// we process.

				#while( _curparm_ < @elements( _parms_ ))

					// If this parameter begins with an identifier,
					// there are some problems to deal with.
					// The symbol table functions (e.g., @ptype) don't
					// allow address expression components after the
					// symbol name.  Named constants, however, do allow
					// such entities.  The following code determines
					// (1) is this a symbol?  (2) if it is a symbol, is
					// it a constant?
					//
					//	For non-constant symbols, we need to strip any
					// trailing non-symbol characters from the string
					// (e.g., "[0]" ).

					?_arg_ := @trim( _parms_[ _curparm_ ], 0 );
					#if( char( _arg_ ) in stdio._idchars_ )

						// If this parameter begins with an id character,
						// then strip away any non-ID symbols from the
						// end of the string.  Then determine if we've
						// got a constant or some other class (e.g.,
						// variable or procedure).  If not a constant,
						// keep only the name.  If a constant, we need
						// to keep all trailing characters as well.

						?_id_ := stdio._GetID_( _arg_ );
						#if
						( 
								@class( _id_ ) = @global:hla.cConstant 
							|	@class( _id_ ) = @global:hla.cValue 
						)

							?_id_ := _arg_;

						#endif

					#else

						// If it's not an ID, we need to keep everything.

						?_id_ := _arg_;

					#endif



					// Determine the type of this parameter so we can
					// call the appropriate routine to input it.

					?_pType_ := @pType( @text( _id_ ));
					#if( _pType_ = @global:hla.ptArray )

						?_pType_ := 
							@pType( @text( @typename( @text( _id_ ))));

					#endif

					// Based on the type, call the appropriate library
					// routine to print this value.

					#if( _pType_ = @global:hla.ptBoolean )

						#error( "Boolean input is not supported" );

					#elseif( _pType_ = @global:hla.ptUns8 ) 
						
						_sVar_.getu8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptUns16 ) 
						
						_sVar_.getu16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptUns32 ) 
						
						_sVar_.getu32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptByte ) 
						
						_sVar_.geth8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptWord ) 
						
						_sVar_.geth16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptDWord ) 
						
						_sVar_.geth32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptInt8 ) 
						
						_sVar_.geti8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptInt16 ) 
						
						_sVar_.geti16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptInt32 ) 
						
						_sVar_.geti32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptChar ) 
						
						_sVar_.getc();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptCset ) 

						#error( "Cset input is not supported" );

					#elseif
					( 
							_pType_ = @global:hla.ptReal32 
						|	_pType_ = @global:hla.ptReal64 
						|	_pType_ = @global:hla.ptReal80 
					) 
						
						_sVar_.getf();
						fstp( @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptString ) 

						_sVar_.gets( @text( _arg_ ));

					#else

						#error
						( 
							"stdin.get: Unknown data type (" +
							_parms_[ _curparm_ ] +
							":" +
							@typename( @text( _id_ )) +
							")"
						);

					#endif
					?_curparm_ := _curparm_ + 1;

				#endwhile

				// Restore the registers pushed earlier for this 
				// call to the GET macro.

				pop( edi );
				pop( esi );
				pop( eax );

			#endmacro

		endclass;
			



	vBaseSocketClass_t: 
		class
			var
				handle		:dword;
				timeout		:@global:hla.timeval;
				mode		:@global:hla.socktype_t;
				IPadrs		:@global:hla.sockaddr;

				// Make sure this class is an even multiple
				// of four bytes long.  This must be the
				// last field in this data structure.
				// Note: Doesn't align work in classes now? (3/06/2001)
				
				
				#if( @CurOffset mod 4 <> 0 )

					Padding: byte[ 4 - (@CurOffset mod 4) ];

				#endif
				
				
			proc
				create:
					procedure {@returns( "esi" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_T_CREATE" );
					
				destroy:
					method;
					@global:_hla._ext( "VBASESOCKETCLASS_DESTROY" );
				
				
				assign:
					method( var src:vBaseSocketClass_t );
					@global:_hla._ext( "VBASESOCKETCLASS_ASSIGN" );
					
					
				poll:
					method  {@returns( "eax" )};
					@global:_hla._ext( "VBASESOCKETCLASS_POLL" );
					
				read:
					method( var buf:var; len:dword )  {@returns( "eax" )};
					@global:_hla._ext( "VBASESOCKETCLASS_READ" );
					
				readTimeout:
					method( var buf:var; len:dword; msTimeout:dword )  
					{@returns( "eax" )};
					@global:_hla._ext( "VBASESOCKETCLASS_READTIMEOUT" );
					
				write:
					method( var buf:var; len:dword )  {@returns( "eax" )};
					@global:_hla._ext( "VBASESOCKETCLASS_WRITE" );
					
				setTimeout2:
					method( tv_sec:dword; tv_usec:dword );
					@global:_hla._ext( "VBASESOCKETCLASS_SETTIMEOUT2" );
			
				setTimeout:
					method( timeout:@global:hla.timeval );
					@global:_hla._ext( "VBASESOCKETCLASS_SETTIMEOUT" );
			
				getTimeout:
					method( var timeout:@global:hla.timeval );
					@global:_hla._ext( "VBASESOCKETCLASS_GETTIMEOUT" );

				getAdrs:
					method  {@returns( "eax" )};
					@global:_hla._ext( "VBASESOCKETCLASS_GETADRS" );
			
				setAdrs:
					method( adrs:dword );
					@global:_hla._ext( "VBASESOCKETCLASS_SETADRS" );
					
				getPort:
					method  {@returns( "ax" )};
					@global:_hla._ext( "VBASESOCKETCLASS_GETPORT" );
			
				setPort:
					method( port:word );
					@global:_hla._ext( "VBASESOCKETCLASS_SETPORT" );
					
				adrsToStr:
					method( s:string );
					@global:_hla._ext( "VBASESOCKETCLASS_ADRSTOSTR" );
			
				a_adrsToStr:
					method;
					@global:_hla._ext( "VBASESOCKETCLASS_A_ADRSTOSTR" );
					
					
					
					
					
				readLn:
					method;
					@global:_hla._ext( "VBASESOCKETCLASS_READLN" );
					
				getc:
					method {@returns( "AL" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETC" );
					
				gets:
					method( s:string );
					@global:_hla._ext( "VBASESOCKETCLASS_GETS" );
					
				a_gets:
					method  {@returns( "eax" )};
					@global:_hla._ext( "VBASESOCKETCLASS_A_GETS" );

				geti8:
					method {@returns( "AL" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETI8" );
					
				geti16:
					method  {@returns( "ax" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETI16" );
					
				geti32:
					method  {@returns( "eax" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETI32" );
					
				geti64:
					method {@returns( "edx:eax" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETI64" );

				geti128:
					method( var l:lword );
					@global:_hla._ext( "VBASESOCKETCLASS_GETI128" );

				getu8:
					method {@returns( "AL" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETU8" );
					
				getu16:
					method  {@returns( "ax" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETU16" );
					
				getu32:
					method  {@returns( "eax" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETU32" );
					
				getu64:
					method {@returns( "edx:eax" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETU64" );

				getu128:
					method( var l:lword );
					@global:_hla._ext( "VBASESOCKETCLASS_GETU128" );

				geth8:
					method {@returns( "AL" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETH8" );
					
				geth16:
					method  {@returns( "ax" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETH16" );
					
				geth32:
					method  {@returns( "eax" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETH32" );
					
				geth64:
					method {@returns( "edx:eax" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETH64" );
					
				geth128:
					method( var l:lword );
					@global:_hla._ext( "VBASESOCKETCLASS_GETH128" );

				getf:
					method {@returns( "st0" )}; 
					@global:_hla._ext( "VBASESOCKETCLASS_GETF" );



				putbool:
					method( b:boolean );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTBOOL" );
					
				putcset:
					method( cs:cset   );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTCSET" );

				putc:
					method( c:char    );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTC" );
					
				putcSize:
					method( c:char; width:int32; fill:char );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTCSIZE" );

				newln:
					method;
					@global:_hla._ext( "VBASESOCKETCLASS_NEWLN" );

				puts:
					method( s:string  );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTS" );
					
				putsSize:
					method
				( 
					s:string; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTSSIZE" );

				putz:
					method( s:zstring  );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTZ" );
					
				putzSize:
					method
				( 
					s:zstring; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTZSIZE" );

				putb:
					method( h:byte    );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTB" );
					
				putw:
					method( w:word 	  );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTW" );
					
				putd:
					method( dw:dword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTD" );
					
				putq:
					method( qw:qword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTQ" );
					
				puttb:
					method( tb:tbyte );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTTB" );
					
				putl:
					method( l:lword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTL" );

				puth8:
					method( h:byte    );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH8" );
					
				puth16:
					method( w:word 	  );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH16" );
					
				puth32:
					method( dw:dword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH32" );
					
				puth64:
					method( qw:qword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH64" );
					
				puth80:
					method( tb:tbyte );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH80" );
					
				puth128:
					method( l:lword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH128" );

				puti8:
					method ( b:byte  );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI8" );
					
				puti16:
					method( w:word  );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI16" );
					
				puti32:
					method( d:dword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI32" );
			
				puti64:
					method( q:qword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI64" );
					
				puti128:
					method( l:lword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI128" );
					

				puth8Size:
					method
				( 
					b:byte; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH8SIZE" );

				puth16Size:
					method
				( 
					w:word; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH16SIZE" );

				puth32Size:
					method
				( 
					d:dword; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH32SIZE" );
				
				puth64Size:
					method
				( 
					q:qword; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH64SIZE" );

				puth80Size:
					method
				( 
					tb:tbyte; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH80SIZE" );

				puth128Size:
					method
				( 
					l:lword; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTH128SIZE" );


				puti8Size:
					method 
				( 
					b:byte;  
					width:int32;	
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI8SIZE" );

				puti16Size:
					method
				( 
					w:word;  
					width:int32;	
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI16SIZE" );

				puti32Size:
					method
				( 
					d:dword; 
					width:int32;	
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI32SIZE" );

				puti64Size:
					method
				( 
					q:qword; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI64SIZE" );

				puti128Size:
					method
				( 
					l:lword; 
					width:int32; 
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTI128SIZE" );

				putu8:
					method( b:byte  );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU8" );
					
				putu16:
					method( w:word  );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU16" );
					
				putu32:
					method( d:dword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU32" );
					
				putu64:
					method( q:qword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU64" );
					
				putu128:
					method( l:lword );
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU128" );

				putu8Size:
					method 
				( 
					b:byte;  
					width:int32;	
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU8SIZE" );

				putu16Size:
					method
				( 
					w:word;  
					width:int32;	
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU16SIZE" );

				putu32Size:
					method
				( 
					d:dword; 
					width:int32;	
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU32SIZE" );

				putu64Size:
					method
				( 
					q:qword; 
					width:int32;	
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU64SIZE" );

				putu128Size:
					method
				( 
					l:lword; 
					width:int32;	
					fill:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTU128SIZE" );


				putr32:
					method
				( 
					r:real32; 
					width:uns32; 
					decpts:uns32;
					fill	:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTR32" );

				putr64:
					method
				( 
					r:real64; 
					width:uns32; 
					decpts:uns32;
					fill	:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTR64" );

				putr80:
					method
				( 
					r		:real80; 
					width	:uns32; 
					decpts	:uns32;
					fill	:char 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTR80" );



				pute32:
					method
				( 
					r:real32; 
					width:uns32 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTE32" );

				pute64:
					method
				( 
					r:real64; 
					width:uns32 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTE64" );

				pute80:
					method
				( 
					r:real80; 
					width:uns32 
				);
					@global:_hla._ext( "VBASESOCKETCLASS_PUTE80" );



				sPutPad:
					method( fill:char; size:uns32 );
					@global:_hla._ext( "VBASESOCKETCLASS_SPUTPAD" );



			// _put_ is used by the put macro to emit the correct
			// call depending upon the presence of width and decpts
			// parameters in addition to the value to output.

			#macro _put_( _obj_, _routine_, _typename_ );
						_invoke_, _func_, _parms_, _realsize_, _typ_;

				?_func_:string := @string:_routine_;
				?_parms_:string := "";
				?_typ_:string := @string:_typename_;

				// Real values allow two size parameters 
				// (width & decpts).

				#if( @substr( _typ_, 0, 4 ) = "real" )

					#if( _width_ <> "-1" )

						?_realsize_:string := @substr( _typ_, 4, 2 );

						// If decpts is <> -1, print in dec notation,
						// else print in sci notation.

						#if( _decpts_ <> "-1" )

							?_parms_:string := 
								"," + _width_ + "," + _decpts_ + ", ' '";
							
						#else
						 
							?_func_:string := "pute" + _realsize_;
							?_parms_:string := "," + _width_;

						#endif

					#else

						// If the user did not specify a format size,
						// then use the puteXX routines with default
						// sizes of: real32=15, real64=22, real80=28.

						?_func_:string := "pute" + _realsize_;
						#if( _realsize_ = "32" )

							?_parms_:string := ",15";

						#elseif( _realsize_ = "64" )

							?_parms_:string := ",22";

						#else

							?_parms_:string := ",28";

						#endif

					#endif

				#else //It's not a real type.

					#if( _decpts_ <> "-1" )

						#error
						( 
							"Fractional width specification "
							"is not supported here" 
						)

					#elseif( _width_ <> "-1" )

						// Width specifications are only supported for
						// certain types.  Check for that here.

						#if
						(
								_typ_ <> "uns8"
							&	_typ_ <> "uns16"
							&	_typ_ <> "uns32"
							&	_typ_ <> "int8"
							&	_typ_ <> "int16"
							&	_typ_ <> "int32"
							&	_typ_ <> "char"
							&	_typ_ <> "string"
							&	_typ_ <> "byte"
							&	_typ_ <> "word"
							&	_typ_ <> "dword"
							&	_typ_ <> "qword"
						)

							#error
							( 
								"Type " + 
								_typ_ + 
								" does not support width format "
								"option" 
							)

						#else

							?_func_:string := _func_ + "Size";
							?_parms_:string := "," + _width_ + ", ' '";

						#endif

					#endif

				#endif
							
				#if(
						@isconst( @text( _arg_ ))
					&	_typ_ = "string"
					&	_arg_ = "#13 #10"
				)

					_obj_.newln();

				#elseif( @isconst( @text( _arg_ )))

					?_invoke_:text := @string( _obj_ ) + "." +_func_;
					_invoke_( @text( _arg_ ) @text( _parms_ ));

				#else

					?_invoke_:text := @string( _obj_ ) + "." + _func_;
					_invoke_
					( 
						(type _typename_ @text( _arg_ )) @text( _parms_ )
					);

				#endif

			#endmacro



			#macro put( _parms_[] ); 
				_curparm_, _pType_, _arg_, _width_, _decpts_, 
				_sVar_, _parmArray_, _id_, _fieldCnt_;

				// Preserved ESI and EDI across all the
				// calls in this macro.

				push( esi );
				push( edi );

				?_sVar_:text := @LastObject;

				?_curparm_:uns32 := 0;
				#while( _curparm_ < @elements( _parms_ ))

					// The following stmt frees up any storage
					// currently in use by parmArray.

					?_parmArray_:uns32 := 0;

					// Get the current parameter into parmArray.

					?_parmArray_ :=	@tokenize
									(
										_parms_[ _curparm_ ],
										0,
										{':'},
										{
											'"',
											'''',
											'[',
											']',
											'(',
											')',
											'{',
											'}'
										}
									);

					?_arg_ := @trim( _parmArray_[ 0 ], 0 );
					#if( char( _arg_ ) in stdio._idchars_ )

						?_id_ := stdio._GetID_( _arg_ );
						#if
						(
								@class( _id_ ) = @global:hla.cConstant
							|	@class( _id_ ) = @global:hla.cValue
						)

							?_id_ := _arg_;

						#endif

					#else

						?_id_ := _arg_;

					#endif

					?_fieldCnt_ := @elements( _parmArray_ );
					#if( _fieldCnt_ > 1 )

						?_width_ := @trim( _parmArray_[ 1 ], 0 );

					#else

						?_width_ := "-1";

					#endif
					#if( _fieldCnt_ > 2 )

						?_decpts_ := @trim( _parmArray_[ 2 ], 0 );

					#else

						?_decpts_ := "-1";

					#endif
					#if( _fieldCnt_ > 3 )

						#error
						(
							"<<" + _parms_[ _curparm_ ] + ">>" +
							" has too many width fields"
						)

					#endif
					
					?_pType_ := @pType(  @text( _id_ ));
					#if( _pType_ = @global:hla.ptArray )

						?_pType_ := 
							@pType( @text( @typename( @text( _id_))));

					#endif

					#if( _pType_ = @global:hla.ptBoolean )
					 
						_sVar_._put_( putbool, boolean )

					#elseif( _pType_ = @global:hla.ptUns8 )
					 
						_sVar_._put_( putu8, uns8 )

					#elseif( _pType_ = @global:hla.ptUns16 ) 
					
						_sVar_._put_( putu16, uns16 )

					#elseif( _pType_ = @global:hla.ptUns32 ) 
					
						_sVar_._put_( putu32, uns32 )

					#elseif( _pType_ = @global:hla.ptByte ) 
					
						_sVar_._put_( putb, byte )

					#elseif( _pType_ = @global:hla.ptWord ) 
					
						_sVar_._put_( putw, word )

					#elseif( _pType_ = @global:hla.ptDWord ) 
					
						_sVar_._put_( putd, dword )

					#elseif( _pType_ = @global:hla.ptInt8 ) 
					
						_sVar_._put_( puti8, int8 )

					#elseif( _pType_ = @global:hla.ptInt16 ) 
					
						_sVar_._put_( puti16, int16 )

					#elseif( _pType_ = @global:hla.ptInt32 ) 
					
						_sVar_._put_( puti32, int32 )

					#elseif( _pType_ = @global:hla.ptChar ) 
					
						_sVar_._put_( putc, char )

					#elseif( _pType_ = @global:hla.ptCset ) 
					
						_sVar_._put_( putcset, cset )

					#elseif( _pType_ = @global:hla.ptReal32 ) 
					
						_sVar_._put_( putr32, real32 )

					#elseif( _pType_ = @global:hla.ptReal64 ) 
					
						_sVar_._put_( putr64, real64 )

					#elseif( _pType_ = @global:hla.ptReal80 ) 
					
						_sVar_._put_( putr80, real80 )

					#elseif( _pType_ = @global:hla.ptString )

						_sVar_._put_( puts, string )


					#elseif( _pType_ = @global:hla.ptZString )

						_sVar_._put_( putz, zstring )


					#elseif( @isclass( @text( _parms_[ _curparm_ ] )))

						#if
						( 
							@defined
							( 
								@text
								(
									 _parms_[ _curparm_ ] + 
									".toString" 
								)
							)
						)

							push( eax );
							push( esi );
							push( edi );
							@text
							( 
								_parms_[ _curparm_ ] + 
								".toString()"
							);
							_sVar_.puts( eax );
							strfree( eax );
							pop( edi );
							pop( esi );
							pop( eax );

						#else

							#error
							(
								"sock.put: Class does not provide a "
								"toString or:
				method procedure"
							);

						#endif

					#else

						#error
						( 
							"sock.put: Unknown data type (" +
							_parms_[ _curparm_ ] +
							":" +
							@typename( @text( _parms_[_curparm_] )) +
							")"
						);

					#endif
					?_curparm_ := _curparm_ + 1;

				#endwhile

				pop( edi );
				pop( esi );

			#endmacro




			#macro get( _parms_[] ); 
				_curparm_, _pType_, _arg_, _id_, _sVar_;

				?_curparm_:uns32 := 0;
				?_sVar_:text := @LastObject;
				
				// Save important registers that the "GET" macro uses.

				push( eax );
				push( esi );
				push( edi );

				// The following loop repeats once for each GET parameter
				// we process.

				#while( _curparm_ < @elements( _parms_ ))

					// If this parameter begins with an identifier,
					// there are some problems to deal with.
					// The symbol table functions (e.g., @ptype) don't
					// allow address expression components after the
					// symbol name.  Named constants, however, do allow
					// such entities.  The following code determines
					// (1) is this a symbol?  (2) if it is a symbol, is
					// it a constant?
					//
					//	For non-constant symbols, we need to strip any
					// trailing non-symbol characters from the string
					// (e.g., "[0]" ).

					?_arg_ := @trim( _parms_[ _curparm_ ], 0 );
					#if( char( _arg_ ) in stdio._idchars_ )

						// If this parameter begins with an id character,
						// then strip away any non-ID symbols from the
						// end of the string.  Then determine if we've
						// got a constant or some other class (e.g.,
						// variable or procedure).  If not a constant,
						// keep only the name.  If a constant, we need
						// to keep all trailing characters as well.

						?_id_ := stdio._GetID_( _arg_ );
						#if
						( 
								@class( _id_ ) = @global:hla.cConstant 
							|	@class( _id_ ) = @global:hla.cValue 
						)

							?_id_ := _arg_;

						#endif

					#else

						// If it's not an ID, we need to keep everything.

						?_id_ := _arg_;

					#endif



					// Determine the type of this parameter so we can
					// call the appropriate routine to input it.

					?_pType_ := @pType( @text( _id_ ));
					#if( _pType_ = @global:hla.ptArray )

						?_pType_ := 
							@pType( @text( @typename( @text( _id_ ))));

					#endif

					// Based on the type, call the appropriate library
					// routine to print this value.

					#if( _pType_ = @global:hla.ptBoolean )

						#error( "Boolean input is not supported" );

					#elseif( _pType_ = @global:hla.ptUns8 ) 
						
						_sVar_.getu8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptUns16 ) 
						
						_sVar_.getu16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptUns32 ) 
						
						_sVar_.getu32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptByte ) 
						
						_sVar_.geth8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptWord ) 
						
						_sVar_.geth16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptDWord ) 
						
						_sVar_.geth32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptInt8 ) 
						
						_sVar_.geti8();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptInt16 ) 
						
						_sVar_.geti16();
						mov( ax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptInt32 ) 
						
						_sVar_.geti32();
						mov( eax, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptChar ) 
						
						_sVar_.getc();
						mov( al, @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptCset ) 

						#error( "Cset input is not supported" );

					#elseif
					( 
							_pType_ = @global:hla.ptReal32 
						|	_pType_ = @global:hla.ptReal64 
						|	_pType_ = @global:hla.ptReal80 
					) 
						
						_sVar_.getf();
						fstp( @text( _arg_ ));

					#elseif( _pType_ = @global:hla.ptString ) 

						_sVar_.gets( @text( _arg_ ));

					#else

						#error
						( 
							"stdin.get: Unknown data type (" +
							_parms_[ _curparm_ ] +
							":" +
							@typename( @text( _id_ )) +
							")"
						);

					#endif
					?_curparm_ := _curparm_ + 1;

				#endwhile

				// Restore the registers pushed earlier for this 
				// call to the GET macro.

				pop( edi );
				pop( esi );
				pop( eax );

			#endmacro

		endclass;
			



	


	// server_t-
	//
	//	Socket server class.
	//

	connectionCallback_t	:procedure( parm:dword );
	server_t:
		class inherits( baseSocketClass_t );
		
			var
				connectedAdrs	:@global:hla.sockaddr;
				serverSockDescr	:dword;
				
				
			override proc
			
				create:
					procedure;
					@global:_hla._ext( "SERVER_T_CREATE" );
				
			// start-
			//
			// timeout thunk is called before each iteration of the
			// internal polling loop that waits for a connection.
			// On entry into the timeout thunk, EAX contains a pointer
			// to an hla.timeval object that specifies the timeout period.
			// If this is zero, there is no timeout (and the thunk will
			// never be called again if it leaves it zero).  On return
			// from the timeout thunk, if EAX contains zero, the polling
			// continues; if EAX is not zero, then start returns to
			// its caller. Other than EAX, the timeout thunk must preserve
			// all registers. 
			//
			// Procedure connectionCallback is called whenever a connection
			// is made. On entry into the procedure, EAX contains the handle
			// of the connection and ESI contains a pointer to the
			// server_t object. On return, all registers must be preserved.
			 
			proc
			
				start:
					method
					( 
						adrs				:dword; 
						port				:word; 
						timeoutCallback		:thunk;
						connectionCallback	:connectionCallback_t;
						parm				:dword
					) {@returns( "eax" )};
					@global:_hla._ext( "SERVER_T_START" );
			
				close:
					method;
					@global:_hla._ext( "SERVER_T_CLOSE" );
		
		endclass;
	

	vServer_t:
		class inherits( vBaseSocketClass_t );
		
			var
				connectedAdrs	:@global:hla.sockaddr;
				serverSockDescr	:dword;
				
				
			override proc
			
				create:
					procedure;
					@global:_hla._ext( "SERVER_T_VCREATE" );
				
			// start-
			//
			// timeout thunk is called before each iteration of the
			// internal polling loop that waits for a connection.
			// On entry into the timeout thunk, EAX contains a pointer
			// to an hla.timeval object that specifies the timeout period.
			// If this is zero, there is no timeout (and the thunk will
			// never be called again if it leaves it zero).  On return
			// from the timeout thunk, if EAX contains zero, the polling
			// continues; if EAX is not zero, then start returns to
			// its caller. Other than EAX, the timeout thunk must preserve
			// all registers. 
			//
			// Procedure connectionCallback is called whenever a connection
			// is made. On entry into the procedure, EAX contains the handle
			// of the connection and ESI contains a pointer to the
			// server_t object. On return, all registers must be preserved.
			 
			proc
				start:
					method
					( 
						adrs				:dword; 
						port				:word; 
						timeoutCallback		:thunk;
						connectionCallback	:connectionCallback_t;
						parm				:dword
					) {@returns( "eax" )};
					@global:_hla._ext( "SERVER_T_VSTART" );
			
				close:
					method;
					@global:_hla._ext( "SERVER_T_VCLOSE" );
		
		endclass;
		
		
	
	client_t:
		class inherits( baseSocketClass_t )
		
	 	
			override proc
			
				create:
					procedure;
					@global:_hla._ext( "CLIENT_T_CREATE" );

			proc
			
				connect:
					method
					( 
						adrs		:dword; 
						port		:word 
					) {@returns( "eax" )};
					@global:_hla._ext( "CLIENT_T_CONNECT" );
					
				close:
					method;
					@global:_hla._ext( "CLIENT_T_CLOSE" );
		
		endclass;
		
		
	
	vClient_t:
		class inherits( vBaseSocketClass_t )
		
		
			override proc
			
				create:
					procedure;
					@global:_hla._ext( "CLIENT_T_VCREATE" );

			proc
				connect:
					method
					( 
						adrs		:dword; 
						port		:word 
					) {@returns( "eax" )};
					@global:_hla._ext( "CLIENT_T_VCONNECT" );
					
				close:
					method;
					@global:_hla._ext( "CLIENT_T_VCLOSE" );
		
		endclass;
	


#endif // sockets_hhf
