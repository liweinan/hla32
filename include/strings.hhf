#if( ! @defined( string_hhf ))
?string_hhf := true;

#includeOnce( "hla.hhf" )
#includeOnce( "stdio.hhf" )
#includeOnce( "zstrings.hhf" )
#includeOnce( "buf.hhf" )
#includeOnce( "os.hhf" )
#includeOnce( "overload.hhf" )
			
				

namespace str; @fast; 

	/*
	** Note: HLA strings consist of a pointer that points at
	** a zero terminated array of characters.  This array of
	** characters is at least four bytes long and is always an
	** even multiple of four characters long.
	**  
	** The eight bytes immediately before this pointer 
	** contain the maximum length and the current dynamic length
	** of the string data.
	**
	** The strRec record provides a template for such a string.
	** The strData field is specified as an array of 12 characters
	** to ensure that the size of this structure is 12 bytes (the
	** "-8" starting offset reduces the size of the record by
	** eight bytes, so this is corrected in the strData field).
	** If you have a pointer to an "strRec" record, the pointer
	** should be pointing at the strData field.  Then you can use
	** the MaxStrLen and length fieldnames to access those fields
	** at the appropriate negative offsets. 
	*/

	type
		strRec:	record := -8;

					// MaxStrLen changed to maxlen!
					
					union
						MaxStrLen	:dword;
						maxlen		:dword;
					endunion;
					length		:dword;
					strData		:char[12];

				endrecord;

	const
		BytesBeforeStr := 8;



	// str.constant( literal_constant )
	//
	//	This macro creates a string constant object whose address
	// you may assign to a string variable.  This is useful, for
	// example, when initializing fields of a record with string data.
	
	#macro constant( __strconst ):__strname,__padding;
		forward( __strname );
			align(4);
			dword @length( __strconst ), @length( __strconst );
		__strname:char; @nostorage;
			byte __strconst, 0;
			?__padding := ((4 - ((@length( __strconst ) + 1) mod 4)) mod 4);
			#while( __padding > 0 )
			
				byte 0;
				?__padding -= 1;
				
			#endwhile
			
	#endmacro


	// str.strvar-	Allocates storage for a static string in
	//				the HLA STATIC section.

	#macro strvar( strsize ): _strVar_;

		#if( ( @section & hla.inStatic ) != hla.inStatic )

			#error( "str.strvar is legal only in the STATIC section" )
			string // To prevent cascading errors

		#elseif( !@IsConst( strsize ) | !hla.isNumber( strsize ) )

			#error( "Expected an integer constant string size" );
			string // To prevent cascading errors

		#else
				string := &_strVar_;
				align(4);
				dword strsize;
				dword 0;
			    _strVar_: char[ ( strsize + 4 ) & -4 ] :=
				    [(( strsize + 4 ) & -4 ) dup [#0] ]

		#endif

	#endmacro



	proc

		// str.init- Initializes a block of memory for use as
		//			 a string variable.  Returns the pointer
		//			 to the string object in EAX.  Note that
		//			 the numBytes parameter specifies the
		//			 total number of bytes in the block of
		//			 memory, not the desired maximum string
		//			 length.  This value should be at least
		//			 16 greater than the desired maximum 
		//			 string length.

		init:
			procedure( var b:var; numBytes:dword ) {@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_INIT" );
			
			
		// String length functions and macros.
		
		length:
			procedure( s:string ) {@returns( "eax" )}; 
			@global:_hla._ext( "STR_LENGTH" );
			
			
		// String Assignment and copy functions.
		
		a_cpy:
			procedure( src:string ) {@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_CPY" );

		cpy:
			procedure( src:string; dest:string ) {@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_CPY" ); 

		cpyz:
			procedure( zstr:zstring; dest:string );
			@global:_hla._ext( "STR_CPYZ" );

		a_cpyz:
			procedure( zstr:zstring ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_CPYZ" );

		a_setstr:
			procedure( src:char; count:uns32 ) {@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_SETSTR" );

		setstr:
			procedure
			( 
				src:char; 
				cnt:uns32; 
				dest:string 
			);
			@global:_hla._ext( "STR_SETSTR" );



	const
		a_bufToStr	:text := "str.a_bufToStr2";

	proc
	
		a_bufToStr2:
			procedure( startBuf:dword; endBuf:dword ) 
				{@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_BUFTOSTR2" );

		a_bufToStr1:
			procedure( buf:@global:buf_t ) {@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_BUFTOSTR2" );		// Yes, STR_A_BUFTOSTR2
			
		

	const
		bufToStr	:text := "str.bufToStr3";
		
	proc
	
		bufToStr2:
			procedure( buf:@global:buf_t; dest:string );
			@global:_hla._ext( "STR_BUFTOSTR3" );	// Yes, STR_BUFTOSTR3

		bufToStr3:
			procedure( startBuf:dword; endBuf:dword; dest:string );
			@global:_hla._ext( "STR_BUFTOSTR3" );



		// Substring functions:
		
		
		substr:
			procedure
			(
				src		:string; 
				start	:dword; 
				len		:dword; 
				dest	:string 
			) 	{@returns( "@c" )};
			@global:_hla._ext( "STR_SUBSTR" );


		a_substr:
			procedure
			(
				src		:string; 
				start	:dword; 
				len		:dword 
			) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_A_SUBSTR" );





//		#macro first( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.first2(string, dword) )
//				hla.signature( str.first3(string, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro


		first2:
			procedure
			(
				s		:string;
				len		:dword
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRST2" );

		first3:
			procedure
			(
				s		:string;
				len		:dword;
				dest	:string
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRST3" );
			

		a_first:
			procedure
			(
				src:	string;
				len:	dword
			) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_A_FIRST" );

		 



//		#macro last( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.last2(string, dword) )
//				hla.signature( str.last3(string, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro


		last2:
			procedure
			(
				s:		string;
				len:	dword
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_LAST2" );

		last3:
			procedure
			(
				s		:string;
				len		:dword;
				dest	:string
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_LAST3" );

		a_last:
			procedure
			(
				src:	string;
				len:	dword
			) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_A_LAST" );




//		#macro truncate( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.truncate2(string, dword) )
//				hla.signature( str.truncate3(string, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro


		truncate2:
			procedure( dest:string; rmvlen:dword ) {@returns( "@c" )};
			@global:_hla._ext( "STR_TRUNCATE2" );
			
		truncate3:
			procedure( src:string; rmvlen:dword; dest:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_TRUNCATE3" );
			
		a_truncate:
			procedure( src:string; rmvlen:dword ) {@returns( "@c" )};
			@global:_hla._ext( "STR_A_TRUNCATE" );
			
		 


		// String insertion and deletion functions
		
//		#macro insert( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.insert3(string, dword, string) )
//				hla.signature( str.insert4(string, dword, string, string) )
//				
//			hla.endoverload
//			
//		#endmacro


		
		insert3:
			procedure
			(
				ins		:string;
				start	:dword;
				dest	:string
			);  @global:_hla._ext( "STR_INSERT3" );

		insert4:
			procedure
			(
				ins		:string;
				start	:dword;
				src		:string;
				dest	:string
			);  @global:_hla._ext( "STR_INSERT4" );

		a_insert:
			procedure
			(
				ins		:string;
				start	:dword;
				src		:string
			) {@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_INSERT" );





		
//		#macro delete( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.delete3(string, dword, dword) )
//				hla.signature( str.delete4(string, dword, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro


		
		delete3:
			procedure
			(
				s		:string;
				start	:dword;
				len		:dword
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_DELETE3" );

		delete4:
			procedure
			(
				s		:string;
				start	:dword;
				len		:dword;
				dest	:string
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_DELETE4" );

		a_delete:
			procedure
			(
				s:		string;
				start:	dword;
				len:	dword
			) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_A_DELETE" );
			
		
//		#macro delLeadingSpaces( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.delLeadingSpaces1(string) )
//				hla.signature( str.delLeadingSpaces2(string, string) )
//				
//			hla.endoverload
//			
//		#endmacro

		delLeadingSpaces1:
			procedure( s: string );
			@global:_hla._ext( "STR_DELLEADINGSPACES1" );
			
		delLeadingSpaces2:
			procedure( src: string; dest:string );
			@global:_hla._ext( "STR_DELLEADINGSPACES2" );
			
		a_delLeadingSpaces:
			procedure( src: string ) {@returns( "(type string eax)" )};				
			@global:_hla._ext( "STR_A_DELLEADINGSPACES" );



//		#macro trim( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.trim1(string) )
//				hla.signature( str.trim2(string, string) )
//				
//			hla.endoverload
//			
//		#endmacro

		trim1:
			procedure( s: string );
			@global:_hla._ext( "STR_TRIM1" );
			
		trim2:
			procedure( src: string; dest:string );
			@global:_hla._ext( "STR_TRIM2" );
			
		a_trim:
			procedure( src: string ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_TRIM" );
		


//		#macro delTrailingSpaces( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.delTrailingSpaces1(string) )
//				hla.signature( str.delTrailingSpaces2(string, string) )
//				
//			hla.endoverload
//			
//		#endmacro

		delTrailingSpaces1:
			procedure( s: string );
			@global:_hla._ext( "STR_DELTRAILINGSPACES1" );
			
		delTrailingSpaces2:
			procedure( src:string; dest: string );
			@global:_hla._ext( "STR_DELTRAILINGSPACES2" );
			
		a_delTrailingSpaces:
			procedure( src: string ) {@returns( "(type string eax)" )}; 	
			@global:_hla._ext( "STR_A_DELTRAILINGSPACES" );


		rmvTrailingSpaces1:
			procedure( dest: string );
			@global:_hla._ext( "STR_RMVTRAILINGSPACES1" );

		rmvTrailingSpaces2:
			procedure( src:string; dest: string );
			@global:_hla._ext( "STR_RMVTRAILINGSPACES2" );
			
		a_rmvTrailingSpaces:
			procedure( src: string ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_RMVTRAILINGSPACES" );
		
		


		// String comparison functions.

		eq:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_EQ" );

		ne:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_NE" );

		lt:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_LT" );

		gt:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_GT" );

		le:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_LE" );

		ge:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_GE" );
		 
		ieq:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_EQI" );

		ine:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_NEI" );

		ilt:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_LTI" );

		igt:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_GTI" );

		ile:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_LEI" );

		ige:
			procedure( src1:string; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_GEI" );
		 


		// String searching functions:
		

//		#macro prefix( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.prefix2(string, string) )
//				hla.signature( str.prefix3(string, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro
			
		prefix2:
			procedure( src1:string; src2:string )	// Same as matchStr2!	
				{@returns( "@c" )}; 
			@global:_hla._ext( "STR_PREFIX2" );

		
		prefix3:
			procedure( src1:string; offs:dword; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_PREFIX3" );



//		#macro iprefix( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.iprefix2(string, string) )
//				hla.signature( str.iprefix3(string, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		iprefix2:
			procedure( src1:string; src2:string )	// Same as matchiStr2!	
				{@returns( "@c" )}; 
			@global:_hla._ext( "STR_IPREFIX2" );

		
		iprefix3:
			procedure( src1:string; offs:dword; src2:string ) {@returns( "@c" )}; 
			@global:_hla._ext( "STR_IPREFIX3" );

		


//		#macro index( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.index2(string, string) )
//				hla.signature( str.index3(string, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		index2:
			procedure( src1:string; src2:string ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_INDEX2" );

		index3:
			procedure( src1:string; offs:dword; src2:string ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_INDEX3" );






//		#macro iindex( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.iindex2(string, string) )
//				hla.signature( str.iindex3(string, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		iindex2:
			procedure( src1:string; src2:string ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_IINDEX2" );


		iindex3:
			procedure( src1:string; offs:dword; src2:string ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_IINDEX3" );



//		#macro rindex( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.rindex2(string, string) )
//				hla.signature( str.rindex3(string, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		rindex2:
			procedure( src1:string; src2:string ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_RINDEX2" );

		rindex3:
			procedure( src1:string; offs:dword; src2:string ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_RINDEX3" );



//		#macro irindex( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.irindex2(string, string) )
//				hla.signature( str.irindex3(string, dword, string) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		irindex2:
			procedure( src1:string; src2:string ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_IRINDEX2" );


		irindex3:
			procedure( src1:string; offs:dword; src2:string ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_IRINDEX3" );
			


//		#macro chpos( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.chpos2( string, char) )
//				hla.signature( str.chpos3( string, dword, char) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		chpos2:
			procedure( src1:string; src2:char ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_CHPOS2" );


		chpos3:
			procedure( src1:string; offs:dword; src2:char ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_CHPOS3" );



//		#macro ichpos( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.ichpos2( string, char) )
//				hla.signature( str.ichpos3( string, dword, char) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		ichpos2:
			procedure( src1:string; src2:char ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_ICHPOS2" );


		ichpos3:
			procedure( src1:string; offs:dword; src2:char ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_ICHPOS3" );





//		#macro rchpos( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.rchpos2(string, char) )
//				hla.signature( str.rchpos3(string, dword, char) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		rchpos2:
			procedure( src1:string; src2:char ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_RCHPOS2" );

		rchpos3:
			procedure( src1:string; offs:dword; src2:char ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_RCHPOS3" );


//		#macro irchpos( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.irchpos2(string, char) )
//				hla.signature( str.irchpos3(string, dword, char) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		irchpos2:
			procedure( src1:string; src2:char ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_IRCHPOS2" );

		irchpos3:
			procedure( src1:string; offs:dword; src2:char ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_IRCHPOS3" );


		// Searching for characters in/not in a character set.
		//
		// Note: "span" and "brk" are particularly non-mnemonic
		// names inherited from stdlib v1.x (and the C stdlib).
		// skipInCset and findInCset are the newer, improved,
		// names. Eventually (though not right now), the span
		// and brk names will be deprecated.

//		#macro span( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.span2(string, cset) )
//				hla.signature( str.span3(string, dword, cset) )
//				
//			hla.endoverload
//			
//		#endmacro
//		
//		#macro skipInCset( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.skipInCset2(string, cset) )
//				hla.signature( str.skipInCset3(string, dword, cset) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		span2:
			procedure( src1: string; src2:cset ) {@returns( "eax" )};	// and @c 
			@global:_hla._ext( "STR_SKIPINCSET2" );


		span3:
			procedure( src1: string; start:dword; src2:cset ) {@returns( "eax" )};	// and @c 
			@global:_hla._ext( "STR_SKIPINCSET3" );
		
		skipInCset2:
			procedure( src1: string; src2:cset ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_SKIPINCSET2" );


		skipInCset3:
			procedure( src1: string; start:dword; src2:cset ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_SKIPINCSET3" );





//		#macro rspan( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.rspan2(string, cset) )
//				hla.signature( str.rspan3(string, dword, cset) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		rspan2:
			procedure( src1: string; src2:cset ) {@returns( "eax" )};	// and @c 
			@global:_hla._ext( "STR_RSKIPINCSET2" );


		rspan3:
			procedure( src1: string; start:dword; src2:cset ) {@returns( "eax" )};	// and @c 
			@global:_hla._ext( "STR_RSKIPINCSET3" );



//		#macro rskipInCset( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.rskipInCset2(string, cset) )
//				hla.signature( str.rskipInCset3(string, dword, cset) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		rskipInCset2:
			procedure( src1: string; src2:cset ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_RSKIPINCSET2" );


		rskipInCset3:
			procedure( src1: string; start:dword; src2:cset ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_RSKIPINCSET3" );





//		#macro brk( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.brk2(string, cset) )
//				hla.signature( str.brk3(string, dword, cset) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		brk2:
			procedure( src1: string; src2:cset ) {@returns( "eax" )};	// and @c 
			@global:_hla._ext( "STR_FINDINCSET2" );


		brk3:
			procedure( src1: string; start:dword; src2:cset ) {@returns( "eax" )};	// and @c 
			@global:_hla._ext( "STR_FINDINCSET3" );




//		#macro findInCset( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.findInCset2(string, cset) )
//				hla.signature( str.findInCset3(string, dword, cset) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		findInCset2:
			procedure( src1: string; src2:cset ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_FINDINCSET2" );


		findInCset3:
			procedure( src1: string; start:dword; src2:cset ) {@returns( "@c" )};	// and eax 
			@global:_hla._ext( "STR_FINDINCSET3" );






//		#macro rbrk( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.rbrk2(string, cset) )
//				hla.signature( str.rbrk3(string, dword, cset) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		rbrk2:
			procedure( src1: string; src2:cset ) {@returns( "eax" )};	// and @c 
			@global:_hla._ext( "STR_RFINDINCSET2" );


		rbrk3:
			procedure( src1: string; start:dword; src2:cset ) {@returns( "eax" )};	// and @c 
			@global:_hla._ext( "STR_RFINDINCSET3" );





//		#macro rfindInCset( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.rfindInCset2(string, cset) )
//				hla.signature( str.rfindInCset3(string, dword, cset) )
//				
//			hla.endoverload
//			
//		#endmacro
		
		rfindInCset2:
			procedure( src1: string; src2:cset ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_RFINDINCSET2" );


		rfindInCset3:
			procedure( src1: string; start:dword; src2:cset ) {@returns( "@c" )};	// and EAX 
			@global:_hla._ext( "STR_RFINDINCSET3" );



		// String parsing functions:
		
//		#macro tokenCnt( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.tokenCnt1(string) )
//				hla.signature( str.tokenCnt2(string, cset) )
//				
//			hla.endoverload
//			
//		#endmacro


		
		tokenCnt1:
			procedure
			(
				src		:string
			) {@returns( "eax" )}; 
			@global:_hla._ext( "STR_TOKENCNT1" );
			
		tokenCnt2:
			procedure
			(
				src	:string;
				delims	:cset
			) {@returns( "eax" )}; 
			@global:_hla._ext( "STR_TOKENCNT2" );
			
			
			
		tokenize:
			procedure
			(
					src:		string;
				var	dest:		var;
					maxStrs:	dword
			) {@returns( "eax" )}; 
			@global:_hla._ext( "STR_TOKENIZE" );
			
	const tokenize3 :text := "@global:str.tokenize";


	proc

		tokenize4:
			procedure
			(
					src:		string;
					delims:		cset;
				var	dest:		var;
					maxStrs:	dword
			) {@returns( "eax" )}; 
			@global:_hla._ext( "STR_TOKENIZE4" );
			
			
		tokenInStr:
			iterator( src:string );
			@global:_hla._ext( "STR_TOKENINSTR" );

		tokenInStr2:
			iterator( src:string; delims:cset );
			@global:_hla._ext( "STR_TOKENINSTR2" );

		charInString:
			iterator( s:string );
			@global:_hla._ext( "STR_CHARINSTR" );

			
		wordInStr:
			iterator( s:string );
			@global:_hla._ext( "STR_WORDINSTR" );
			
			
		a_getField2:
			procedure( s:string; field:dword ) {@returns( "@c" )};	// carry set = success, returns pointer in EAX 
			@global:_hla._ext( "STR_A_GETFIELD2" );
			
		a_getField3:
			procedure( s:string; field:dword; cst:cset ) {@returns( "@c" )};	// carry set = success, returns pointer in EAX 
			@global:_hla._ext( "STR_A_GETFIELD3" );
			
		getField3:
			procedure( s:string; field:dword; dest:string ) {@returns( "@c" )};	// carry set = success
			@global:_hla._ext( "STR_GETFIELD3" );

		getField4:
			procedure( s:string; field:dword; cst:cset; dest:string ) {@returns( "@c" )};	// carry set = success
			@global:_hla._ext( "STR_GETFIELD4" );
			
		_getFieldIndex: // not meant to be called by user since it does 
						// not preserve registers
			procedure( s:string; field:dword; var cst:cset )
				{@returns( "@c" )};	// carry set = success, EAX = index
			@global:_hla._ext( "STR__GETFIELDINDEX" );


		rmv1stChar1:
			procedure( s:string ) {@returns( "al" )};
			@global:_hla._ext( "STR_RMV1STCHAR1" );
			
		rmv1stChar2:
			procedure( s:string; remainder:string ) {@returns( "al" )};
			@global:_hla._ext( "STR_RMV1STCHAR2" );
			
		rmvLastChar1:
			procedure( s:string ) {@returns( "al" )};
			@global:_hla._ext( "STR_RMVLASTCHAR1" );
			
		rmvLastChar2:
			procedure( s:string; remainder:string ) {@returns( "al" )};
			@global:_hla._ext( "STR_RMVLASTCHAR2" );


		_removeWord:
			procedure
			(  
				s			:string; 
				lastWord	:boolean;
				wordStr		:string; 
				remainder	:string 
			) {@returns( "@c" )};
			@global:_hla._ext( "STR__REMOVEWORD" );

		a_rmv1stWord1:
			procedure( s:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_A_RMV1STWORD1" );

		a_rmv1stWord2:
			procedure( s:string; remainder:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_A_RMV1STWORD2" );
	  
		rmv1stWord2:
			procedure( s:string; wordStr:string ) {@returns( "@c" )};	// and EAX
			@global:_hla._ext( "STR_RMV1STWORD2" );

		rmv1stWord3:
			procedure( s:string; wordStr:string; remainder:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_RMV1STWORD" );

		a_rmvLastWord1:
			procedure( s:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_A_RMVLASTWORD1" );

		a_rmvLastWord2:
			procedure( s:string; remainder:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_A_RMVLASTWORD2" );

		rmvLastWord2:
			procedure( s:string; wordStr:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_RMVLASTWORD2" );

		rmvLastWord3:
			procedure( s:string; wordStr:string; remainder:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_RMVLASTWORD3" );

			
		// String formatting functions
			
		a_columnize2:
			procedure( var s:var; numStrs:dword ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_COLUMNIZE2" );
		
		a_columnize3:
			procedure( var s:var; numStrs:dword; tabCols:dword ) {@returns( "(type string eax)" )};	
			@global:_hla._ext( "STR_A_COLUMNIZE3" );

		columnize3:
			procedure( var s:var; numStrs:dword; dest:string );
			@global:_hla._ext( "STR_COLUMNIZE3" );

		columnize4:
			procedure( var s:var; numStrs:dword; tabCols:dword; dest:string );
			@global:_hla._ext( "STR_COLUMNIZE4" );
			

		spread2:
			procedure( s:string; toWidth:dword ) {@returns( "@c" )};
			@global:_hla._ext( "STR_SPREAD2" );
			
		spread3:
			procedure( s:string; toWidth:dword; dest:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_SPREAD3" );

		a_spread:
			procedure( s:string; toWidth:dword ) {@returns( "@c" )};
			@global:_hla._ext( "STR_A_SPREAD" );
			
		_spread:
			procedure( src:string; dst:string; width:dword );
			@global:_hla._ext( "STR__SPREAD" ); // utility function, now for calling
			
		
		_tabulate:
			procedure 
			(
				s				:string;
				tabCols			:dword;
				var tabCols_a	:var;
				dest			:string;
				tabChar			:char
			);
			@global:_hla._ext( "STR__TABULATE" );

		a_deTab2:
			procedure( s:string; tabCols:dword ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_DETAB2" );
			
		a_deTab3:
			procedure( s:string; var tabCols:var; numTabs: dword ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_DETAB3" );

		deTab2:
			procedure( s:string; tabCols:dword );
			@global:_hla._ext( "STR_DETAB2" );

		deTab3a:
			procedure( s:string; tabCols:dword; dest:string );
			@global:_hla._ext( "STR_DETAB3a" );

		deTab3b:
			procedure( s:string; var tabCols:var; numTabs: dword );
			@global:_hla._ext( "STR_DETAB3b" );

		deTab4:
			procedure( s:string; var tabCols:var; numTabs: dword; dest:string );
			@global:_hla._ext( "STR_DETAB4" );

		a_enTab2:
			procedure( s:string; tabCols:dword ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_ENTAB2" );
			
		a_enTab3:
			procedure( s:string; var tabCols:var; numTabs: dword ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_ENTAB3" );
			
		enTab2:
			procedure( s:string; tabCols:dword );
			@global:_hla._ext( "STR_ENTAB2" );
		
		enTab3a:
			procedure( s:string; tabCols:dword; dest:string );
			@global:_hla._ext( "STR_ENTAB3a" );
			
		enTab3b:
			procedure( s:string; var tabCols:var; numTabs: dword );
			@global:_hla._ext( "STR_ENTAB3b" );
			
		enTab4:
			procedure( s:string; var tabCols:var; numTabs: dword; dest:string );
			@global:_hla._ext( "STR_ENTAB4" );



		// String conversion functions:
		

//		#macro upper( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.upper1(string) )
//				hla.signature( str.upper2(string, string) )
//				
//			hla.endoverload
//			
//		#endmacro

		upper1:
			procedure( s: string );
			@global:_hla._ext( "STR_UPPER1" );
			
		upper2:
			procedure( src: string; dest:string );
			@global:_hla._ext( "STR_UPPER2" );
			
		a_upper:
			procedure( src: string ) {@returns( "(type string eax)" )}; 				
			@global:_hla._ext( "STR_A_UPPER" );

//		#macro lower( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.lower1(string) )
//				hla.signature( str.lower2(string, string) )
//				
//			hla.endoverload
//			
//		#endmacro

		lower1:
			procedure( s: string );
			@global:_hla._ext( "STR_LOWER1" );
			
		lower2:
			procedure( src: string; dest:string );
			@global:_hla._ext( "STR_LOWER2" );
			
		a_lower:
			procedure( src: string ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_LOWER" );


//		#macro translate( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.translate3(string, string, string ) )
//				hla.signature( str.translate4(string, string, string, string) )
//				
//			hla.endoverload
//			
//		#endmacro

		translate3:
			procedure
			( 
				src:string; 
				from:string; 
				toStr:string 
			);
			@global:_hla._ext( "STR_TRANSLATE3" );

		translate4:
			procedure
			( 
				src:string; 
				from:string; 
				toStr:string; 
				dest:string 
			);
			@global:_hla._ext( "STR_TRANSLATE4" );

		a_translate:
			procedure( src:string; from:string; toStr:string ) 
				{@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_TRANSLATE" );	
		

//		#macro reverse( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.reverse1(string ) )
//				hla.signature( str.reverse2(string, string ) )
//				
//			hla.endoverload
//			
//		#endmacro

		reverse1:
			procedure( dest:string );
			@global:_hla._ext( "STR_REVERSE1" );

		reverse2:
			procedure( src:string; dest:string );
			@global:_hla._ext( "STR_REVERSE2" );

		a_reverse:
			procedure( src:string ) {@returns( "(type string eax)" )};
			@global:_hla._ext( "STR_A_REVERSE" );






		// String concatentation functions.
		
//		#macro cat( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.cat2(string, string) )
//				hla.signature( str.cat3(string, string, string) )
//				
//			hla.endoverload
//			
//		#endmacro


		cat2:
			procedure( src:string; dest:string );
			@global:_hla._ext( "STR_CAT2" );

		cat3:
			procedure( src1:string; src2:string; dest:string ) 
				{@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_CAT3" );

		a_cat:
			procedure( src1:string; src2:string ) {@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_CAT" );




		catz:
			procedure( zsrc:zstring; dest:string );
			@global:_hla._ext( "STR_CATZ" );

		a_catz:
			procedure( zsrc:zstring; ssrc:string ) {@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_CATZ" );



//		#macro catsub( parms[] );
//		
//			hla.overload( parms )
//			
//				hla.signature( str.catsub4(string, dword, dword, string) )
//				hla.signature( str.catsub5(string, dword, dword, string, string) )
//				
//			hla.endoverload
//			
//		#endmacro


		catsub4:
			procedure( src:string; start:dword; len:dword; dest:string );
			@global:_hla._ext( "STR_CATSUB4" );

		catsub5:
			procedure
			( 
				src2	:string; 
				start	:dword; 
				len		:dword; 
				src1	:string; 
				dest	:string 
			);
			@global:_hla._ext( "STR_CATSUB5" );

		a_catsub:
			procedure( src2:string; start:dword; len:dword; src1:string ) 
				{@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_CATSUB" );



	const
		a_catbuf	:text := "str.a_catbuf3";
		catbuf		:text := "str.catbuf3a";
		
	proc
	
		a_catbuf2:
			procedure( src1:@global:buf_t; src2:string ) 
				{@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_CATBUF3" );		// Yes, STR_A_CATBUF3

		a_catbuf3:
			procedure
			( 
				startBuf	:dword; 
				endBuf		:dword; 
				src			:string 
			) {@returns( "(type string eax)" )}; 
			@global:_hla._ext( "STR_A_CATBUF3" );



		catbuf2:
			procedure( src:@global:buf_t; dest:string );
			@global:_hla._ext( "STR_CATBUF3A" );		// Yes, STR_CATBUF3A

		catbuf3a:
			procedure
			( 
				startBuf	:dword; 
				endBuf		:dword; 
				dest		:string 
			);
			@global:_hla._ext( "STR_CATBUF3A" );

		catbuf3b:
			procedure
			( 
				src1		:@global:buf_t; 
				src2		:string; 
				dest		:string 
			);
			@global:_hla._ext( "STR_CATBUF4" );	// Yes, STR_CATBUF4

		catbuf4:
			procedure
			( 
				startBuf	:dword; 
				endBuf		:dword;
				src2		:string; 
				dest		:string 
			);
			@global:_hla._ext( "STR_CATBUF4" );





			
		// Value concatenation routines:
				   
		catbool:
			procedure( dest:string;  b:boolean );
			@global:_hla._ext( "STR_CATBOOL" );

		catcSize:
			procedure( dest:string;  c:char; width:int32; fill:char );
			@global:_hla._ext( "STR_CATCSIZE" );

		catc:
			procedure( dest:string;  c:char );
			@global:_hla._ext( "STR_CATC" );


		cats:
			procedure( dest:string;  src:string );
			@global:_hla._ext( "STR_CATS" );

		catsSize:
			procedure( dest:string; s:string; width:int32; fill:char );
			@global:_hla._ext( "STR_CATSSIZE" );


		catzs:
			procedure( dest:string;  src:zstring );
			@global:_hla._ext( "STR_CATZS" );

		catzsSize:
			procedure( dest:string; s:zstring; width:int32; fill:char );
			@global:_hla._ext( "STR_CATZSSIZE" );


		catcset:
			procedure( dest:string;  c:cset );
			@global:_hla._ext( "STR_CATCSET" );


		catbin8:
			procedure( dest:string;  b:byte );
			@global:_hla._ext( "STR_CATBIN8" );


		catb:
			procedure( dest:string;  b:byte );
			@global:_hla._ext( "STR_CATB" );

		catw:
			procedure( dest:string;  w:word );
			@global:_hla._ext( "STR_CATW" );

		catd:
			procedure( dest:string;  d:dword );
			@global:_hla._ext( "STR_CATD" );

		catq:
			procedure( dest:string;  q:qword );
			@global:_hla._ext( "STR_CATQ" );

		cattb:
			procedure( dest:string;  tb:tbyte );
			@global:_hla._ext( "STR_CATTB" );
			
		catl:
			procedure( dest:string;  l:lword );
			@global:_hla._ext( "STR_CATL" );


		// Note: catbSize, catwSize, ..., catlSize are all deprecated.
		
		catbSize:
			procedure( dest:string;  b:byte; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH8SIZE" );

		catwSize:
			procedure( dest:string;  w:word; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH16SIZE" );

		catdSize:
			procedure( dest:string;  d:dword; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH32SIZE" );

		catqSize:
			procedure( dest:string;  q:qword; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH64SIZE" );

		cattbSize:
			procedure( dest:string;  tb:tbyte; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH80SIZE" );

		catlSize:
			procedure( dest:string;  l:lword; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH128SIZE" );






		cath8:
			procedure( dest:string;  b:byte );
			@global:_hla._ext( "STR_CATH8" );

		cath16:
			procedure( dest:string;  w:word );
			@global:_hla._ext( "STR_CATH16" );

		cath32:
			procedure( dest:string;  d:dword );
			@global:_hla._ext( "STR_CATH32" );

		cath64:
			procedure( dest:string;  q:qword );
			@global:_hla._ext( "STR_CATH64" );

		cath80:
			procedure( dest:string;  tb:tbyte );
			@global:_hla._ext( "STR_CATH80" );

		cath128:
			procedure( dest:string;  l:lword );
			@global:_hla._ext( "STR_CATH128" );

			

		cath8Size:
			procedure( dest:string;  b:byte; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH8SIZE" );

		cath16Size:
			procedure( dest:string;  w:word; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH16SIZE" );

		cath32Size:
			procedure( dest:string;  d:dword; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH32SIZE" );

		cath64Size:
			procedure( dest:string;  q:qword; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH64SIZE" );

		cath80Size:
			procedure( dest:string;  tb:tbyte; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH80SIZE" );

		cath128Size:
			procedure( dest:string;  l:lword; size:dword; fill:char );
			@global:_hla._ext( "STR_CATH128SIZE" );





		catu8:
			procedure( dest:string;  u8:byte );
			@global:_hla._ext( "STR_CATU8" );

		catu8Size:
			procedure
			( 
				dest:string; 
				u8:byte; 
				width:int32; 
				fill:char 
			);
			@global:_hla._ext( "STR_CATU8SIZE" );

		catu16:
			procedure( dest:string;  u16:word );
			@global:_hla._ext( "STR_CATU16" );

		catu16Size:
			procedure
			( 
				dest:string; 
				u16:word; 
				width:int32;
				fill:char 
			);
			@global:_hla._ext( "STR_CATU16SIZE" );

		catu32:
			procedure( dest:string;  u32:dword );
			@global:_hla._ext( "STR_CATU32" );

		catu32Size:
			procedure
			( 
				dest:string;
				u32:dword; 
				width:int32;
				fill:char 
			);
			@global:_hla._ext( "STR_CATU32SIZE" );

		catu64:
			procedure( dest:string;  u64:qword );
			@global:_hla._ext( "STR_CATU64" );

		catu64Size:
			procedure
			( 
				dest:string;
				u64:qword; 
				width:int32;
				fill:char 
			);
			@global:_hla._ext( "STR_CATU64SIZE" );

		catu128:
			procedure( dest:string;  u128:lword );
			@global:_hla._ext( "STR_CATU128" );

		catu128Size:
			procedure
			( 
				dest:string;
				u128:lword; 
				width:int32;
				fill:char 
			);
			@global:_hla._ext( "STR_CATU128SIZE" );







		cati8:
			procedure( dest:string;  i8:byte );
			@global:_hla._ext( "STR_CATI8" );

		cati8Size:
			procedure
			( 
				dest:string;
				i8:byte; 
				width:int32; 
				fill:char 
			);
			@global:_hla._ext( "STR_CATI8SIZE" );

		cati16:
			procedure( dest:string;  i16:word );
			@global:_hla._ext( "STR_CATI16" );

		cati16Size:
			procedure
			( 
				dest:string;
				i16:word; 
				width:int32;
				fill:char 
			);
			@global:_hla._ext( "STR_CATI16SIZE" );

		cati32:
			procedure( dest:string;  i32:dword );
			@global:_hla._ext( "STR_CATI32" );

		cati32Size:
			procedure
			( 
				dest:string; 
				i32:dword; 
				width:int32;
				fill:char 
			);
			@global:_hla._ext( "STR_CATI32SIZE" );

		cati64:
			procedure( dest:string;  i64:qword );
			@global:_hla._ext( "STR_CATI64" );

		cati64Size:
			procedure
			( 
				dest:string; 
				i64:qword; 
				width:int32;
				fill:char 
			);
			@global:_hla._ext( "STR_CATI64SIZE" );

		cati128:
			procedure( dest:string;  i128:lword );
			@global:_hla._ext( "STR_CATI128" );

		cati128Size:
			procedure
			( 
				dest:string; 
				i128:lword; 
				width:int32;
				fill:char 
			);
			@global:_hla._ext( "STR_CATI128SIZE" );


		catr80:
			procedure
			( 
				dest:string; 
				r:real80; 
				width:int32; 
				decpts:uns32
			);
			@global:_hla._ext( "STR_CATR80" );

		catr80pad:
			procedure
			( 
				dest:string; 
				r:real80; 
				width:int32; 
				decpts:uns32; 
				pad:char
			);
			@global:_hla._ext( "STR_CATR80PAD" );

		catr64:
			procedure
			( 
				dest:string; 
				r:real64; 
				width:int32; 
				decpts:uns32
			);
			@global:_hla._ext( "STR_CATR64" );

		catr64pad:
			procedure
			( 
				dest:string; 
				r:real64; 
				width:int32; 
				decpts:uns32; 
				pad:char
			);
			@global:_hla._ext( "STR_CATR64PAD" );

		catr32:
			procedure
			( 
				dest:string; 
				r:real32; 
				width:int32; 
				decpts:uns32
			);
			@global:_hla._ext( "STR_CATR32" );

		catr32pad:
			procedure
			( 
				dest:string; 
				r:real32; 
				width:int32; 
				decpts:uns32; 
				pad:char
			);
			@global:_hla._ext( "STR_CATR32PAD" );




		cate80:
			procedure
			( 
				dest:string; 
				r:real80; 
				width:int32 
			);
			@global:_hla._ext( "STR_CATE80" );


		cate64:
			procedure
			( 
				dest:string; 
				r:real64; 
				width:int32 
			);
			@global:_hla._ext( "STR_CATE64" );


		cate32:
			procedure
			( 
				dest:string; 
				r:real32; 
				width:int32 
			);
			@global:_hla._ext( "STR_CATE32" );



		// The following macros provide the same interface to cate32, cate64,
		// and cate80 as the plain (without size/fill char) integer output
		// routines:
			
		
		#macro _cate80( _cate80_s_, _cate80_r_ );
		
			@global:str.cate80( _cate80_s_, _cate80_r_, 28 )
			
		#endmacro

		#macro _cate64( _cate64_s_, _cate64_r_ );
		
			@global:str.cate64( _cate64_s_, _cate64_r_, 22 )
			
		#endmacro

		#macro _cate32( _cate32_s_, _cate32_r_ );
		
			@global:str.cate32( _cate32_s_, _cate32_r_, 15 )
			
		#endmacro


		// The following macros provide the same interface (for the cat macro)
		// as the integerSize functions:
		
		#macro cate80_( _cate80_s_, _cate80_r_, _cate80_w_, _cate80_f_ );
		
			@global:str.cate80( _cate80_s_, _cate80_r_, _cate80_w_ )
			
		#endmacro


		#macro cate64_( _cate64_s_, _cate64_r_, _cate64_w_, _cate64_f_ );
		
			@global:str.cate64( _cate64_s_, _cate64_r_, _cate64_w_ )
			
		#endmacro


		#macro cate32_( _cate32_s_, _cate32_r_, _cate32_w_, _cate32_f_ );
		
			@global:str.cate32( _cate32_s_, _cate32_r_, _cate32_w_ )
			
		#endmacro



		#macro zlen( z );
		
			#print( "WARNING! str.zlen is deprecated, use zstr.len instead" )
			@global:zstr.len(z)
			
		#endmacro
		
		#macro zcmp( z );
		
			#print( "WARNING! str.zcmp is deprecated, use zstr.cmpstr instead" )
			@global:zstr.zcmp(z)
			
		#endmacro
		
		#macro zcpy( z );
		
			#print( "WARNING! str.zcpy is deprecated, use zstr.cpy instead" )
			@global:zstr.cpy(z)
			
		#endmacro
		
		#macro zcat( z );
		
			#print( "WARNING! str.zcat is deprecated, use zstr.cat instead" )
			@global:zstr.cpy(z)
			
		#endmacro
		



const
	validPutType :boolean[ @global:hla.sizePTypes ] :=
		[
			@global:false,		// Undefined
			@global:true,		// tBoolean 	//1
			@global:false,		// enum			//2
			@global:true,		// tUns8,		//3
			@global:true,		// tUns16,		//4
			@global:true,		// tUns32,		//5
			@global:true,		// tUns64,		//6
			@global:true,		// tUns128,		//7
			@global:true,		// tByte,		//8
			@global:true,		// tWord,		//9
			@global:true,		// tDWord,		//10
			@global:true,		// tQWord,		//11
			@global:true,		// tTByte,		//12
			@global:true,		// tLWord,		//13
			@global:true,		// tInt8,		//14
			@global:true,		// tInt16,		//15
			@global:true,		// tInt32,		//16
			@global:true,		// tInt64,		//17
			@global:true,		// tInt128,		//18
			@global:true,		// tChar, 		//19
			@global:false,		// tWChar,		//20
			@global:true,		// tReal32,		//21
			@global:true,		// tReal64, 	//22
			@global:true,		// tReal80,		//23
			@global:false,		// tReal128,	//24
			@global:true,		// tString,		//25
			@global:true,		// tZString,	//26
			@global:false,		// tWString,	//27
			@global:true,		// tCset,		//28
			@global:false,		// tArray,		//29
			@global:false,		// tRecord,		//30
			@global:false,		// tUnion,		//31
			@global:false,		// tRegEx		//32
			@global:true,		// tClass,		//33
			@global:false,		// tProcptr,	//34
			@global:false,		// tThunk,		//35
			@global:true,		// tPointer		//36
			@global:false,		// tLabel		//37
			@global:false,		// tProc		//38
			@global:false,		// tMethod		//39
			@global:false,		// tClassProc	//40
			@global:false,		// tClassIter	//41
			@global:false,		// tIterator	//42
			@global:false,		// tProgram		//43
			@global:false,		// tMacro		//44
			@global:false,		// tOverloads	//45
			@global:false,		// tText		//46
			@global:false,		// tRegExMac	//47
			@global:false,		// tNamespace	//48
			@global:false,		// tSegment		//49
			@global:false,		// tAnonRec		//50
			@global:false,		// tAnonUnion	//51
			@global:false,		// tVariant		//52
			@global:false		// tError		//53
		];

	validPutSizeType :boolean[ @global:hla.sizePTypes ] :=
		[
			@global:false,		// Undefined
			@global:false,		// tBoolean 	//1
			@global:false,		// enum			//2
			@global:true,		// tUns8,		//3
			@global:true,		// tUns16,		//4
			@global:true,		// tUns32,		//5
			@global:true,		// tUns64,		//6
			@global:true,		// tUns128,		//7
			@global:true,		// tByte,		//8
			@global:true,		// tWord,		//9
			@global:true,		// tDWord,		//10
			@global:true,		// tQWord,		//11
			@global:true,		// tTByte,		//12
			@global:true,		// tLWord,		//13
			@global:true,		// tInt8,		//14
			@global:true,		// tInt16,		//15
			@global:true,		// tInt32,		//16
			@global:true,		// tInt64,		//17
			@global:true,		// tInt128,		//18
			@global:true,		// tChar, 		//19
			@global:false,		// tWChar,		//20
			@global:true,		// tReal32,		//21
			@global:true,		// tReal64, 	//22
			@global:true,		// tReal80,		//23
			@global:false,		// tReal128,	//24
			@global:true,		// tString,		//25
			@global:true,		// tZString,	//26
			@global:false,		// tWString,	//27
			@global:false,		// tCset,		//28
			@global:false,		// tArray,		//29
			@global:false,		// tRecord,		//30
			@global:false,		// tUnion,		//31
			@global:false,		// tRegEx		//32
			@global:false,		// tClass,		//33
			@global:false,		// tProcptr,	//34
			@global:false,		// tThunk,		//35
			@global:true,		// tPointer		//36
			@global:false,		// tLabel		//37
			@global:false,		// tProc		//38
			@global:false,		// tMethod		//39
			@global:false,		// tClassProc	//40
			@global:false,		// tClassIter	//41
			@global:false,		// tIterator	//42
			@global:false,		// tProgram		//43
			@global:false,		// tMacro		//44
			@global:false,		// tOverloads	//45
			@global:false,		// tText		//46
			@global:false,		// tRegExMac	//47
			@global:false,		// tNamespace	//48
			@global:false,		// tSegment		//49
			@global:false,		// tAnonRec		//50
			@global:false,		// tAnonUnion	//51
			@global:false,		// tVariant		//52
			@global:false		// tError		//53
		];										  




	validPutSize2Type :boolean[ @global:hla.sizePTypes ] :=
		[
			@global:false,		// Undefined
			@global:false,		// tBoolean 	//1
			@global:false,		// enum			//2
			@global:false,		// tUns8,		//3
			@global:false,		// tUns16,		//4
			@global:false,		// tUns32,		//5
			@global:false,		// tUns64,		//6
			@global:false,		// tUns128,		//7
			@global:false,		// tByte,		//8
			@global:false,		// tWord,		//9
			@global:false,		// tDWord,		//10
			@global:false,		// tQWord,		//11
			@global:false,		// tTByte,		//12
			@global:false,		// tLWord,		//13
			@global:false,		// tInt8,		//14
			@global:false,		// tInt16,		//15
			@global:false,		// tInt32,		//16
			@global:false,		// tInt64,		//17
			@global:false,		// tInt128,		//18
			@global:false,		// tChar, 		//19
			@global:false,		// tWChar,		//20
			@global:true,		// tReal32,		//21
			@global:true,		// tReal64, 	//22
			@global:true,		// tReal80,		//23
			@global:false,		// tReal128,	//24
			@global:false,		// tString,		//25
			@global:false,		// tZString,	//26
			@global:false,		// tWString,	//27
			@global:false,		// tCset,		//28
			@global:false,		// tArray,		//29
			@global:false,		// tRecord,		//30
			@global:false,		// tUnion,		//31
			@global:false,		// tRegEx		//32
			@global:false,		// tClass,		//33
			@global:false,		// tProcptr,	//34
			@global:false,		// tThunk,		//35
			@global:false,		// tPointer		//36
			@global:false,		// tLabel		//37
			@global:false,		// tProc		//38
			@global:false,		// tMethod		//39
			@global:false,		// tClassProc	//40
			@global:false,		// tClassIter	//41
			@global:false,		// tIterator	//42
			@global:false,		// tProgram		//43
			@global:false,		// tMacro		//44
			@global:false,		// tOverloads	//45
			@global:false,		// tText		//46
			@global:false,		// tRegExMac	//47
			@global:false,		// tNamespace	//48
			@global:false,		// tSegment		//49
			@global:false,		// tAnonRec		//50
			@global:false,		// tAnonUnion	//51
			@global:false,		// tVariant		//52
			@global:false		// tError		//53
		];										  



	putFunc :string[ @global:hla.sizePTypes ] :=
		[
			"",				// Undefined
			"catbool",		// tBoolean 	//1
			"",				// enum			//2
			"catu8",		// tUns8,		//3
			"catu16",		// tUns16,		//4
			"catu32",		// tUns32,		//5
			"catu64",		// tUns64,		//6
			"catu128",		// tUns128,		//7
			"catb",			// tByte,		//8
			"catw",			// tWord,		//9
			"catd",			// tDWord,		//10
			"catq",			// tQWord,		//11
			"cattb",		// tTByte,		//12
			"catl",			// tLWord,		//13
			"cati8",		// tInt8,		//14
			"cati16",		// tInt16,		//15
			"cati32",		// tInt32,		//16
			"cati64",		// tInt64,		//17
			"cati128",		// tInt128,		//18
			"catc",			// tChar, 		//19
			"",				// tWChar,		//20
			"_cate32",		// tReal32,		//21
			"_cate64",		// tReal64, 	//22
			"_cate80",		// tReal80,		//23
			"",				// tReal128,	//24
			"cats",			// tString,		//25
			"catzs",		// tZString,	//26
			"",				// tWString,	//27
			"catcset",		// tCset,		//28
			"",				// tArray,		//29
			"",				// tRecord,		//30
			"",				// tUnion,		//31
			"",				// tRegEx		//32
			"",				// tClass,		//33
			"",				// tProcptr,	//34
			"",				// tThunk,		//35
			"catd",			// tPointer		//36
			"",				// tLabel		//37
			"",				// tProc		//38
			"",				// tMethod		//39
			"",				// tClassProc	//40
			"",				// tClassIter	//41
			"",				// tIterator	//42
			"",				// tProgram		//43
			"",				// tMacro		//44
			"",				// tOverloads	//45
			"",				// tText		//46
			"",				// tRegExMac	//47
			"",				// tNamespace	//48
			"",				// tSegment		//49
			"",				// tAnonRec		//50
			"",				// tAnonUnion	//51
			"",				// tVariant		//52
			""				// tError		//53
		];


	putSizeFunc :string[ @global:hla.sizePTypes ] :=
		[
			"",					// Undefined
			"",					// tBoolean 	//1
			"",					// enum			//2
			"catu8Size",		// tUns8,		//3
			"catu16Size",		// tUns16,		//4
			"catu32Size",		// tUns32,		//5
			"catu64Size",		// tUns64,		//6
			"catu128Size",		// tUns128,		//7
			"cath8Size",		// tByte,		//8
			"cath16Size",		// tWord,		//9
			"cath32Size",		// tDWord,		//10
			"cath64Size",		// tQWord,		//11
			"cath80Size",		// tTByte,		//12
			"cath128Size",		// tLWord,		//13
			"cati8Size",		// tInt8,		//14
			"cati16Size",		// tInt16,		//15
			"cati32Size",		// tInt32,		//16
			"cati64Size",		// tInt64,		//17
			"cati128Size",		// tInt128,		//18
			"catcSize",			// tChar, 		//19
			"",					// tWChar,		//20
			"cate32_",			// tReal32,		//21
			"cate64_",			// tReal64, 	//22
			"cate80_",			// tReal80,		//23
			"",					// tReal128,	//24
			"catsSize",			// tString,		//25
			"catzsSize",		// tZString,	//26
			"",					// tWString,	//27
			"",					// tCset,		//28
			"",					// tArray,		//29
			"",					// tRecord,		//30
			"",					// tUnion,		//31
			"",					// tRegEx		//32
			"",					// tClass,		//33
			"",					// tProcptr,	//34
			"",					// tThunk,		//35
			"catdSize",			// tPointer		//36
			"",					// tLabel		//37
			"",					// tProc		//38
			"",					// tMethod		//39
			"",					// tClassProc	//40
			"",					// tClassIter	//41
			"",					// tIterator	//42
			"",					// tProgram		//43
			"",					// tMacro		//44
			"",					// tOverloads	//45
			"",					// tText		//46
			"",					// tRegExMac	//47
			"",					// tNamespace	//48
			"",					// tSegment		//49
			"",					// tAnonRec		//50
			"",					// tAnonUnion	//51
			"",					// tVariant		//52
			""					// tError		//53
		];										  


	putSize2Func :string[ @global:hla.sizePTypes ] :=
		[
			"",					// Undefined
			"",					// tBoolean 	//1
			"",					// enum			//2
			"",					// tUns8,		//3
			"",					// tUns16,		//4
			"",					// tUns32,		//5
			"",					// tUns64,		//6
			"",					// tUns128,		//7
			"",					// tByte,		//8
			"",					// tWord,		//9
			"",					// tDWord,		//10
			"",					// tQWord,		//11
			"",					// tLWord,		//12
			"",					// tLWord,		//13
			"",					// tInt8,		//14
			"",					// tInt16,		//15
			"",					// tInt32,		//16
			"",					// tInt64,		//17
			"",					// tInt128,		//18
			"",					// tChar, 		//19
			"",					// tWChar,		//20
			"catr32pad",		// tReal32,		//21
			"catr64pad",		// tReal64, 	//22
			"catr80pad",		// tReal80,		//23
			"",					// tReal128,	//24
			"",					// tString,		//25
			"",					// tZString,	//26
			"",					// tWString,	//27
			"",					// tCset,		//28
			"",					// tArray,		//29
			"",					// tRecord,		//30
			"",					// tUnion,		//31
			"",					// tRegEx		//32
			"",					// tClass,		//33
			"",					// tProcptr,	//34
			"",					// tThunk,		//35
			"",					// tPointer		//36
			"",					// tLabel		//37
			"",					// tProc		//38
			"",					// tMethod		//39
			"",					// tClassProc	//40
			"",					// tClassIter	//41
			"",					// tIterator	//42
			"",					// tProgram		//43
			"",					// tMacro		//44
			"",					// tOverloads	//45
			"",					// tText		//46
			"",					// tRegExMac	//47
			"",					// tNamespace	//48
			"",					// tSegment		//49
			"",					// tAnonRec		//50
			"",					// tAnonUnion	//51
			"",					// tVariant		//52
			""					// tError		//53
		];										  


	// str.put macro:
	// (note: use global VAL objects to speed up processing:
	
	val
		_theParm_:string;
		_theDest_:string;
		
	#macro put( _destStr_, _parameters_[] ); 

		?@global:str._theDest_ := @string:_destStr_;
		push( eax );
		mov( _destStr_, eax );
		mov( 0, (type str.strRec [eax]).length );
		mov( 0, (type byte [eax]) );
		pop( eax );
		?@global:str._theParm_ :string := @string:_destStr_;
		#for( @global:str._theParm_ in _parameters_ )

			@global:hla.put
			( 
				str, 
				@global:str._theDest_, 
				@eval(@global:str._theParm_) 
			)

		#endfor

	#endmacro



	// str.put2 macro:
	
	val
		_theParm2_:string;
		_theDest2_:string;

	#macro put2( _destStr_, _parameters_[] ):_sv_; 

		?@global:str._theDest2_ := @string:_destStr_;
			
		#for( @global:str._theParm2_ in _parameters_ )

			@global:hla.put
			( 
				str, 
				@global:str._theDest2_, 
				@eval(@global:str._theParm2_) 
			)

		#endfor

	#endmacro


	readonly
		CmdLnDelimiters	:cset; @global:_hla._ext( "STR_CMDLNDELIMITERS" );






//////////////////// TODOs //////////////////////////////////////////////
//                      Left to implement                              //
/////////////////////////////////////////////////////////////////////////


	// The following macros write "function overloading" macros
	// that are used to create function overloads for all the
	// string/pattern matching functions.
	//
	// The implementation is somewhat ugly because the HLA
	// macro expander copies all text between #macro and #endmacro
	// without any translation when recording a macro. In the
	// following examples, the code needs to replace certain names
	// within the body of the macro being generated. To accomplish this,
	// the following code first creates a string object that is the
	// macro definition (complete with injected strings) and then
	// expands that string as text to generate the actual macro.
	
	val 
		parmCnt := 0;
		fName	:string := "";
	
	#macro strpat1( string macroName ):theMacro;
	
		?theMacro :text :=
		
			"#macro " + macroName + "( parms[] ); "
		
				"?@global:str.parmCnt := @elements( parms ); "
				"#if( @global:str.parmCnt = 1 ) "
				
					"@text( ""@global:str." + macroName + "1""  ) "
					"( "
						"@text( parms[0] ) "
					") "
					
				"#elseif( @global:str.parmCnt = 2 ) "
				
					"@text( ""@global:str." + macroName + "2"" ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ) "
					") "
					
				"#elseif( @global:str.parmCnt = 3 ) "
				
					"@text( ""@global:str." + macroName + "3"" ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ), " 
						"@text( parms[2] ) "
					") "
					
				"#else "
				
					"#error "
					"( " 
						"""Could not match parameters to the '" +
						macroName + 
						"' function"" " 
					") "
					
				"#endif "
				
			"#endmacro ";
			
		theMacro
		
	#endmacro
	
	
	
	#macro strpat2( string macroName ):theMacro;
	
		?theMacro :text :=
		
			"#macro " + macroName + "( parms[] ); "
		
				"?@global:str.parmCnt := @elements( parms ); "
				"#if( @global:str.parmCnt = 2 ) "
				
					"@text( ""@global:str." + macroName + "2""  ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ) "
					") "
					
				"#elseif( @global:str.parmCnt = 3 ) "
				
					"@text( ""@global:str." + macroName + "3"" ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ), " 
						"@text( parms[2] ) "
					") "
					
				"#elseif( @global:str.parmCnt = 4 ) "
				
					"@text( ""@global:str." + macroName + "4"" ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ), " 
						"@text( parms[2] ), " 
						"@text( parms[3] ) "
					") "
					
				"#else "
				
					"#error "
					"( " 
						"""Could not match parameters to the '" +
						macroName + 
						"' function"" " 
					") "
					
				"#endif "
				
			"#endmacro ";
			
		theMacro
		
	#endmacro
	
	
	#macro strpat3( string macroName ):theMacro;
	
		?theMacro :text :=
		
			"#macro " + macroName + "( parms[] ); "
		
				"?@global:str.parmCnt := @elements( parms ); "
				"#if( @global:str.parmCnt = 3 ) "
				
					"@text( ""@global:str." + macroName + "3""  ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ), " 
						"@text( parms[2] ) "
					") "
					
				"#elseif( @global:str.parmCnt = 4 ) "
				
					"@text( ""@global:str." + macroName + "4"" ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ), " 
						"@text( parms[2] ), " 
						"@text( parms[3] ) "
					") "
					
				"#elseif( @global:str.parmCnt = 5 ) "
				
					"@text( ""@global:str." + macroName + "5"" ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ), " 
						"@text( parms[2] ), " 
						"@text( parms[3] ), " 
						"@text( parms[4] ) "
					") "
					
				"#else "
				
					"#error "
					"( " 
						"""Could not match parameters to the '" +
						macroName + 
						"' function"" " 
					") "
					
				"#endif "
				
			"#endmacro ";
			
		theMacro
		
	#endmacro
	
	
	
	#macro strpat4( string macroName ):theMacro;
	
		?theMacro :text :=
		
			"#macro " + macroName + "( parms[] ); "
		
				"?@global:str.parmCnt := @elements( parms ); "
				"#if( @global:str.parmCnt = 4 ) "
				
					"@text( ""@global:str." + macroName + "4""  ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ), " 
						"@text( parms[2] ), " 
						"@text( parms[3] ) "
					") "
					
				"#elseif( @global:str.parmCnt = 5 ) "
				
					"@text( ""@global:str." + macroName + "5"" ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ), " 
						"@text( parms[2] ), " 
						"@text( parms[3] ), " 
						"@text( parms[4] ) "
					") "
					
				"#elseif( @global:str.parmCnt = 6 ) "
				
					"@text( ""@global:str." + macroName + "6"" ) "
					"( "
						"@text( parms[0] ), " 
						"@text( parms[1] ), " 
						"@text( parms[2] ), " 
						"@text( parms[3] ), " 
						"@text( parms[4] ), " 
						"@text( parms[5] ) "
					") "
					
				"#else "
				
					"#error "
					"( " 
						"""Could not match parameters to the '" +
						macroName + 
						"' function"" " 
					") "
					
				"#endif "
				
			"#endmacro ";
			
		theMacro
		
	#endmacro
	
	

	// Cset pattern matching procedures:
	

			
	strpat2( oneCset );
	proc
		
		
		oneCset2:
			procedure( src:string; cst:cset ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONECSET2" );
										
		oneCset3:
			procedure( src:string; cst:cset; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONECSET3" );
										
		oneCset4:
			procedure( src:string; cst:cset; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONECSET4" );
										


	strpat2( upToCset );
	proc
				
		upToCset2:
			procedure( src:string; cst:cset ) {@returns( "@c" )};	// Also eax
			@global:_hla._ext( "STR_UPTOCSET2" );

		upToCset3:
			procedure( src:string; cst:cset; rem:string ) {@returns( "@c" )};	// Also eax
			@global:_hla._ext( "STR_UPTOCSET3" );

		upToCset4:
			procedure( src:string; cst:cset; rem:string; mat:string ) {@returns( "@c" )};	// Also eax
			@global:_hla._ext( "STR_UPTOCSET4" );




	strpat2( zeroOrOneCset );
	proc
				
		zeroOrOneCset2:
			procedure( src:string; cst:cset ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORONECSET2" );
			
		zeroOrOneCset3:
			procedure( src:string; cst:cset; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORONECSET3" );
			
		zeroOrOneCset4:
			procedure( src:string; cst:cset; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORONECSET4" );
			


	strpat2( zeroOrMoreCset );
	proc
				
		zeroOrMoreCset2:
			procedure( src:string; cst:cset ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMORECSET2" );
			
		zeroOrMoreCset3:
			procedure( src:string; cst:cset; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMORECSET3" );
			
		zeroOrMoreCset4:
			procedure( src:string; cst:cset; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMORECSET4" );
			


	strpat2( oneOrMoreCset );
	proc
				
		oneOrMoreCset2:
			procedure( src:string; cst:cset ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMORECSET2" );
			
		oneOrMoreCset3:
			procedure( src:string; cst:cset; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMORECSET3" );
			
		oneOrMoreCset4:
			procedure( src:string; cst:cset; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMORECSET4" );

			


	strpat3( exactlyNCset );
	proc
				
		exactlyNCset3:
			procedure( src:string; cst:cset; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNCSET3" );

		exactlyNCset4:
			procedure( src:string; cst:cset; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNCSET4" );

		exactlyNCset5:
			procedure( src:string; cst:cset; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNCSET5" );




	strpat3( firstNCset );
	proc
				
		firstNCset3:
			procedure( src:string; cst:cset; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRSTNCSET3" );

		firstNCset4:
			procedure( src:string; cst:cset; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRSTNCSET4" );

		firstNCset5:
			procedure( src:string; cst:cset; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRSTNCSET5" );



	strpat3( norLessCset );
	proc
				
		norLessCset3:
			procedure( src:string; cst:cset; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORLESSCSET3" );
			
		norLessCset4:
			procedure( src:string; cst:cset; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORLESSCSET4" );
			
		norLessCset5:
			procedure( src:string; cst:cset; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORLESSCSET5" );
			



	strpat3( norMoreCset );
	proc
				
		norMoreCset3:
			procedure( src:string; cst:cset; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORMORECSET3" );
			
		norMoreCset4:
			procedure( src:string; cst:cset; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORMORECSET4" );
			
		norMoreCset5:
			procedure( src:string; cst:cset; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORMORECSET5" );
			




	strpat4( ntoMCset );
	proc
				
		ntoMCset4:
			procedure( src:string; cst:cset; n:uns32; m:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NTOMCSET4" );
			
		ntoMCset5:
			procedure( src:string; cst:cset; n:uns32; m:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NTOMCSET5" );
			
		ntoMCset6:
			procedure
		( 
			src	:string; 
			cst	:cset; 
			n	:uns32; 
			m	:uns32; 
			rem	:string; 
			mat	:string 
		) {@returns( "@c" )};
			@global:_hla._ext( "STR_NTOMCSET6" );
			


	strpat4( exactlyNtoMCset );
	proc
				
		exactlyNtoMCset4:
			procedure( src:string; cst:cset; n:uns32; m:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNTOMCSET4" );
			
		exactlyNtoMCset5:
			procedure( src:string; cst:cset; n:uns32; m:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNTOMCSET5" );
			
		exactlyNtoMCset6:
			procedure
		( 
			src	:string; 
			cst	:cset; 
			n	:uns32; 
			m	:uns32; 
			rem	:string; 
			mat	:string 
		) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNTOMCSET6" );
			




		// Character matching routines.


	strpat2( oneChar );
	proc
				
		oneChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONECHAR2" );

		oneChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONECHAR3" );

		oneChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONECHAR4" );



	strpat2( upToChar );
	proc
				
		upToChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOCHAR2" );

		upToChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOCHAR3" );

		upToChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOCHAR4" );



	strpat2( zeroOrOneChar );
	proc
				
		zeroOrOneChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORONECHAR2" );
			
		zeroOrOneChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORONECHAR3" );
			
		zeroOrOneChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORONECHAR4" );
			


	strpat2( zeroOrMoreChar );
	proc
				
		zeroOrMoreChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMORECHAR2" );
			
		zeroOrMoreChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMORECHAR3" );
			
		zeroOrMoreChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMORECHAR4" );
			


	strpat2( oneOrMoreChar );
	proc
				
		oneOrMoreChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMORECHAR2" );
			
		oneOrMoreChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMORECHAR3" );
			
		oneOrMoreChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMORECHAR4" );
			


	strpat3( exactlyNChar );
	proc
				
		exactlyNChar3:
			procedure( src:string; c:char; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNCHAR3" );
			
		exactlyNChar4:
			procedure( src:string; c:char; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNCHAR4" );
			
		exactlyNChar5:
			procedure( src:string; c:char; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNCHAR5" );
			


	strpat3( firstNChar );
	proc
				
		firstNChar3:
			procedure( src:string; c:char; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRSTNCHAR3" );

		firstNChar4:
			procedure( src:string; c:char; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRSTNCHAR4" );

		firstNChar5:
			procedure( src:string; c:char; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRSTNCHAR5" );



	strpat3( norLessChar );
	proc
				
		norLessChar3:
			procedure( src:string; c:char; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORLESSCHAR3" );
			
		norLessChar4:
			procedure( src:string; c:char; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORLESSCHAR4" );
			
		norLessChar5:
			procedure( src:string; c:char; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORLESSCHAR5" );
			


	strpat3( norMoreChar );
	proc
				
		norMoreChar3:
			procedure( src:string; c:char; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORMORECHAR3" );
			
		norMoreChar4:
			procedure( src:string; c:char; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORMORECHAR4" );
			
		norMoreChar5:
			procedure( src:string; c:char; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORMORECHAR5" );
			


	strpat4( ntoMChar );
	proc
				
		ntoMChar4:
			procedure( src:string; c:char; n:uns32; m:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NTOMCHAR4" );
			
		ntoMChar5:
			procedure( src:string; c:char; n:uns32; m:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NTOMCHAR5" );
			
		ntoMChar6:
			procedure
			( 
				src:string; 
				c:char; 
				n:uns32; 
				m:uns32; 
				rem:string; 
				mat:string 
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_NTOMCHAR6" );
			


	strpat4( exactlyNtoMChar );
	proc
				
		exactlyNtoMChar4:
			procedure( src:string; c:char; n:uns32; m:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNTOMCHAR4" );

		exactlyNtoMChar5:
			procedure( src:string; c:char; n:uns32; m:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNTOMCHAR5" );

		exactlyNtoMChar6:
			procedure
			( 
				src	:string; 
				c	:char; 
				n	:uns32; 
				m	:uns32; 
				rem	:string; 
				mat	:string 
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNTOMCHAR6" );





		// Case insensitive Character matching routines.


	strpat2( oneiChar );
	proc
				
		oneiChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEICHAR2" );

		oneiChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEICHAR3" );

		oneiChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEICHAR4" );
			


	strpat2( upToiChar );
	proc
				
		upToiChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOICHAR2" );

		upToiChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOICHAR3" );

		upToiChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOICHAR4" );



	strpat2( zeroOrOneiChar );
	proc
				
		zeroOrOneiChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORONEICHAR2" );
			
		zeroOrOneiChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORONEICHAR3" );
			
		zeroOrOneiChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORONEICHAR4" );
			


	strpat2( zeroOrMoreiChar );
	proc
				
		zeroOrMoreiChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMOREICHAR2" );
			
		zeroOrMoreiChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMOREICHAR3" );
			
		zeroOrMoreiChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMOREICHAR4" );
			


	strpat2( oneOrMoreiChar );
	proc
				
		oneOrMoreiChar2:
			procedure( src:string; c:char ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMOREICHAR2" );
			
		oneOrMoreiChar3:
			procedure( src:string; c:char; rem:string ) {@returns( "@c" )};	
			@global:_hla._ext( "STR_ONEORMOREICHAR3" );
			
		oneOrMoreiChar4:
			procedure( src:string; c:char; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMOREICHAR4" );
			


	strpat3( exactlyNiChar );
	proc
				
		exactlyNiChar3:
			procedure( src:string; c:char; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNICHAR3" );

		exactlyNiChar4:
			procedure( src:string; c:char; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNICHAR4" );

		exactlyNiChar5:
			procedure( src:string; c:char; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNICHAR5" );



	strpat3( firstNiChar );
	proc
				
		firstNiChar3:
			procedure( src:string; c:char; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRSTNICHAR3" );

		firstNiChar4:
			procedure( src:string; c:char; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRSTNICHAR4" );

		firstNiChar5:
			procedure( src:string; c:char; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_FIRSTNICHAR5" );



	strpat3( norLessiChar );
	proc
				
		norLessiChar3:
			procedure( src:string; c:char; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORLESSICHAR3" );

		norLessiChar4:
			procedure( src:string; c:char; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORLESSICHAR4" );

		norLessiChar5:
			procedure( src:string; c:char; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORLESSICHAR5" );



	strpat3( norMoreiChar );
	proc
				
		norMoreiChar3:
			procedure( src:string; c:char; n:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORMOREICHAR3" );
			
		norMoreiChar4:
			procedure( src:string; c:char; n:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORMOREICHAR4" );
			
		norMoreiChar5:
			procedure( src:string; c:char; n:uns32; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NORMOREICHAR5" );
			


	strpat4( ntoMiChar );
	proc
				
		ntoMiChar4:
			procedure( src:string; c:char; n:uns32; m:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NTOMICHAR4" );

		ntoMiChar5:
			procedure( src:string; c:char; n:uns32; m:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_NTOMICHAR5" );

		ntoMiChar6:
			procedure
			( 
				src:string; 
				c:char; 
				n:uns32; 
				m:uns32; 
				rem:string; 
				mat:string 
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_NTOMICHAR6" );



	strpat4( exactlyNtoMiChar );
	proc
				
		exactlyNtoMiChar4:
			procedure( src:string; c:char; n:uns32; m:uns32 ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNTOMICHAR4" );

		exactlyNtoMiChar5:
			procedure( src:string; c:char; n:uns32; m:uns32; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNTOMICHAR5" );

		exactlyNtoMiChar6:
			procedure
			( 
				src:string; 
				c:char; 
				n:uns32; 
				m:uns32; 
				rem:string; 
				mat:string 
			) {@returns( "@c" )};
			@global:_hla._ext( "STR_EXACTLYNTOMICHAR6" );


		
		// String matching procedures:


	strpat2( matchStr );
	proc
				
		matchStr2:
			procedure( src:string; s:string )	// Same as prefix! 
				{@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHSTR2" );
			
		matchStr3:
			procedure( src:string; s:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHSTR3" );
			
		matchStr4:
			procedure( src:string; s:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHSTR4" );
			


	strpat2( matchToStr );
	proc
				
		matchToStr2:
			procedure( src:string; s:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHTOSTR2" );
			
		matchToStr3:
			procedure( src:string; s:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHTOSTR3" );
			
		matchToStr4:
			procedure( src:string; s:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHTOSTR4" );
			


	strpat2( upToStr );
	proc
				
		upToStr2:
			procedure( src:string; s:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOSTR2" );
			
		upToStr3:
			procedure( src:string; s:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOSTR3" );
			
		upToStr4:
			procedure( src:string; s:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOSTR4" );
			


	strpat2( matchiStr );
	proc
				
		matchiStr2:
			procedure( src:string; s:string )	// Same as iprefix! 
				{@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHISTR2" );
			
		matchiStr3:
			procedure( src:string; s:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHISTR3" );
			
		matchiStr4:
			procedure( src:string; s:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHISTR4" );
			


	strpat2( matchToiStr );
	proc
				
		matchToiStr2:
			procedure( src:string; s:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHTOISTR2" );
			
		matchToiStr3:
			procedure( src:string; s:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHTOISTR3" );
			
		matchToiStr4:
			procedure( src:string; s:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHTOISTR4" );
			


	strpat2( upToiStr );
	proc
				
		upToiStr2:
			procedure( src:string; s:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOISTR2" );

		upToiStr3:
			procedure( src:string; s:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOISTR3" );

		upToiStr4:
			procedure( src:string; s:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_UPTOISTR4" );



	strpat2( matchWord );
	proc
				
		matchWord2:
			procedure( src:string; s:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHWORD2" );
			
		matchWord3:
			procedure( src:string; s:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHWORD3" );
			
		matchWord4:
			procedure( src:string; s:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHWORD4" );
			


	strpat2( matchiWord );
	proc
				
		matchiWord2:
			procedure( src:string; s:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHIWORD2" );

		matchiWord3:
			procedure( src:string; s:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHIWORD3" );

		matchiWord4:
			procedure( src:string; s:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_MATCHIWORD4" );



		// Whitespace and end of string matching procedures:


	strpat1( zeroOrMoreWS );
	proc
				
		zeroOrMoreWS1:
			procedure( src:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMOREWS1" );
			
		zeroOrMoreWS2:
			procedure( src:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMOREWS2" );
			
		zeroOrMoreWS3:
			procedure( src:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ZEROORMOREWS3" );
			


	strpat1( oneOrMoreWS );
	proc
				
		oneOrMoreWS1:
			procedure( src:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMOREWS1" );
			
		oneOrMoreWS2:
			procedure( src:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMOREWS2" );
			
		oneOrMoreWS3:
			procedure( src:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_ONEORMOREWS3" );
			


	strpat1( WSorEOS );
	proc
				
		WSorEOS1:
			procedure( src:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_WSOREOS1" );
			
		WSorEOS2:
			procedure( src:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_WSOREOS2" );
			
		WSorEOS3:
			procedure( src:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_WSOREOS3" );
			


	strpat1( WSthenEOS );
	proc
				
		WSthenEOS1:
			procedure( src:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_WSTHENEOS1" );
			
		WSthenEOS2:
			procedure( src:string; rem:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_WSTHENEOS2" );
			
		WSthenEOS3:
			procedure( src:string; rem:string; mat:string ) {@returns( "@c" )};
			@global:_hla._ext( "STR_WSTHENEOS3" );
		
		
		
		
/////////////////////////////////////////////////////////////////////
///////////
//
//
//
//
//
//
//
//
//	rxMatch2:
//			procedure( s:string; regularExp:string );
//		@returns( "eax" )
//		@global:_hla._ext( "STR_RXMATCH2" );		
//		
//	rxMatch5:
//			procedure
//	( 
//			s			:string; 
//			regularExp	:string; 
//		var	extractStrs	:var; 
//			maxExtracts	:dword;
//		var	numExtracts	:dword 
//	)
//		{@returns( "eax" )};
//		@global:_hla._ext( "STR_RXMATCH5" );		
//		
//
//		
//
//	replace2:
//			procedure( s:string; replacement:string );
//		@global:_hla._ext( "STR_REPLACE" );
//		
//	replace3:
//			procedure( src:string; replacement:string; dest:string );
//		@global:_hla._ext( "STR_REPLACE3" );
//		
//	a_replace:
//			procedure( src:string; replacement:string );
//		@global:_hla._ext( "STR_A_REPLACE" );
//		
//	search:
//			procedure( src:string; srch:string );
//		@returns( "eax" )
//		@global:_hla._ext( "STR_SEARCH" );
//
//
//		
//	volname:
//			procedure( pathname:string; dest:string );
//		@global:_hla._ext( "STR_DRIVENAME" );
//		
//	a_volname:
//			procedure( pathname:string );
//		@returns( "eax" )
//		@global:_hla._ext( "STR_A_DRIVENAME" );
//		






end str;


namespace str;

	proc
		first				:overloads first2("@global:str.first2");
		first				:overloads first3("@global:str.first3");
		
		last				:overloads last3("@global:str.last3");
		last				:overloads last2("@global:str.last2");
		
		truncate			:overloads truncate3("@global:str.truncate3");
		truncate			:overloads truncate2("@global:str.truncate2");
		
		insert				:overloads insert3("@global:str.insert3");
		insert				:overloads insert4("@global:str.insert4");
		
		delete				:overloads delete3("@global:str.delete3");
		delete				:overloads delete4("@global:str.delete4");
		
		delLeadingSpaces	:overloads delLeadingSpaces1("@global:str.delLeadingSpaces1");
		delLeadingSpaces	:overloads delLeadingSpaces2("@global:str.delLeadingSpaces2");
		
		trim				:overloads trim1("@global:str.trim1");
		trim				:overloads trim2("@global:str.trim2");
		
		delTrailingSpaces	:overloads delTrailingSpaces1("@global:str.delTrailingSpaces1");
		delTrailingSpaces	:overloads delTrailingSpaces2("@global:str.delTrailingSpaces2");
		
		prefix				:overloads prefix3("@global:str.prefix3");
		prefix				:overloads prefix2("@global:str.prefix2");
		
		iprefix				:overloads iprefix3("@global:str.iprefix3");
		iprefix				:overloads iprefix2("@global:str.iprefix2");
		
		index				:overloads index3("@global:str.index3");
		index				:overloads index2("@global:str.index2");
		
		iindex				:overloads iindex3("@global:str.iindex3");
		iindex				:overloads iindex2("@global:str.iindex2");
		
		rindex				:overloads rindex3("@global:str.rindex3");
		rindex				:overloads rindex2("@global:str.rindex2");
		
		irindex				:overloads irindex3("@global:str.irindex3");
		irindex				:overloads irindex2("@global:str.irindex2");
		
		chpos				:overloads chpos3("@global:str.chpos3");
		chpos				:overloads chpos2("@global:str.chpos2");
		
		ichpos				:overloads ichpos3("@global:str.ichpos3");
		ichpos				:overloads ichpos2("@global:str.ichpos2");
		
		rchpos				:overloads rchpos3("@global:str.rchpos3");
		rchpos				:overloads rchpos2("@global:str.rchpos2");
		
		irchpos				:overloads irchpos3("@global:str.irchpos3");
		irchpos				:overloads irchpos2("@global:str.irchpos2");

		span				:overloads span3("@global:str.span3");
		span				:overloads span2("@global:str.span2");

		skipInCset			:overloads skipInCset3("@global:str.skipInCset3");
		skipInCset			:overloads skipInCset2("@global:str.skipInCset2");
		
		rspan				:overloads rspan3("@global:str.rspan3");
		rspan				:overloads rspan2("@global:str.rspan2");

		rskipInCset			:overloads rskipInCset3("@global:str.rskipInCset3");
		rskipInCset			:overloads rskipInCset2("@global:str.rskipInCset2");

		brk					:overloads brk3("@global:str.brk3");
		brk					:overloads brk2("@global:str.brk2");

		findInCset			:overloads findInCset3("@global:str.findInCset3");
		findInCset			:overloads findInCset2("@global:str.findInCset2");

		rbrk				:overloads rbrk3("@global:str.rbrk3");
		rbrk				:overloads rbrk2("@global:str.rbrk2");

		rfindInCset			:overloads rfindInCset3("@global:str.rfindInCset3");
		rfindInCset			:overloads rfindInCset2("@global:str.rfindInCset2");

		tokenCnt			:overloads tokenCnt1("@global:str.tokenCnt1");
		tokenCnt			:overloads tokenCnt2("@global:str.tokenCnt2");

		upper				:overloads upper1("@global:str.upper1");
		upper				:overloads upper2("@global:str.upper2");

		lower				:overloads lower1("@global:str.lower1");
		lower				:overloads lower2("@global:str.lower2");

		translate			:overloads translate3("@global:str.translate3");
		translate			:overloads translate4("@global:str.translate4");

		reverse				:overloads reverse1("@global:str.reverse1");
		reverse				:overloads reverse2("@global:str.reverse2");

		cat					:overloads cat2("@global:str.cat2");
		cat					:overloads cat3("@global:str.cat3");

		catsub				:overloads catsub4("@global:str.catsub4");
		catsub				:overloads catsub5("@global:str.catsub5");


end str;


#endif
